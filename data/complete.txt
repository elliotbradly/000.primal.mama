import*asActCtrfrom"../../00.control.unit/control.action";
import*asActTrnfrom"../../01.turn.unit/turn.action";
import*asActColfrom"../../97.collect.unit/collect.action";
import*asActBusfrom"../../99.bus.unit/bus.action";
import*asActVrtfrom"../../act/vurt.action"
import*asActDskfrom"../../act/disk.action"
import*asActPvtfrom"../../act/pivot.action";
import*asActCrdfrom"../../act/cardano.action";
import{ControlModel}from"../control.model";
importControlBitfrom"../fce/control.bit";
importStatefrom"../../99.core/state";
varbit,val,idx,dex,lst,dat,src;
exportconstinitControl=async(cpy:ControlModel,bal:ControlBit,ste:State)=>{
bal.slv({intBit:{idx:"init-control"}});
exportconstupdateControl=async(cpy:ControlModel,bal:ControlBit,ste:State)=>{
exportconstopenControl=(cpy:ControlModel,bal:ControlBit,ste:State)=>{
exportconstcreateControl=(cpy:ControlModel,bal:ControlBit,ste:State)=>{
exportconsttestControl=async(cpy:ControlModel,bal:ControlBit,ste:State)=>{
if(bal.slv!=null)bal.slv({condBit:{idx:"test-control",dat:{}}});
varpatch=(ste,type,bale)=>ste.dispatch({type,bale});
import{Action}from"../99.core/interface/action.interface";
importControlBitfrom"./fce/control.bit";
exportconstINIT_CONTROL="[Controlaction]InitControl";
exportclassInitControlimplementsAction{
readonlytype=INIT_CONTROL;
constructor(publicbale:ControlBit){}
exportconstUPDATE_CONTROL="[Controlaction]UpdateControl";
exportclassUpdateControlimplementsAction{
readonlytype=UPDATE_CONTROL;
constructor(publicbale:ControlBit){}
exportconstOPEN_CONTROL="[Openaction]OpenControl";
exportclassOpenControlimplementsAction{
readonlytype=OPEN_CONTROL;
constructor(publicbale:ControlBit){}
exportconstCREATE_CONTROL="[Createaction]CreateControl";
exportclassCreateControlimplementsAction{
readonlytype=CREATE_CONTROL;
constructor(publicbale:ControlBit){}
exportconstTEST_CONTROL="[Testaction]TestControl";
exportclassTestControlimplementsAction{
readonlytype=TEST_CONTROL;
constructor(publicbale:ControlBit){}
exporttypeActions=|InitControl|UpdateControl
|OpenControl
|CreateControl
|TestControl
export{initControl}from"./buz/control.buzz";
export{updateControl}from"./buz/control.buzz";
export{openControl}from"./buz/control.buzz";
export{createControl}from"./buz/control.buzz";
export{testControl}from"./buz/control.buzz";
importControlfrom"./fce/control.interface";
importControlBitfrom"./fce/control.interface";
exportclassControlModelimplementsControl{
idx:string='111.control';
import*asclonefrom"clone-deep";
import*asActfrom"./control.action";
import{ControlModel}from"./control.model";
import*asBuzzfrom"./control.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:ControlModel=newControlModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.UPDATE_CONTROL:
returnBuzz.updateControl(clone(model),act.bale,state);
caseAct.INIT_CONTROL:
returnBuzz.initControl(clone(model),act.bale,state);
caseAct.OPEN_CONTROL:
returnBuzz.openControl(clone(model),act.bale,state);
caseAct.CREATE_CONTROL:
returnBuzz.createControl(clone(model),act.bale,state);
caseAct.TEST_CONTROL:
returnBuzz.testControl(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassControlUnit{
constructor(state:State){
exportdefaultinterfaceControlBit{
idx:string;
src?:string;
val?:number;
dat?:any;
slv?:Function;
bit?:any;
lst?:any[];
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
exportdefaultinterfaceControlBit{
idx:string;
src?:string;
val?:number;
dat?:any;
slv?:Function;
bit?:any;
lst?:any[];
importControlBitfrom"./control.bit";
exportdefaultinterfaceControl{
global.CONTROL=require("../dist/111.control/hunt");
global.CONTROL.ActCtl=require("../dist/111.control/00.control.unit/control.action");
import*asActTrnfrom"../../01.turn.unit/turn.action";
import*asActColfrom"../../97.collect.unit/collect.action";
import*asActBusfrom"../../99.bus.unit/bus.action";
import*asActVrtfrom"../../act/vurt.action"
import*asActDskfrom"../../act/disk.action"
import*asActPvtfrom"../../act/pivot.action";
import*asActCrdfrom"../../act/cardano.action";
import*asActBlkfrom"../../act/block.action";
varbit,val,idx,dex,lst,dat,src;
exportconstinitTurn=async(cpy:TurnModel,bal:TurnBit,ste:State)=>{
bal.slv({intBit:{idx:"init-turn"}});
exportconstupdateTurn=async(cpy:TurnModel,bal:TurnBit,ste:State)=>{
bit=awaitste.bus(ActBlk.WRITE_BLOCK,{idx:'blk00'})
vardiff=bit.blkBit.dat.diff
if(diff==0){
bal.slv({trnBit:{idx:"update-turn",dat:bit}});
diff
bal.slv({trnBit:{idx:"update-turn",dat:bit}});
exportconstopenTurn=async(cpy:TurnModel,bal:TurnBit,ste:State)=>{
bit=awaitste.bus(ActBlk.OPEN_BLOCK,{idx:'blk00'})
bal.slv({trnBit:{idx:"open-turn",dat:bit}});
exportconstreadTurn=(cpy:TurnModel,bal:TurnBit,ste:State)=>{
debugger
import{TurnModel}from"../turn.model";
importTurnBitfrom"../fce/turn.bit";
importStatefrom"../../99.core/state";
exportdefaultinterfaceTurnBit{
idx:string;
src?:string;
val?:number;
dat?:any;
slv?:Function;
bit?:any;
lst?:any[];
importTurnBitfrom"./turn.bit";
exportdefaultinterfaceTurn{
import{Action}from"../99.core/interface/action.interface";
importTurnBitfrom"./fce/turn.bit";
exportconstINIT_TURN="[Turnaction]InitTurn";
exportclassInitTurnimplementsAction{
readonlytype=INIT_TURN;
constructor(publicbale:TurnBit){}
exportconstUPDATE_TURN="[Turnaction]UpdateTurn";
exportclassUpdateTurnimplementsAction{
readonlytype=UPDATE_TURN;
constructor(publicbale:TurnBit){}
exportconstOPEN_TURN="[Openaction]OpenTurn";
exportclassOpenTurnimplementsAction{
readonlytype=OPEN_TURN;
constructor(publicbale:TurnBit){}
exportconstREAD_TURN="[Readaction]ReadTurn";
exportclassReadTurnimplementsAction{
readonlytype=READ_TURN;
constructor(publicbale:TurnBit){}
exporttypeActions=|InitTurn|UpdateTurn
|OpenTurn
|ReadTurn
export{initTurn}from"./buz/turn.buzz";
export{updateTurn}from"./buz/turn.buzz";
export{openTurn}from"./buz/turn.buzz";
export{readTurn}from"./buz/turn.buzz";
importTurnfrom"./fce/turn.interface";
importTurnBitfrom"./fce/turn.interface";
exportclassTurnModelimplementsTurn{
import*asclonefrom"clone-deep";
import*asActfrom"./turn.action";
import{TurnModel}from"./turn.model";
import*asBuzzfrom"./turn.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:TurnModel=newTurnModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.UPDATE_TURN:
returnBuzz.updateTurn(clone(model),act.bale,state);
caseAct.INIT_TURN:
returnBuzz.initTurn(clone(model),act.bale,state);
caseAct.OPEN_TURN:
returnBuzz.openTurn(clone(model),act.bale,state);
caseAct.READ_TURN:
returnBuzz.readTurn(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassTurnUnit{
constructor(state:State){
import*asActColfrom"../../97.collect.unit/collect.action";
varbit,lst,dat,idx,val,src,dex
exportconstinitCollect=(cpy:CollectModel,bal:CollectBit,ste:State)=>{
exportconstupdateCollect=(cpy:CollectModel,bal:CollectBit,ste:State)=>{
exportconstfetchCollect=(cpy:CollectModel,bal:CollectBit,ste:State)=>{
if(bal.val==null)bal.val=1;
if((bal.bit==null))bal.slv({clcBit:{idx:"fetch-collect-err",src:'no-bit'}});
vartype=bal.bit.split('').slice(-1).pop().toLowerCase();
varcabBit:CaboodleBit=cpy.caboodleBitList[cpy.caboodleBits[type]]
if(bal.val==1)bit=cabBit.bitList[0]
elsebit=cabBit
if(bal.slv!=null)bal.slv({clcBit:{idx:"fetch-collect",dat:bit}});
exportconstreadCollect=async(cpy:CollectModel,bal:CollectBit,ste:State)=>{
if((bal.bit==null))bal.slv({clcBit:{idx:"read-collect-err",src:'no-bit'}});
vartype=bal.bit.split('').slice(-1).pop().toLowerCase();
if(cpy.caboodleBits[type]==null)createCollect(cpy,{idx:type},ste)
varcabBit:CaboodleBit=cpy.caboodleBitList[cpy.caboodleBits[type]]
if(cabBit.bits[bal.idx]==null){
bit=awaitste.hunt(ActCol.WRITE_COLLECT,{idx:bal.idx,bit:bal.bit})
}else{
dat=cabBit.bitList[cabBit.bits[bal.idx]]
if(bal.slv!=null)bal.slv({clcBit:{idx:"read-collect",dat}});
exportconstwriteCollect=async(cpy:CollectModel,bal:CollectBit,ste:State)=>{
vartype=bal.bit.split('').slice(-1).pop().toLowerCase();
if(cpy.caboodleBits[type]==null)createCollect(cpy,{idx:type},ste)
if((bal.bit==null))bal.slv({rskBit:{idx:"write-collect-err",src:'no-bit'}});
varcabBit:CaboodleBit=cpy.caboodleBitList[cpy.caboodleBits[type]]
if(cabBit.bits[bal.idx]==null){
bit=awaitste.hunt(bal.bit,{idx:bal.idx,src:bal.src,dat:bal.dat})
varobjDat=bit[Object.keys(bit)[0]];
dat=objDat.dat
dat.dex=cabBit.bitList.length;
cabBit.bitList.push(dat)
varidx=bal.idx;
if(idx==null)idx=dat.idx
if(idx==null)thrownewError("writecollecthasnoidx")
cabBit.bits[idx]=dat.dex
}else{
varcabDat=cabBit.bitList[cabBit.bits[bal.idx]]
bal.dat
for(varkeyinbal.dat){
if(cabDat==null)cabDat={}
cabDat[key]=bal.dat[key]
cabBit.bitList[cabBit.bits[bal.idx]]=cabDat
if((dat==null)&&(bal.slv!=null))bal.slv({rskBit:{idx:"write-collect-err",src:'no-dat'}});
if(bal.slv!=null)bal.slv({clcBit:{idx:"write-collect",dat}});
exportconstcreateCollect=(cpy:CollectModel,bal:CollectBit,ste:State)=>{
varcabBit:CaboodleBit={idx:bal.idx,dex:0,bits:{},bitList:[]}
cabBit.dex=cpy.caboodleBitList.length
cpy.caboodleBitList.push(cabBit)
cpy.caboodleBits[cabBit.idx]=cabBit.dex;
if(bal.slv!=null)bal.slv({rskBit:{idx:"create-collect",dat:cabBit}});
exportconstremoveCollect=async(cpy:CollectModel,bal:CollectBit,ste:State)=>{
vartype=bal.bit.split('').slice(-1).pop().toLowerCase();
if(cpy.caboodleBits[type]==null)returnbal.slv({rskBit:{idx:"remove-collect-not-present"}});
varcabBit:CaboodleBit=cpy.caboodleBitList[cpy.caboodleBits[type]]
if(cabBit.bits[bal.idx]==null)returnbal.slv({rskBit:{idx:"remove-collect-idx-not-present"}});
bit=awaitste.hunt(bal.bit,{idx:bal.idx,src:bal.src,dat:bal.dat})
varobjDat=bit[Object.keys(bit)[0]];
dat=objDat.dat
dex=dat.dex
for(vari=dex;i<cabBit.bitList.length-1;i++){
varupdate=cabBit.bitList[i]
update.dex-=1
for(varkeyindat){
dat[key]=null
deletecabBit.bits[bal.idx]
varitm=cabBit.bitList.splice(dex,1)
cabBit.dex-=1
if(bal.slv!=null)bal.slv({rskBit:{idx:"remove-collect",dat:cabBit}});
exportconstdeleteCollect=(cpy:CollectModel,bal:CollectBit,ste:State)=>{
exportconstemptyCollect=(cpy:CollectModel,bal:CollectBit,ste:State)=>{
import{CollectModel}from"../collect.model";
importCollectBitfrom"../fce/collect.bit";
importStatefrom"../../99.core/state";
importCaboodleBitfrom"../fce/caboodle.bit";import{read}from"fs";
import{Action}from"../99.core/interface/action.interface";
importCollectBitfrom"./fce/collect.bit";
exportconstINIT_COLLECT="[Collectaction]InitCollect";
exportclassInitCollectimplementsAction{
readonlytype=INIT_COLLECT;
constructor(publicbale:CollectBit){}
exportconstUPDATE_COLLECT="[Collectaction]UpdateCollect";
exportclassUpdateCollectimplementsAction{
readonlytype=UPDATE_COLLECT;
constructor(publicbale:CollectBit){}
exportconstFETCH_COLLECT="[Collectaction]FetchCollect";
exportclassFetchCollectimplementsAction{
readonlytype=FETCH_COLLECT;
constructor(publicbale:CollectBit){}
exportconstREAD_COLLECT="[Readaction]ReadCollect";
exportclassReadCollectimplementsAction{
readonlytype=READ_COLLECT;
constructor(publicbale:CollectBit){}
exportconstWRITE_COLLECT="[Writeaction]WriteCollect";
exportclassWriteCollectimplementsAction{
readonlytype=WRITE_COLLECT;
constructor(publicbale:CollectBit){}
exportconstCREATE_COLLECT="[Createaction]CreateCollect";
exportclassCreateCollectimplementsAction{
readonlytype=CREATE_COLLECT;
constructor(publicbale:CollectBit){}
exportconstREMOVE_COLLECT="[Createaction]RemoveCollect";
exportclassRemoveCollectimplementsAction{
readonlytype=REMOVE_COLLECT;
constructor(publicbale:CollectBit){}
exportconstDELETE_COLLECT="[Createaction]DeleteCollect";
exportclassDeleteCollectimplementsAction{
readonlytype=DELETE_COLLECT;
constructor(publicbale:CollectBit){}
exportconstEMPTY_COLLECT="[Emptyaction]EmptyCollect";
exportclassEmptyCollectimplementsAction{
readonlytype=EMPTY_COLLECT;
constructor(publicbale:CollectBit){}
exporttypeActions=|InitCollect|UpdateCollect
|ReadCollect
|WriteCollect
|CreateCollect
|EmptyCollect
|FetchCollect
|DeleteCollect
|RemoveCollect
export{initCollect}from"./buz/collect.buzz";
export{updateCollect}from"./buz/collect.buzz";
export{readCollect}from"./buz/collect.buzz";
export{writeCollect}from"./buz/collect.buzz";
export{createCollect}from"./buz/collect.buzz";
export{emptyCollect}from"./buz/collect.buzz";
export{fetchCollect}from"./buz/collect.buzz";
export{deleteCollect}from"./buz/collect.buzz";
export{removeCollect}from"./buz/collect.buzz";
importCaboodleBitfrom"./fce/caboodle.bit";
importCollectfrom"./fce/collect.interface";
importCollectBitfrom"./fce/collect.interface";
exportclassCollectModelimplementsCollect{
idx:string;
caboodleBitList:CaboodleBit[]=[];
caboodleBits:any={};
import*asclonefrom"clone-deep";
import*asActfrom"./collect.action";
import{CollectModel}from"./collect.model";
import*asBuzzfrom"./collect.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:CollectModel=newCollectModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.UPDATE_COLLECT:
returnBuzz.updateCollect(clone(model),act.bale,state);
caseAct.INIT_COLLECT:
returnBuzz.initCollect(clone(model),act.bale,state);
caseAct.READ_COLLECT:
returnBuzz.readCollect(clone(model),act.bale,state);
caseAct.WRITE_COLLECT:
returnBuzz.writeCollect(clone(model),act.bale,state);
caseAct.CREATE_COLLECT:
returnBuzz.createCollect(clone(model),act.bale,state);
caseAct.DELETE_COLLECT:
returnBuzz.deleteCollect(clone(model),act.bale,state);
caseAct.REMOVE_COLLECT:
returnBuzz.removeCollect(clone(model),act.bale,state);
caseAct.EMPTY_COLLECT:
returnBuzz.emptyCollect(clone(model),act.bale,state);
caseAct.FETCH_COLLECT:
returnBuzz.fetchCollect(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassCollectUnit{
constructor(state:State){
exportdefaultinterfaceCaboodleBit{
idx:string;
dex:number;
bitList:any[];
bits:any;
exportdefaultinterfaceCollectBit{
idx?:string;
src?:string;
val?:number;
dex?:number;
dat?:any;
bit?:any;
slv?:Function;
importCollectBitfrom"./collect.bit";
importCaboodleBitfrom"./caboodle.bit";
exportdefaultinterfaceCollect{
idx:string;
caboodleBitList:CaboodleBit[];
caboodleBits:any;
import{Action}from"../99.core/interface/action.interface";
importBusBitfrom"./fce/bus.bit";
exportconstINIT_BUS="[Busaction]InitBus";
exportclassInitBusimplementsAction{
readonlytype=INIT_BUS;
constructor(publicbale:BusBit){}
exportconstOPEN_BUS="[Busaction]OpenBus";
exportclassOpenBusimplementsAction{
readonlytype=OPEN_BUS;
constructor(publicbale:BusBit){}
exportconstCONNECT_BUS="[Busaction]ConnectBus";
exportclassConnectBusimplementsAction{
readonlytype=CONNECT_BUS;
constructor(publicbale:BusBit){}
exportconstMESSAGE_BUS="[Busaction]MessageBus";
exportclassMessageBusimplementsAction{
readonlytype=MESSAGE_BUS;
constructor(publicbale:BusBit){}
exportconstUPDATE_BUS="[Busaction]UpdateBus";
exportclassUpdateBusimplementsAction{
readonlytype=UPDATE_BUS;
constructor(publicbale:BusBit){}
exportconstCREATE_BUS="[Busaction]CreateBus";
exportclassCreateBusimplementsAction{
readonlytype=CREATE_BUS;
constructor(publicbale:BusBit){}
exporttypeActions=|InitBus|OpenBus|UpdateBus|ConnectBus|MessageBus|CreateBus;
export{initBus}from"./buz/bus.buzz";
export{openBus}from"./buz/bus.buzz";
export{updateBus}from"./buz/bus.buzz";
export{connectBus}from"./buz/bus.buzz";
export{messageBus}from"./buz/bus.buzz";
export{createBus}from"./buz/bus.buzz";
importBusfrom"./fce/bus.interface";
importBusBitfrom"./fce/bus.interface";
exportclassBusModelimplementsBus{
MQTT:any;
actList:any;
client:any;
bus:Function;
responseSuffix:string='-response'
promises:any={}
import*asclonefrom"clone-deep";
import*asActfrom"./bus.action";
import{BusModel}from"./bus.model";
import*asBuzzfrom"./bus.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:BusModel=newBusModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.UPDATE_BUS:
returnBuzz.updateBus(clone(model),act.bale,state);
caseAct.OPEN_BUS:
returnBuzz.openBus(clone(model),act.bale,state);
caseAct.CONNECT_BUS:
returnBuzz.connectBus(clone(model),act.bale,state);
caseAct.CREATE_BUS:
returnBuzz.createBus(clone(model),act.bale,state);
caseAct.MESSAGE_BUS:
returnBuzz.connectBus(clone(model),act.bale,state);
caseAct.INIT_BUS:
returnBuzz.initBus(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassBusUnit{
constructor(state:State){
import*asActBusfrom"../../99.bus.unit/bus.action";
import*asActColfrom"../../97.collect.unit/collect.action";
import{BusModel}from"../bus.model";
importBusBitfrom"../fce/bus.bit";
importStatefrom"../../99.core/state";
importSfrom"string";
import*asclonefrom"clone-deep";
varlst,idx,bit,src,dat,dex;
exportconstinitBus=(cpy:BusModel,bal:BusBit,ste:State)=>{
cpy.actList=[]
if(bal==null)bal={idx:null}
if(bal.lst==null)bal.lst=[]
if((bal.src!=null)&&(bal.src.constructor==Array))lst=bal.src;
bal.lst.forEach((a)=>{
for(varkeyina){
cpy.actList.push(a[key])
ste.bus=(idx,dat,bit)=>updateBus(cpy,{idx,dat,bit},ste)
if(bal.dat!=null){
cpy.MQTT=bal.dat;
else{
if(lst==null){
if(bal.src!=null)cpy.host=bal.src
cpy.client=cpy.MQTT.connect(cpy.host);
cpy.client.on('message',(tpc,msg)=>{messageBus(cpy,{idx:tpc,src:msg},ste)})
cpy.client.on('connect',()=>{
openBus(cpy,{idx:'init-bus',lst:cpy.actList},ste)
if(bal.slv!=null)bal.slv({intBit:{idx:"init-bus"}})
}else{
varcomplete=(lst)=>{
lst.shift()
if(lst.length!=0)return
if(bal.slv!=null)bal.slv({intBit:{idx:"init-bus"}})
lst.forEach(async(a)=>{
bit=awaitste.hunt(ActCol.WRITE_COLLECT,{idx:a.idx,src:a.src,bit:ActBus.CREATE_BUS})
varclient=bit.clcBit.dat;
client.on('message',(tpc,msg)=>{messageBus(cpy,{idx:tpc,src:msg,bit:a.idx},ste)})
client.on('connect',()=>{
openBus(cpy,{idx:'init-bus',lst:cpy.actList,bit:a.idx},ste)
complete(lst)
exportconstcreateBus=(cpy:BusModel,bal:BusBit,ste:State)=>{
varclient=cpy.MQTT.connect(bal.src);
if(bal.slv!=null)bal.slv({busBit:{idx:"create-bus",dat:client}});
exportconstopenBus=async(cpy:BusModel,bal:BusBit,ste:State)=>{
varout=[]
bal.lst.forEach((a)=>{
if(a==null)return
if(a.includes==null)return
if(a.includes('[')&&a.includes(']')==false)return
out.push(a)
varclient=cpy.client;
if(bal.bit!=null){
bit=awaitste.hunt(ActCol.READ_COLLECT,{idx:bal.bit,bit:ActBus.CREATE_BUS})
client=bit.clcBit.dat
out.forEach((a)=>{
client.subscribe(a,(err)=>{
if(!err){
exportconstconnectBus=(cpy:BusModel,bal:BusBit,ste:State)=>{
varlst=[]
exportconstmessageBus=async(cpy:BusModel,bal:BusBit,ste:State)=>{
if(bal.src!=null)dat=bal.src.toString()
idx=bal.idx
dat=JSON.parse(dat)
varclient=cpy.client;
if(bal.bit!=null){
bit=awaitste.hunt(ActCol.READ_COLLECT,{idx:bal.bit,bit:ActBus.CREATE_BUS})
client=bit.clcBit.dat
if(idx.includes(cpy.responseSuffix)==true){
varresponseIDX=bal.idx;
varobj=cpy.promises[responseIDX];
if(obj.slv!=null)obj.slv(dat);
client.unsubscribe(responseIDX,(err)=>{
if(!err){
}else{
varbit=awaitste.hunt(idx,dat)
varcloneBit=clone(bit)
for(varkeyincloneBit){
varitm=cloneBit[key]
if(itm.dat!=null){
if(itm.dat.bit!=null)itm.dat.bit=null
cloneBit
client.publish(bal.idx+cpy.responseSuffix,JSON.stringify(cloneBit))
exportconstupdateBus=async(cpy:BusModel,bal:BusBit,ste:State)=>{
varclient=cpy.client;
if(bal.bit!=null){
bit=awaitste.hunt(ActCol.READ_COLLECT,{idx:bal.bit,bit:ActBus.CREATE_BUS})
client=bit.clcBit.dat
if((client==null)&&(bal.bit==null)){
bit=awaitste.hunt(ActCol.FETCH_COLLECT,{bit:ActBus.CREATE_BUS})
client=bit.clcBit.dat
varresponseIDX=bal.idx+cpy.responseSuffix;
varslv;
constpromo=newPromise((rslv,rjct)=>(slv=rslv));
varobj={slv:(val0)=>slv(val0)};
cpy.promises[responseIDX]=obj
client.subscribe(responseIDX,(err)=>{
if(!err){
client.publish(bal.idx,JSON.stringify(bal.dat))
returnpromo;
varpatch=(ste,type,bale)=>ste.dispatch({type,bale});
exportdefaultinterfaceBusBit{
idx:string;
val?:number;
lst?:any;
src?:any;
bit?:string;
slv?:Function;
dat?:any;
importBusBitfrom"./bus.bit";
exportdefaultinterfaceBus{
exportinterfaceAction<T=any>{
type:string;
bale?:T;
exportinterfaceAction<T=any>{
type:string;
bale?:T;
exportdefaultinterfaceModel{}
import{BehaviorSubject}from"rx-lite";
import{Subject}from"rx-lite";
import{Action}from"./interface/action.interface";
importUnitModelfrom"../BEE";
import*asEffectfrom"../BEE";
exportdefaultclassStateextendsBehaviorSubject<any>{
publichunt:any;
publicvalue:any;
publicpivot:any;
publicbus:any;
privatedispatcher:Subject=newSubject();
constructor(init:UnitModel=newUnitModel()){
super(init);
this.dispatcher
.scan((state,action)=>this.reducedApp(state,action),init)
.subscribe((state)=>{
super.onNext(state);
reducedApp(nextState:any,key:any){
for(varkinEffect.reducer)Effect.reducer[k](nextState[k],key,this);
returnnextState;
dispatch(value:Action){
varresult=this.dispatcher.onNext(value);
returnresult;
pat(value:Action){
this.dispatch(value);
next(value:any){
this.dispatcher.onNext(value);
exportconstINIT_BLOCK="[Blockaction]InitBlock";
exportconstUPDATE_BLOCK="[Blockaction]UpdateBlock";
exportconstREAD_BLOCK="[Readaction]ReadBlock";
exportconstWRITE_BLOCK="[Writeaction]WriteBlock";
exportconstREMOVE_BLOCK="[Removeaction]RemoveBlock";
exportconstDELETE_BLOCK="[Deleteaction]DeleteBlock";
exportconstCREATE_BLOCK="[Createaction]CreateBlock";
exportconstNOW_BLOCK="[Nowaction]NowBlock";
exportconstOPEN_BLOCK="[Openaction]OpenBlock";
exportconstHASH_BLOCK="[Hashaction]HashBlock";
exportconstINIT_CANVAS="[Canvasaction]InitCanvas";
exportconstUPDATE_CANVAS="[Canvasaction]UpdateCanvas";
exportconstREAD_CANVAS="[Readaction]ReadCanvas";
exportconstWRITE_CANVAS="[Writeaction]WriteCanvas";
exportconstDELETE_CANVAS="[Deleteaction]DeleteCanvas";
exportconstREMOVE_CANVAS="[Removeaction]RemoveCanvas";
exportconstCREATE_CANVAS="[Createaction]CreateCanvas";
exportconstNEST_CANVAS="[Nestaction]NestCanvas";
exportconstINIT_CARDANO="[Cardanoaction]InitCardano";
exportconstUPDATE_CARDANO="[Cardanoaction]UpdateCardano";
exportconstREAD_CARDANO="[Readaction]ReadCardano";
exportconstINIT_CHOICE="[Choiceaction]InitChoice";
exportconstUPDATE_CHOICE="[Choiceaction]UpdateChoice";
exportconstOPEN_CHOICE="[Openaction]OpenChoice";
exportconstKEY_CHOICE="[Keyaction]KeyChoice";
exportconstTOWER_CHOICE="[Toweraction]TowerChoice";
exportconstINIT_CONSOLE="[Consoleaction]InitConsole";
exportconstUPDATE_CONSOLE="[Consoleaction]UpdateConsole";
exportconstREAD_CONSOLE="[Readaction]ReadConsole";
exportconstWRITE_CONSOLE="[Writeaction]WriteConsole";
exportconstREMOVE_CONSOLE="[Removeaction]RemoveConsole";
exportconstDELETE_CONSOLE="[Deleteaction]DeleteConsole";
exportconstCREATE_CONSOLE="[Createaction]CreateConsole";
exportconstINIT_DISK='[Diskaction]InitDisk'
exportconstUPDATE_DISK='[Diskaction]UpdateDisk'
exportconstREAD_DISK='[Diskaction]ReadDisk'
exportconstWRITE_DISK='[Diskaction]WriteDisk'
exportconstINDEX_DISK='[Indexaction]IndexDisk'
exportconstLOAD_LIST_DISK='[Load_listaction]Load_listDisk'
exportconstCOPY_DISK='[Copyaction]CopyDisk'
exportconstFRAME_DISK='[Frameaction]FrameDisk'
exportconstBATCH_DISK='[Batchaction]BatchDisk'
exportconstTRASH_DISK='[Trashaction]TrashDisk'
exportconstENSURE_DISK='[Ensureaction]EnsureDisk'
exportconstDELETE_DISK='[Deleteaction]DeleteDisk'
import{Action}from"../99.core/interface/action.interface";
exportconstINIT_GRAPHIC="[Graphicaction]InitGraphic";
exportconstUPDATE_GRAPHIC="[Graphicaction]UpdateGraphic";
exportconstREAD_GRAPHIC="[Readaction]ReadGraphic";
exportconstWRITE_GRAPHIC="[Writeaction]WriteGraphic";
exportconstCREATE_GRAPHIC="[Createaction]CreateGraphic";
exportconstINIT_GRID="[Gridaction]InitGrid";
exportconstUPDATE_GRID="[Gridaction]UpdateGrid";
exportconstINIT_HEXAGON="[Hexagonaction]InitHexagon";
exportconstUPDATE_HEXAGON="[Hexagonaction]UpdateHexagon";
exportconstREAD_HEXAGON="[Readaction]ReadHexagon";
exportconstWRITE_HEXAGON="[Writeaction]WriteHexagon";
exportconstCREATE_HEXAGON="[Createaction]CreateHexagon";
exportconstINIT_INPUT="[Inputaction]InitInput";
exportconstUPDATE_INPUT="[Inputaction]UpdateInput";
exportconstOPEN_INPUT="[Openaction]OpenInput";
exportconstINIT_PIVOT="[Pivotaction]InitPivot";
exportconstUPDATE_PIVOT="[Pivotaction]UpdatePivot";
exportconstOPEN_PIVOT="[Openaction]OpenPivot";
exportconstRUN_PIVOT="[Runaction]RunPivot";
exportconstEDIT_PIVOT="[Editaction]EditPivot";
exportconstPATCH_PIVOT="[Patchaction]PatchPivot";
exportconstCOUNT_PIVOT="[Patchaction]CountPivot";
exportconstLIST_PIVOT="[Patchaction]ListPivot";
exportconstCREATE_PIVOT="[Patchaction]CreatePivot";
exportconstCONTAINS_PIVOT="[Patchaction]ContainsPivot";
exportconstBUNDLE_PIVOT="[Patchaction]BundlePivot";
exportconstINIT_RENPY="[Renpyaction]InitRenpy";
exportconstUPDATE_RENPY="[Renpyaction]UpdateRenpy";
exportconstOPEN_RENPY="[Renpyaction]OpenRenpy";
exportconstINIT_SHINY="[Shinyaction]InitShiny";
exportconstUPDATE_SHINY="[Shinyaction]UpdateShiny";
exportconstOPEN_SHINY="[Shinyaction]OpenShiny";
exportconstINIT_SPACE="[Spaceaction]InitSpace";
exportconstUPDATE_SPACE="[Spaceaction]UpdateSpace";
exportconstREADY_SPACE="[Readyaction]ReadySpace";
exportconstINIT_TERMINAL="[Terminalaction]InitTerminal";
exportconstOPEN_TERMINAL="[Terminalaction]OpenTerminal";
exportconstFOCUS_TERMINAL="[Terminalaction]FocusTerminal";
exportconstWRITE_TERMINAL="[Terminalaction]WriteTerminal";
exportconstUPDATE_TERMINAL="[Terminalaction]UpdateTerminal";
exportconstCLEAR_TERMINAL="[Terminalaction]ClearTerminal";
exportconstINPUT_TERMINAL="[Terminalaction]InputTerminal";
exportconstTABLE_TERMINAL="[Terminalaction]TableTerminal";
exportconstCLOSE_TERMINAL="[Terminalaction]CloseTerminal";
exportconstROOT_TERMINAL="[Terminalaction]RootTerminal";
exportconstCONTENT_TERMINAL="[Terminalaction]ContentTerminal";
exportconstADD_PORT="[Terminalaction]AddPort";
exportconstINIT_VISAGE="[Visageaction]InitVisage";
exportconstUPDATE_VISAGE="[Visageaction]UpdateVisage";
exportconstFULLSCREEN_VISAGE="[Fullscreenaction]FullscreenVisage";
exportconstREAD_VISAGE="[Readaction]ReadVisage";
exportconstWRITE_VISAGE="[Writeaction]WriteVisage";
exportconstCREATE_VISAGE="[Createaction]CreateVisage";
exportconstSIZE_VISAGE="[Sizeaction]SizeVisage";
exportconstRENDER_VISAGE="[Renderaction]RenderVisage";
exportconstINIT_VURT="[Vurtaction]InitVurt";
exportconstDELAY_VURT="[Vurtaction]DelayVurt";
exportconstTEST_CLOUD_VURT="[Vurtaction]TestCloudVurt";
exportconstFETCH_VURT="[Vurtaction]FetchVurt";
exportconstUPDATE_VURT="[Vurtaction]UpdateVurt";
exportconstREPLACE_VURT="[Vurtaction]ReplaceVurt";
exportconstUNIT_VURT="[Vurtaction]UnitVurt";
exportconstCOUNT_VURT="[Vurtaction]CountVurt";
exportconstLIST_PIVOT_VURT="[Vurtaction]ListPivotVurt";
exportconstLIST_UNIT_VURT="[Vurtaction]ListUnitVurt";
exportconstCONTAINS_VURT="[Containsaction]ContainsVurt";
exportconstBUNDLE_VURT="[Bundleaction]BundleVurt";
exportconstVALUE_VURT="[Valueaction]ValueVurt";
importModelfrom"./99.core/interface/model.interface";
importControlUnitfrom"./00.control.unit/control.unit";
importTurnUnitfrom"./01.turn.unit/turn.unit";
importCollectUnitfrom"./97.collect.unit/collect.unit";
importBusUnitfrom"./99.bus.unit/bus.unit";
importControlfrom"./00.control.unit/fce/control.interface";
import{ControlModel}from"./00.control.unit/control.model";
importTurnfrom"./01.turn.unit/fce/turn.interface";
import{TurnModel}from"./01.turn.unit/turn.model";
importCollectfrom"./97.collect.unit/fce/collect.interface";
import{CollectModel}from"./97.collect.unit/collect.model";
importBusfrom"./99.bus.unit/fce/bus.interface";
import{BusModel}from"./99.bus.unit/bus.model";
exportconstlist:Array<any>=[ControlUnit,TurnUnit,CollectUnit,BusUnit];
import*asreduceFromControlfrom"./00.control.unit/control.reduce";
import*asreduceFromTurnfrom"./01.turn.unit/turn.reduce";
import*asreduceFromCollectfrom"./97.collect.unit/collect.reduce";
import*asreduceFromBusfrom"./99.bus.unit/bus.reduce";
exportconstreducer:any={
control:reduceFromControl.reducer,
turn:reduceFromTurn.reducer,
collect:reduceFromCollect.reducer,
bus:reduceFromBus.reducer,
exportdefaultclassUnitDataimplementsModel{
control:Control=newControlModel();
turn:Turn=newTurnModel();
collect:Collect=newCollectModel();
bus:Bus=newBusModel();
varsim={
hunt:null,
state:null
sim.hunt=(typ,obj)=>{returnhost(obj,typ)}
varhost=(obj,typ)=>{
init();
varslv;
constpromo=newPromise((rslv,rjct)=>(slv=rslv));
if(obj==null)obj={};
if(obj.slv==null)obj.slv=(val0)=>slv(val0);
sim.state.dispatch({type:typ,bale:obj});
returnpromo;
varinit=()=>{
if(sim.state!=null)return;
sim.state=newState();
sim.state.pivot=sim;
sim.state.hunt=sim.hunt
for(varkinImport.list)newImport.list[k](sim.state);
import*asImportfrom"./BEE";
importStatefrom"./99.core/state";
module.exports=sim;
exportconstVERTICAL="vertical";
exportconstHORIZONTAL="horizontal";
exportconstBLACK:string="black";
exportconstRED:string="red";
exportconstGREEN:string="green";
exportconstYELLOW:string="yellow";
exportconstMAGENTA:string="magenta";
exportconstCYAN:string="cyan";
exportconstWHITE:string="white";
exportconstBLUE:string="blue";
exportconstRED:string="\x1b[31m%s\x1b[0m";
exportconstGREEN:string="\x1b[32m%s\x1b[0m";
exportconstYELLOW:string="\x1b[33m%s\x1b[0m";
exportconstMAGENTA:string="\x1b[34m%s\x1b[0m";
exportconstCYAN:string="\x1b[36m%s\x1b[0m";
exportconstEAST="E";
exportconstSOUTH_EAST="SE";
exportconstSOUTH="S";
exportconstSOUTH_WEST="SW";
exportconstWEST="W";
exportconstNORTH_WEST="NW";
exportconstNORTH="N";
exportconstNORTH_EAST="NE";
exportconstWISE_EAST="WiseE";
exportconstWISE_SOUTH_EAST="WiseSE";
exportconstWISE_SOUTH="WiseS";
exportconstWISE_SOUTH_WEST="WiseSW";
exportconstWISE_WEST="WiseW";
exportconstWISE_NORTH_WEST="WiseNW";
exportconstWISE_NORTH="WiseN";
exportconstWISE_NORTH_EAST="WiseNE";
exportconstPLAT:string="plat";
exportconstAMBT:string="ambt";
exportconstAVAS:string="avas";
exportconstRECTANGLE:string="rectangle";
exportconstROUNDED_RECTANGLE:string="rounded-rectangle";
exportconstCIRCLE:string="circle";
exporttypePosition<Type>={
x:number;
y:number;
}&Type
exporttypeGridFill=Position<{
xSpan:number;
ySpan:number;
exportconstTOP_FULL_IDX='top-fill';
exportconstMID_FULL_IDX='mid-fill';
exportconstBOT_FULL_IDX='bot-fill';
exportconstTOP_FULL_BIT:GridFill={x:0,y:0,xSpan:12,ySpan:4};
exportconstMID_FULL_BIT:GridFill={x:0,y:4,xSpan:12,ySpan:5};
exportconstBOT_FULL_BIT:GridFill={x:0,y:8,xSpan:12,ySpan:4};
exportconstFOCUS:string="focus";
exportconstHEXMAP:string="hexmap";
exportconstPLAT:string="plat";
exportconstAMBT:string="ambt";
exportconstAVAS:string="avas";
exportconstSPACE:string="space";
exportconstTIMELINE:string="timeline";
exportconstMENU_SINGLE:string="menu_single";
exportconstCLEAN:string="clean";
exportconstCYAN:string="cyan";
exportconstRED:string="red";
exportconstGREEN:string="green";
exportconstBLUE:string="blue";
exportconstYELLOW:string="yellow";
exportconstMAGENTA:string="magenta";
exportconstVISAGE:string="visage";
exportconstSURFACE:string="surface";
exportconstCONTAINER:string="container";
exportconstGRAPHIC:string="graphic";
exportconstTEXT:string="text";
exportconstSPRITE:string="sprite";
exportconstHEXAGON:string="hexagon";
exportconstVIDEO:string="video";
exportconstLOOP:string="loop";
exportconstGEOJSON="geojson";
exportconstRECTANGLE="rectangle";
exportconstTRIANGLE="triangle";
exportconstHEXAGON="hexagon";
exportconstPARALLELOGRAM="parallelogram";
exportconstFOCUS="focus";
exportconstHEXMAP="hexmap";
exportconstCLOCK:string="clock";
exportconstSCREEN:string="screen-visage";
exportconstMOUNT_FULL:string="mount-visage-full";
exportconstMOUNT_PART:string="mount-visage-part";
exportconstMOUNT_HEIGHT:string="mount-visage-height";
exportconstMOUNT_WIDTH:string="mount-visage-width";
import*asActTmefrom'../../00.time.unit/time.action';
import*asActClkfrom'../../03.clock.unit/clock.action';
import*asActColfrom'../../97.collect.unit/collect.action';
import*asActCnsfrom'../../act/console.action';
import*asActPvtfrom'../../act/pivot.action';
import*asActDskfrom'../../act/disk.action';
import*asActBusfrom'../../99.bus.unit/bus.action';
varbit,lst,dex,src,dat;
exportconstinitTime=async(cpy:TimeModel,bal:TimeBit,ste:State)=>{
bit=awaitste.hunt(ActBus.INIT_BUS,{
idx:cpy.idx,
src:bal.src,
lst:[ActTme,ActClk],
dat:bal.dat,
});
const{exec}=require('child_process');
exec('tsc-b001.time',async(err,stdout,stderr)=>{
if(err){
console.error(`execerror:${err}`);
lst=[];
bit=awaitste.bus(ActPvt.BUNDLE_PIVOT,{src:'001.time'});
lst.push(bit);
bit=awaitste.bus(ActDsk.READ_DISK,{src:'./work/001.time.js'});
varblend=bit.dskBit.dat;
bit=awaitste.bus(ActDsk.WRITE_DISK,{
src:'./cloud/001.time.js',
dat:blend,
});
lst.push(bit);
setTimeout(async()=>{
bit=awaitste.bus(ActCns.UPDATE_CONSOLE,{
idx:'cns00',
src:'---timebundled',
});
if(bal.slv!=null)bal.slv({intBit:{idx:'init-time'}});
},3);
});
exportconsttestTime=async(cpy:TimeModel,bal:TimeBit,ste:State)=>{
bal.slv({tmeBit:{idx:'test-time',src:'testing-time'}});
exportconstformatTime=(cpy:TimeModel,bal:TimeBit,ste:State)=>{
if(bal.src==null)bal.src=DateTime.now();
src=DateTime.fromISO(bal.src).toLocaleString(DateTime.DATETIME_FULL);
if(bal.slv!=null)bal.slv({tmeBit:{idx:'format-time',src}});
exportconstnowTime=(cpy:TimeModel,bal:TimeBit,ste:State)=>{
if(bal.slv!=null)
bal.slv({
tmeBit:{idx:'now-time',val:DateTime.now().toUnixInteger()},
});
exportconstupdateTime=async(cpy:TimeModel,bal:TimeBit,ste:State)=>{
bit=awaitste.hunt(ActTme.READ_TIME,{
idx:bal.idx,
bit:ActTme.CREATE_TIME,
});
vartmeBit=bit.tmeBit.dat;
vardat=bal.dat;
if(dat==null)dat=[];
vardate=DateTime.local(
tmeBit.yrs,
tmeBit.mth,
tmeBit.day,
tmeBit.hrs,
tmeBit.min,
tmeBit.sec,
if(dat.yrs==null)dat.yrs=0;
if(dat.mth==null)dat.mth=0;
if(dat.day==null)dat.day=0;
if(dat.hrs==null)dat.hrs=0;
if(dat.min==null)dat.min=0;
if(dat.sec==null)dat.sec=0;
date=date.plus({
years:dat.yrs,
months:dat.mth,
days:dat.day,
hours:dat.hrs,
minutes:dat.min,
seconds:dat.sec,
});
tmeBit.yrs=date.year;
tmeBit.mth=date.month;
tmeBit.day=date.day;
tmeBit.hrs=date.hour;
tmeBit.min=date.minute;
tmeBit.sec=date.second;
tmeBit.wek=date.weekNumber;
tmeBit.qtr=date.quarter;
tmeBit.cnt=Math.floor(
date.diff(DateTime.local(tmeBit.yrs,1,1),'days').days,
tmeBit.src=date.toFormat('MM-dd-yyyy,hh:mm:ssa');
tmeBit.now=date.valueOf();
bit=awaitste.hunt(ActTme.WRITE_TIME,{
idx:tmeBit.idx,
dat:tmeBit,
bit:ActTme.CREATE_TIME,
});
if(bal.slv!=null)
bal.slv({tmeBit:{idx:'update-time',dat:bit.tmeBit.dat}});
exportconstwriteTime=async(cpy:TimeModel,bal:TimeBit,ste:State)=>{
bit=awaitste.hunt(ActCol.WRITE_COLLECT,{
idx:bal.idx,
dat:bal.dat,
bit:ActTme.CREATE_TIME,
});
if(bal.slv!=null)
bal.slv({tmeBit:{idx:'write-time',dat:bit.clcBit.dat}});
exportconstreadTime=async(cpy:TimeModel,bal:TimeBit,ste:State)=>{
if(bal.idx==null)bal.idx='tme00';
bit=awaitste.hunt(ActCol.READ_COLLECT,{
idx:bal.idx,
bit:ActTme.CREATE_TIME,
});
if(bal.slv!=null)
bal.slv({tmeBit:{idx:'read-time',dat:bit.clcBit.dat}});
exportconstcreateTime=(cpy:TimeModel,bal:TimeBit,ste:State)=>{
if(bal.idx==null)bal.idx='tme00';
if(bal.src==null)bal.src=TIME.CLOCK;
switch(bal.src){
caseTIME.CLOCK:
varclk:ClockBit=bal.dat;
if(clk==null)clk={idx:bal.idx};
if(clk.idx==null)clk.idx=bal.idx;
if(clk.src==null)clk.src='clk-bit';
if(clk.val==null)clk.val=0;
if(clk.pst==null)clk.pst=0;
if(clk.qtr==null)clk.qtr=0;
if(clk.yrs==null)clk.yrs=3210;
if(clk.mth==null)clk.mth=3;
if(clk.wek==null)clk.wek=3;
if(clk.day==null)clk.day=3;
if(clk.hrs==null)clk.hrs=3;
if(clk.min==null)clk.min=3;
if(clk.sec==null)clk.sec=3;
vardate=DateTime.local(
clk.yrs,
clk.mth,
clk.day,
clk.hrs,
clk.min,
clk.sec,
clk.yrs=date.year;
clk.mth=date.month;
clk.day=date.day;
clk.hrs=date.hour;
clk.min=date.minute;
clk.sec=date.second;
clk.cnt=Math.floor(
date.diff(DateTime.local(clk.yrs,1,1),'days').days,
clk.wek=date.weekNumber;
clk.qtr=date.quarter;
clk.src=date.toFormat('MM-dd-yyyy,hh:mm:ssa');
clk.now=date.valueOf();
if(bal.slv!=null)
bal.slv({tmeBit:{idx:'create-time',dat:clk}});
break;
exportconstcompareTime=async(cpy:TimeModel,bal:TimeBit,ste:State)=>{
if(bal.val==null)bal.val=0;
bit=awaitste.hunt(ActTme.READ_TIME,{idx:bal.idx});
varidxBit=bit.tmeBit.dat;
bit=awaitste.hunt(ActTme.READ_TIME,{idx:bal.src});
varsrcBit=bit.tmeBit.dat;
varobjIdx={
year:idxBit.yrs,
month:idxBit.mth,
day:idxBit.day,
hour:idxBit.hrs,
second:idxBit.sec,
varidxNow=DateTime.fromObject(objIdx);
varobjSrc={
year:srcBit.yrs,
month:srcBit.mth,
day:srcBit.day,
hour:srcBit.hrs,
second:srcBit.sec,
varsrcNow=DateTime.fromObject(objSrc);
varcomp;
if(bal.val==1)
comp=idxNow.diff(srcNow,[
'days',
'hours',
'years',
'weeks',
'seconds',
'months',
'minutes',
]);
elseif(bal.val==0)
comp=srcNow.diff(idxNow,[
'days',
'hours',
'years',
'weeks',
'seconds',
'months',
'minutes',
]);
varvalue=comp.values;
varclkBit:ClockBit={
idx:'compare-clock',
yrs:value.years,
mth:value.months,
wek:value.weeks,
day:value.days,
hrs:value.hours,
min:value.minutes,
sec:value.seconds,
if(bal.slv!=null)
bal.slv({tmeBit:{idx:'compare-clock',dat:clkBit}});
exportconstreduceTime=async(cpy:TimeModel,bal:TimeBit,ste:State)=>{
varbit;
if((bal.idx=null))bal.idx='tme00';
bit=awaitste.hunt(ActTme.READ_TIME,{idx:bal.idx});
varidxBit=bit.tmeBit.dat;
vardate=DateTime.local(
idxBit.yrs,
idxBit.mth,
idxBit.day,
idxBit.hrs,
idxBit.min,
idxBit.sec,
varmod={
years:0,
quarters:0,
months:0,
weeks:0,
hours:0,
minutes:0,
seconds:0,
varclk:ClockBit=bal.bit;
if(clk==null)clk={idx:bal.idx};
if(clk.idx==null)clk.idx=bal.idx;
if(clk.yrs!=null)mod.years=clk.yrs;
if(clk.qtr!=null)mod.quarters=clk.qtr;
if(clk.mth!=null)mod.months=clk.mth;
if(clk.wek!=null)mod.weeks=clk.wek;
if(clk.hrs!=null)mod.hours=clk.hrs;
if(clk.min!=null)mod.minutes=clk.min;
if(clk.sec!=null)mod.seconds=clk.sec;
varnow=date.minus(mod);
clk.yrs=now.year;
clk.mth=now.month;
clk.day=now.day;
clk.hrs=now.hour;
clk.min=now.minute;
clk.sec=now.second;
clk.cnt=Math.floor(now.diff(DateTime.local(clk.yrs,1,1),'days').days);
clk.wek=now.weekNumber;
clk.qtr=now.quarter;
clk.src=now.toFormat('MM-dd-yyyy,hh:mm:ssa');
clk.now=now.valueOf();
bit=awaitste.hunt(ActTme.WRITE_TIME,{idx:bal.idx,dat:clk});
if(bal.slv!=null)
bal.slv({tmeBit:{idx:'reduce-time',dat:bit.tmeBit.dat}});
varpatch=(ste,type,bale)=>ste.dispatch({type,bale});
import{TimeModel}from'../time.model';
importTimeBitfrom'../fce/time.bit';
importStatefrom'../../99.core/state';
import{DateTime}from'luxon';
import*asTIMEfrom'../../val/time';
importClockBitfrom'../fce/clock.bit';
exportdefaultinterfaceClockBit{
idx:string;
opn?:string;
dex?:number;
src?:string;
now?:number;
val?:number;
pst?:number;
qtr?:number;
yrs?:number;
mth?:number;
wek?:number;
day?:number;
hrs?:number;
min?:number;
sec?:number;
cnt?:number;
dat?:any;
slv?:any;
prt?:any;
importClockBitfrom"./clock.bit";
exportdefaultinterfaceTimeBit{
idx:string;
val?:number;
src?:string;
slv?:Function;
prt?:any;
dat?:any;
bit?:any;
clk?:ClockBit
importTimeBitfrom"./time.bit";
exportdefaultinterfaceTime{
import{Action}from"../99.core/interface/action.interface";
importTimeBitfrom"./fce/time.bit";
exportconstINIT_TIME="[Timeaction]InitTime";
exportclassInitTimeimplementsAction{
readonlytype=INIT_TIME;
constructor(publicbale:TimeBit){}
exportconstUPDATE_TIME="[Timeaction]UpdateTime";
exportclassUpdateTimeimplementsAction{
readonlytype=UPDATE_TIME;
constructor(publicbale:TimeBit){}
exportconstNOW_TIME="[Timeaction]NowTime";
exportclassNowTimeimplementsAction{
readonlytype=NOW_TIME;
constructor(publicbale:TimeBit){}
exportconstFORMAT_TIME="[Timeaction]FormatTime";
exportclassFormatTimeimplementsAction{
readonlytype=FORMAT_TIME;
constructor(publicbale:TimeBit){}
exportconstREAD_TIME="[Readaction]ReadTime";
exportclassReadTimeimplementsAction{
readonlytype=READ_TIME;
constructor(publicbale:TimeBit){}
exportconstWRITE_TIME="[Writeaction]WriteTime";
exportclassWriteTimeimplementsAction{
readonlytype=WRITE_TIME;
constructor(publicbale:TimeBit){}
exportconstCREATE_TIME="[Createaction]CreateTime";
exportclassCreateTimeimplementsAction{
readonlytype=CREATE_TIME;
constructor(publicbale:TimeBit){}
exportconstCOMPARE_TIME="[Compareaction]CompareTime";
exportclassCompareTimeimplementsAction{
readonlytype=COMPARE_TIME;
constructor(publicbale:TimeBit){}
exportconstREDUCE_TIME="[Reduceaction]ReduceTime";
exportclassReduceTimeimplementsAction{
readonlytype=REDUCE_TIME;
constructor(publicbale:TimeBit){}
exportconstTEST_TIME="[Reduceaction]TestTime";
exportclassTestTimeimplementsAction{
readonlytype=TEST_TIME;
constructor(publicbale:TimeBit){}
exporttypeActions=InitTime|UpdateTime|NowTime|FormatTime
|ReadTime
|WriteTime
|CreateTime
|CompareTime
|ReduceTime
|TestTime
export{initTime}from"./buz/time.buzz";
export{updateTime}from"./buz/time.buzz";
export{nowTime}from"./buz/time.buzz";
export{formatTime}from"./buz/time.buzz";
export{readTime}from"./buz/time.buzz";
export{writeTime}from"./buz/time.buzz";
export{createTime}from"./buz/time.buzz";
export{compareTime}from"./buz/time.buzz";
export{reduceTime}from"./buz/time.buzz";
export{testTime}from"./buz/time.buzz";
importTimefrom"./fce/time.interface";
importTimeBitfrom"./fce/time.interface";
exportclassTimeModelimplementsTime{
idx:string='001.time';
import*asclonefrom"clone-deep";
import*asActfrom"./time.action";
import{TimeModel}from"./time.model";
import*asBuzzfrom"./time.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:TimeModel=newTimeModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.NOW_TIME:
returnBuzz.nowTime(clone(model),act.bale,state);
caseAct.UPDATE_TIME:
returnBuzz.updateTime(clone(model),act.bale,state);
caseAct.FORMAT_TIME:
returnBuzz.formatTime(clone(model),act.bale,state);
caseAct.INIT_TIME:
returnBuzz.initTime(clone(model),act.bale,state);
caseAct.READ_TIME:
returnBuzz.readTime(clone(model),act.bale,state);
caseAct.WRITE_TIME:
returnBuzz.writeTime(clone(model),act.bale,state);
caseAct.CREATE_TIME:
returnBuzz.createTime(clone(model),act.bale,state);
caseAct.COMPARE_TIME:
returnBuzz.compareTime(clone(model),act.bale,state);
caseAct.REDUCE_TIME:
returnBuzz.reduceTime(clone(model),act.bale,state);
caseAct.TEST_TIME:
returnBuzz.testTime(clone(model),act.bale,state);
default:
returnmodel;
import{Singleton}from"typescript-ioc";
importStatefrom"../99.core/state";
@Singleton
exportdefaultclassTimeUnit{
constructor(state:State){
global.TIME=require("../dist/001.time/hunt");
import*asActColfrom"../../97.collect.unit/collect.action";
import*asActClkfrom"../clock.action";
varbit,val,idx,dex,lst,dat;
exportconstinitClock=(cpy:ClockModel,bal:ClockBit,ste:State)=>{
debugger
exportconstupdateClock=async(cpy:ClockModel,bal:ClockBit,ste:State)=>{
varnow:TicBit=bal.dat
bit=awaitste.hunt(ActClk.READ_CLOCK,{idx:bal.idx})
varticDat:TicBit=bit.clkBit.dat
vardt=ticDat.bit;
if(now.yrs==null)now.yrs=0
if(now.mth==null)now.mth=0
if(now.day==null)now.day=0
if(now.hrs==null)now.hrs=0
if(now.min==null)now.min=0
if(now.sec==null)now.sec=0
if(now.wek==null)now.wek=0
if(now.qtr==null)now.qtr=0;
varaddition={
years:now.yrs,
months:now.mth,
days:now.day,
hours:now.hrs,
minutes:now.min,
seconds:now.sec,
weeks:now.wek,
quarters:now.qtr
dt=dt.plus(addition);
ticDat.src=dt.toISO()
ticDat.qtr=dt.quarter;
ticDat.yrs=dt.year;
ticDat.mth=dt.month;
ticDat.wek=dt.weekNumber;
ticDat.day=dt.day;
ticDat.sec=dt.second;
ticDat.min=dt.minute;
ticDat.hrs=dt.hour;
ticDat.frm=dt.toLocaleString(DateTime.DATETIME_HUGE_WITH_SECONDS)
ticDat.now=dt.valueOf();
ticDat.bit=dt;
bal.slv({clkBit:{idx:"update-clock",dat:ticDat}});
exportconstreadClock=async(cpy:ClockModel,bal:ClockBit,ste:State)=>{
varslv=bal.slv;
if(bal.idx==null)bal.idx="hex00";
bit=awaitste.hunt(ActCol.READ_COLLECT,{idx:bal.idx,src:bal.src,bit:ActClk.CREATE_CLOCK});
if(slv!=null)slv({clkBit:{idx:"read-clock",dat:bit.clcBit.dat}});
exportconstwriteClock=async(cpy:ClockModel,bal:ClockBit,ste:State)=>{
if(bal.dat!=null){
bit=awaitste.hunt(ActClk.UPDATE_CLOCK,{idx:bal.idx,dat:bal.dat});
bal.dat=bit.clkBit.dat
bit=awaitste.hunt(ActCol.WRITE_COLLECT,{idx:bal.idx,src:bal.src,dat:bal.dat,bit:ActClk.CREATE_CLOCK});
vardata=bit.clcBit.dat
if(bal.slv!=null)bal.slv({clkBit:{idx:"write-clock",dat:data}});
bal.dat={}
if(bal.dat.dat==null)bal.dat.dat={}
if(bal.clk!=null)bal.dat.clk=bal.clk;
bit=awaitste.hunt(ActCol.WRITE_COLLECT,{idx:bal.idx,src:bal.src,dat:bal.dat,bit:ActClk.CREATE_CLOCK});
vardata=bit.clcBit.dat
if(bal.slv!=null)bal.slv({clkBit:{idx:"write-clock",dat:data}});
exportconstremoveClock=async(cpy:ClockModel,bal:ClockBit,ste:State)=>{
bit=awaitste.hunt(ActCol.REMOVE_COLLECT,{idx:bal.idx,src:bal.src,dat:bal.dat,bit:ActClk.DELETE_CLOCK})
if(bal.slv!=null)bal.slv({clkBit:{idx:"remove-clock",dat:bit.clcBit}});
exportconstcreateClock=async(cpy:ClockModel,bal:ClockBit,ste:State)=>{
if(bal.dat.clk==null){
varclkBit:TicBit={idx:bal.idx}
clkBit.day=3;
clkBit.hrs=3;
clkBit.min=3;
clkBit.mth=3;
clkBit.sec=3;
clkBit.yrs=3033;
bal.dat.clk=clkBit
varclk=bal.dat.clk;
vardateObject={
day:null,
year:null,
hour:null,
month:null,
minute:null,
second:null,
if(clk.day!=null)dateObject.day=clk.day;
if(clk.yrs!=null)dateObject.year=clk.yrs;
if(clk.hrs!=null)dateObject.hour=clk.hrs;
if(clk.mth!=null)dateObject.month=clk.mth;
if(clk.min!=null)dateObject.minute=clk.min;
if(clk.sec!=null)dateObject.second=clk.sec;
vardt=DateTime.fromObject(dateObject)
vardat:TicBit={idx:bal.idx,src:null};
dat.bit=dt;
dat.src=dt.toISO()
dat.qtr=dt.quarter;
dat.yrs=dt.year;
dat.mth=dt.month;
dat.wek=dt.weekNumber;
dat.day=dt.day;
dat.sec=dt.second;
dat.min=dt.minute;
dat.frm=dt.toLocaleString(DateTime.DATETIME_HUGE_WITH_SECONDS)
dat.now=dt.valueOf();
dat.val=0;
dat.pst=0;
bal.slv({clkBit:{idx:"create-clock",dat:dat}});
exportconstdeleteClock=async(cpy:ClockModel,bal:ClockBit,ste:State)=>{
debugger
exportconstpushClock=async(cpy:ClockModel,bal:ClockBit,ste:State)=>{
bit=awaitste.hunt(ActClk.READ_CLOCK,{idx:bal.idx})
vardat:TicBit=bit.clkBit.dat
vardate=DateTime.local(dat.yrs,dat.mth,dat.day,dat.hrs,dat.min,dat.sec);
varupd=bal.dat
exportconstblockClock=async(cpy:ClockModel,bal:ClockBit,ste:State)=>{
if(bal.idx==null){
returnbal.slv({clkBit:{idx:"block-clock-error",src:'no-blockfrost-idx'}});
varblockfrost=bal.idx;
fetch(url,{
method:'GET',
headers:{'project_id':blockfrost},
.then(response=>response.json())
.then(asyncresponse=>{
constrsp:BlockBit=response;
vardiff;
if(rsp.epoch_slot==cpy.slot){
cpy.tick=false
else{
cpy.tick=true
vardt1=DateTime.fromSeconds(cpy.slotTime)
vardt2=DateTime.fromSeconds(rsp.time)
diff=dt1.diff(dt2,["seconds"])
cpy.slot=rsp.epoch_slot
cpy.slotTime=rsp.time
varobj=diff.toObject();
for(varkeyinobj){
obj[key]*=-1
cpy.score=obj.seconds
val=cpy.tick;
dex=cpy.slot
rsp.score=cpy.score
dat=JSON.stringify(rsp)
returnbal.slv({clkBit:{idx:"block-clock",val,dex,dat}});
.catch(err=>{
val=cpy.tick
dex=cpy.slot
bal.slv({clkBit:{idx:"block-clock",val,dex}});
console.error(err);
exportconstlistClock=async(cpy:ClockModel,bal:ClockBit,ste:State)=>{
dat=null
bit=awaitste.hunt(ActCol.FETCH_COLLECT,{val:0,bit:ActClk.CREATE_CLOCK})
if(bit.clcBit.dat==null)lst=[]
elsedat=bit.clcBit.dat;
if(dat!=null){
dat.bitList.forEach((a)=>{
lst=[]
lst.push((a.idx))
if(bal.slv!=null)bal.slv({clkBit:{idx:'list-clock',lst}});
exportconsttestClock=(cpy:ClockModel,bal:ClockBit,ste:State)=>{
debugger
import{ClockModel}from"../clock.model";
importClockBitfrom"../fce/clock.bit";
importStatefrom"../../99.core/state";
importTicBitfrom"../fce/tic.bit";
import{DateTime}from"luxon";
import{BlockBit}from"../fce/blockbit";
import{Action}from"../99.core/interface/action.interface";
importClockBitfrom"./fce/clock.bit";
exportconstINIT_CLOCK="[Clockaction]InitClock";
exportclassInitClockimplementsAction{
readonlytype=INIT_CLOCK;
constructor(publicbale:ClockBit){}
exportconstUPDATE_CLOCK="[Clockaction]UpdateClock";
exportclassUpdateClockimplementsAction{
readonlytype=UPDATE_CLOCK;
constructor(publicbale:ClockBit){}
exportconstREAD_CLOCK="[Readaction]ReadClock";
exportclassReadClockimplementsAction{
readonlytype=READ_CLOCK;
constructor(publicbale:ClockBit){}
exportconstWRITE_CLOCK="[Writeaction]WriteClock";
exportclassWriteClockimplementsAction{
readonlytype=WRITE_CLOCK;
constructor(publicbale:ClockBit){}
exportconstREMOVE_CLOCK="[Removeaction]RemoveClock";
exportclassRemoveClockimplementsAction{
readonlytype=REMOVE_CLOCK;
constructor(publicbale:ClockBit){}
exportconstCREATE_CLOCK="[Createaction]CreateClock";
exportclassCreateClockimplementsAction{
readonlytype=CREATE_CLOCK;
constructor(publicbale:ClockBit){}
exportconstDELETE_CLOCK="[Deleteaction]DeleteClock";
exportclassDeleteClockimplementsAction{
readonlytype=DELETE_CLOCK;
constructor(publicbale:ClockBit){}
exportconstBLOCK_CLOCK="[Blockaction]BlockClock";
exportclassBlockClockimplementsAction{
readonlytype=BLOCK_CLOCK;
constructor(publicbale:ClockBit){}
exportconstLIST_CLOCK="[Listaction]ListClock";
exportclassListClockimplementsAction{
readonlytype=LIST_CLOCK;
constructor(publicbale:ClockBit){}
exportconstTEST_CLOCK="[Testaction]TestClock";
exportclassTestClockimplementsAction{
readonlytype=TEST_CLOCK;
constructor(publicbale:ClockBit){}
exporttypeActions=|InitClock|UpdateClock
|ReadClock
|WriteClock
|RemoveClock
|CreateClock
|DeleteClock
|BlockClock
|ListClock
|TestClock
export{initClock}from"./buz/clock.buzz";
export{updateClock}from"./buz/clock.buzz";
export{readClock}from"./buz/clock.buzz";
export{writeClock}from"./buz/clock.buzz";
export{removeClock}from"./buz/clock.buzz";
export{createClock}from"./buz/clock.buzz";
export{deleteClock}from"./buz/clock.buzz";
export{blockClock}from"./buz/clock.buzz";
export{listClock}from"./buz/clock.buzz";
export{testClock}from"./buz/clock.buzz";
importClockfrom"./fce/clock.interface";
importClockBitfrom"./fce/clock.interface";
exportclassClockModelimplementsClock{
tick:boolean=true;
slot:Number=0;
slotTime:Number=0;
score:any;
import*asclonefrom"clone-deep";
import*asActfrom"./clock.action";
import{ClockModel}from"./clock.model";
import*asBuzzfrom"./clock.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:ClockModel=newClockModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.UPDATE_CLOCK:
returnBuzz.updateClock(clone(model),act.bale,state);
caseAct.INIT_CLOCK:
returnBuzz.initClock(clone(model),act.bale,state);
caseAct.READ_CLOCK:
returnBuzz.readClock(clone(model),act.bale,state);
caseAct.WRITE_CLOCK:
returnBuzz.writeClock(clone(model),act.bale,state);
caseAct.REMOVE_CLOCK:
returnBuzz.removeClock(clone(model),act.bale,state);
caseAct.CREATE_CLOCK:
returnBuzz.createClock(clone(model),act.bale,state);
caseAct.DELETE_CLOCK:
returnBuzz.deleteClock(clone(model),act.bale,state);
caseAct.BLOCK_CLOCK:
returnBuzz.blockClock(clone(model),act.bale,state);
caseAct.LIST_CLOCK:
returnBuzz.listClock(clone(model),act.bale,state);
caseAct.TEST_CLOCK:
returnBuzz.testClock(clone(model),act.bale,state);
default:
returnmodel;
import{Singleton}from"typescript-ioc";
importStatefrom"../99.core/state";
@Singleton
exportdefaultclassClockUnit{
constructor(state:State){
exportdefaultinterfaceAmountBit{
unit?:string;
quantity?:number;
exportinterfaceBlockBit{
block_vrf:string
confirmations:number
epoch:number
epoch_slot:number
fees:string
hash:string
height:number
next_block:any
op_cert:string
op_cert_counter:string
output:string
previous_block:string
size:number
slot:number
slot_leader:string
time:number
tx_count:number
score:any;
importAmountBitfrom"./amount.bit";
exportdefaultinterfaceBlockfrostBit{
address?:string;
amount?:AmountBit[];
script?:boolean;
stake_address?:string;
type?:string;
importTicBitfrom"./tic.bit";
exportdefaultinterfaceClockBit{
idx:string;
src?:string;
val?:number;
dat?:any;
bit?:any;
slv?:Function;
clk:TicBit
importClockBitfrom"./clock.bit";
exportdefaultinterfaceClock{
exportdefaultinterfaceTicBit{
idx:string;
src?:string;
typ?:string;
frm?:string;
opn?:string;
dex?:number;
now?:number;
val?:number;
pst?:number;
qtr?:number;
yrs?:number;
mth?:number;
wek?:number;
day?:number;
hrs?:number;
min?:number;
sec?:number;
cnt?:number;
dat?:any;
clk?:TicBit
bit?:any;
import*asActColfrom'../../97.collect.unit/collect.action';
varbit,lst,dat,idx,val,src,dex;
exportconstinitCollect=(cpy:CollectModel,bal:CollectBit,ste:State)=>{
exportconstupdateCollect=(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
exportconstfetchCollect=(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
if(bal.val==null)bal.val=1;
if(bal.bit==null)
bal.slv({clcBit:{idx:'fetch-collect-err',src:'no-bit'}});
vartype=bal.bit.split('').slice(-1).pop().toLowerCase();
varcabBit:CaboodleBit=cpy.caboodleBitList[cpy.caboodleBits[type]];
if(bal.val==1)bit=cabBit.bitList[0];
elsebit=cabBit;
if(bal.slv!=null)bal.slv({clcBit:{idx:'fetch-collect',dat:bit}});
exportconstreadCollect=async(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
if(bal.bit==null)
bal.slv({clcBit:{idx:'read-collect-err',src:'no-bit'}});
vartype=bal.bit.split('').slice(-1).pop().toLowerCase();
if(cpy.caboodleBits[type]==null)createCollect(cpy,{idx:type},ste);
varcabBit:CaboodleBit=cpy.caboodleBitList[cpy.caboodleBits[type]];
if(cabBit.bits[bal.idx]==null){
bit=awaitste.hunt(ActCol.WRITE_COLLECT,{
idx:bal.idx,
src:bal.src,
bit:bal.bit,
});
}else{
dat=cabBit.bitList[cabBit.bits[bal.idx]];
if(bal.slv!=null)bal.slv({clcBit:{idx:'read-collect',dat}});
exportconstwriteCollect=async(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
dat=null;
vartype=bal.bit.split('').slice(-1).pop().toLowerCase();
if(cpy.caboodleBits[type]==null)createCollect(cpy,{idx:type},ste);
if(bal.bit==null)
bal.slv({rskBit:{idx:'write-collect-err',src:'no-bit'}});
varcabBit:CaboodleBit=cpy.caboodleBitList[cpy.caboodleBits[type]];
bal.idx;
val=0;
if(cabBit.bits[bal.idx]==null){
bit=awaitste.hunt(bal.bit,{idx:bal.idx,src:bal.src,dat:bal.dat});
varobjDat=bit[Object.keys(bit)[0]];
dat=objDat.dat;
if(dat==null)dat={};
dat.dex=cabBit.bitList.length;
cabBit.bitList.push(dat);
varidx=bal.idx;
if(idx==null)idx=dat.idx;
if(idx==null)thrownewError('writecollecthasnoidx');
cabBit.bits[idx]=dat.dex;
}else{
varcabDat=cabBit.bitList[cabBit.bits[bal.idx]];
bal.dat;
val=1;
for(varkeyinbal.dat){
if(cabDat==null)cabDat={};
cabDat[key]=bal.dat[key];
cabBit.bitList[cabBit.bits[bal.idx]]=cabDat;
dat=cabDat;
if(dat==null&&bal.slv!=null)
bal.slv({rskBit:{idx:'write-collect-err',src:'no-dat'}});
if(bal.slv!=null)bal.slv({clcBit:{idx:'write-collect',val,dat}});
exportconstcreateCollect=(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
varcabBit:CaboodleBit={idx:bal.idx,dex:0,bits:{},bitList:[]};
cabBit.dex=cpy.caboodleBitList.length;
cpy.caboodleBitList.push(cabBit);
cpy.caboodleBits[cabBit.idx]=cabBit.dex;
if(bal.slv!=null)
bal.slv({clcBit:{idx:'create-collect',dat:cabBit}});
exportconstremoveCollect=async(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
vartype=bal.bit.split('').slice(-1).pop().toLowerCase();
if(cpy.caboodleBits[type]==null)
returnbal.slv({rskBit:{idx:'remove-collect-not-present'}});
varcabBit:CaboodleBit=cpy.caboodleBitList[cpy.caboodleBits[type]];
if(cabBit.bits[bal.idx]==null)
returnbal.slv({rskBit:{idx:'remove-collect-idx-not-present'}});
bit=awaitste.hunt(bal.bit,{idx:bal.idx,src:bal.src,dat:bal.dat});
varobjDat=bit[Object.keys(bit)[0]];
dat=objDat.dat;
dex=dat.dex;
for(vari=dex;i<cabBit.bitList.length-1;i++){
varupdate=cabBit.bitList[i];
update.dex-=1;
for(varkeyindat){
dat[key]=null;
deletecabBit.bits[bal.idx];
varitm=cabBit.bitList.splice(dex,1);
cabBit.dex-=1;
if(bal.slv!=null)
bal.slv({clcBit:{idx:'remove-collect',dat:itm[0]}});
exportconstputCollect=(cpy:CollectModel,bal:CollectBit,ste:State)=>{
cpy.caboodleBits[bal.idx]=bal.val;
cpy.caboodleBitList[bal.val]=bal.dat;
if(bal.slv!=null)
bal.slv({clcBit:{idx:'put-collect',dat:bal.dat}});
exportconstgetCollect=(cpy:CollectModel,bal:CollectBit,ste:State)=>{
val=cpy.caboodleBits[bal.idx];
dat=cpy.caboodleBitList[val];
if(bal.slv!=null)bal.slv({clcBit:{idx:'get-collect',val,dat}});
exportconstmodelCollect=(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
if(bal.slv!=null)bal.slv({clcBit:{idx:'model-collect',dat:cpy}});
exportconstdeleteCollect=(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
exportconstemptyCollect=(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
exportconstdotCollect=(cpy:CollectModel,bal:CollectBit,ste:State)=>{
vargel=bal.dat;
varout=[];
bal.src.split('\n').forEach((a,b)=>{
vardoTCompiled=doT.template(a);
varoutLine=doTCompiled(gel);
out.push(outLine);
});
if(bal.slv!=null)
bal.slv({clcBit:{idx:'dot-vurt',lst:out,src:out.join('\n')}});
exportconstformatCollect=(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
lst=bal.src.split(':');
varidx=lst[0];
varout=[];
idx=S(idx).collapseWhitespace().s;
varopt=lst[1].split(',');
opt.forEach((a,b)=>{
varnow=S(a).collapseWhitespace().s;
if(a.length<1)return;
out.push(now);
});
dat=[idx,out];
bal.slv({clcBit:{idx:'format-collect',dat}});
exportconstlistCollect=(cpy:CollectModel,bal:CollectBit,ste:State)=>{
vartype=bal.bit.split('').slice(-1).pop().toLowerCase();
if(cpy.caboodleBits[type]==null)createCollect(cpy,{idx:type},ste);
varcabBit:CaboodleBit=cpy.caboodleBitList[cpy.caboodleBits[type]];
lst=[];
cabBit.bitList.forEach((a)=>{
if(a.idx!=null)lst.push(a.idx);
if(a.id!=null)lst.push(a.id);
});
bal.slv({clcBit:{idx:'list-collect',lst}});
exportconstselectCollect=(cpy:CollectModel,bal:CollectBit,ste:State)=>{
varChance=require('chance');
varchance=newChance();
dat=chance.pickone(bal.lst)
bal.slv({clcBit:{idx:'select-collect',dat}});
exportconsthashCollect=(cpy:CollectModel,bal:CollectBit,ste:State)=>{
if(bal.src==null)bal.src='';
lst=bal.src.split('\n');
dat={};
lst.forEach((a)=>{
a=S(a).collapseWhitespace().s;
if(a.length<3)return;
if(a[0]=='-')return
varhold=a.split(':');
vardom=hold[0];
varsub=hold[1];
varnow=sub.split(',');
now.forEach((b,c)=>{
now[c]=S(b).collapseWhitespace().s;
});
dat[dom]=now;
});
bal.slv({clcBit:{idx:'hash-collect',dat}});
import{CollectModel}from'../collect.model';
importCollectBitfrom'../fce/collect.bit';
importStatefrom'../../99.core/state';
importCaboodleBitfrom'../fce/caboodle.bit';
import*asSfrom'string';
import*asdoTfrom'dot';
import{Action}from"../99.core/interface/action.interface";
importCollectBitfrom"./fce/collect.bit";
exportconstINIT_COLLECT="[Collectaction]InitCollect";
exportclassInitCollectimplementsAction{
readonlytype=INIT_COLLECT;
constructor(publicbale:CollectBit){}
exportconstUPDATE_COLLECT="[Collectaction]UpdateCollect";
exportclassUpdateCollectimplementsAction{
readonlytype=UPDATE_COLLECT;
constructor(publicbale:CollectBit){}
exportconstFETCH_COLLECT="[Collectaction]FetchCollect";
exportclassFetchCollectimplementsAction{
readonlytype=FETCH_COLLECT;
constructor(publicbale:CollectBit){}
exportconstREAD_COLLECT="[Readaction]ReadCollect";
exportclassReadCollectimplementsAction{
readonlytype=READ_COLLECT;
constructor(publicbale:CollectBit){}
exportconstWRITE_COLLECT="[Writeaction]WriteCollect";
exportclassWriteCollectimplementsAction{
readonlytype=WRITE_COLLECT;
constructor(publicbale:CollectBit){}
exportconstCREATE_COLLECT="[Createaction]CreateCollect";
exportclassCreateCollectimplementsAction{
readonlytype=CREATE_COLLECT;
constructor(publicbale:CollectBit){}
exportconstREMOVE_COLLECT="[Createaction]RemoveCollect";
exportclassRemoveCollectimplementsAction{
readonlytype=REMOVE_COLLECT;
constructor(publicbale:CollectBit){}
exportconstDELETE_COLLECT="[Createaction]DeleteCollect";
exportclassDeleteCollectimplementsAction{
readonlytype=DELETE_COLLECT;
constructor(publicbale:CollectBit){}
exportconstEMPTY_COLLECT="[Emptyaction]EmptyCollect";
exportclassEmptyCollectimplementsAction{
readonlytype=EMPTY_COLLECT;
constructor(publicbale:CollectBit){}
exportconstMODEL_COLLECT="[Emptyaction]ModelCollect";
exportclassModelCollectimplementsAction{
readonlytype=MODEL_COLLECT;
constructor(publicbale:CollectBit){}
exportconstPUT_COLLECT="[Emptyaction]PutCollect";
exportclassPutCollectimplementsAction{
readonlytype=PUT_COLLECT;
constructor(publicbale:CollectBit){}
exportconstGET_COLLECT="[Emptyaction]GetCollect";
exportclassGetCollectimplementsAction{
readonlytype=GET_COLLECT;
constructor(publicbale:CollectBit){}
exportconstFORMAT_COLLECT="[Formataction]FormatCollect";
exportclassFormatCollectimplementsAction{
readonlytype=FORMAT_COLLECT;
constructor(publicbale:CollectBit){}
exportconstDOT_COLLECT="[Formataction]DotCollect";
exportclassDotCollectimplementsAction{
readonlytype=DOT_COLLECT;
constructor(publicbale:CollectBit){}
exportconstLIST_COLLECT="[Listaction]ListCollect";
exportclassListCollectimplementsAction{
readonlytype=LIST_COLLECT;
constructor(publicbale:CollectBit){}
exportconstHASH_COLLECT="[Hashaction]HashCollect";
exportclassHashCollectimplementsAction{
readonlytype=HASH_COLLECT;
constructor(publicbale:CollectBit){}
exportconstSELECT_COLLECT="[Hashaction]SelectCollect";
exportclassSelectCollectimplementsAction{
readonlytype=SELECT_COLLECT;
constructor(publicbale:CollectBit){}
exporttypeActions=|InitCollect|UpdateCollect
|ReadCollect
|WriteCollect
|CreateCollect
|EmptyCollect
|FetchCollect
|DeleteCollect
|RemoveCollect
|ModelCollect
|GetCollect
|PutCollect
|FormatCollect
|DotCollect
|ListCollect
|HashCollect
|SelectCollect
export{initCollect}from"./buz/collect.buzz";
export{updateCollect}from"./buz/collect.buzz";
export{readCollect}from"./buz/collect.buzz";
export{writeCollect}from"./buz/collect.buzz";
export{createCollect}from"./buz/collect.buzz";
export{emptyCollect}from"./buz/collect.buzz";
export{fetchCollect}from"./buz/collect.buzz";
export{deleteCollect}from"./buz/collect.buzz";
export{removeCollect}from"./buz/collect.buzz";
export{modelCollect}from"./buz/collect.buzz";
export{putCollect}from"./buz/collect.buzz";
export{getCollect}from"./buz/collect.buzz";
export{formatCollect}from"./buz/collect.buzz";
export{dotCollect}from"./buz/collect.buzz";
export{listCollect}from"./buz/collect.buzz";
export{hashCollect}from"./buz/collect.buzz";
export{selectCollect}from"./buz/collect.buzz";
importCaboodleBitfrom"./fce/caboodle.bit";
importCollectfrom"./fce/collect.interface";
importCollectBitfrom"./fce/collect.interface";
exportclassCollectModelimplementsCollect{
idx:string='23.11.14';
caboodleBitList:CaboodleBit[]=[];
caboodleBits:any={};
import*asclonefrom"clone-deep";
import*asActfrom"./collect.action";
import{CollectModel}from"./collect.model";
import*asBuzzfrom"./collect.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:CollectModel=newCollectModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.UPDATE_COLLECT:
returnBuzz.updateCollect(clone(model),act.bale,state);
caseAct.INIT_COLLECT:
returnBuzz.initCollect(clone(model),act.bale,state);
caseAct.READ_COLLECT:
returnBuzz.readCollect(clone(model),act.bale,state);
caseAct.WRITE_COLLECT:
returnBuzz.writeCollect(clone(model),act.bale,state);
caseAct.CREATE_COLLECT:
returnBuzz.createCollect(clone(model),act.bale,state);
caseAct.DELETE_COLLECT:
returnBuzz.deleteCollect(clone(model),act.bale,state);
caseAct.REMOVE_COLLECT:
returnBuzz.removeCollect(clone(model),act.bale,state);
caseAct.EMPTY_COLLECT:
returnBuzz.emptyCollect(clone(model),act.bale,state);
caseAct.FETCH_COLLECT:
returnBuzz.fetchCollect(clone(model),act.bale,state);
caseAct.MODEL_COLLECT:
returnBuzz.modelCollect(clone(model),act.bale,state);
caseAct.GET_COLLECT:
returnBuzz.getCollect(clone(model),act.bale,state);
caseAct.PUT_COLLECT:
returnBuzz.putCollect(clone(model),act.bale,state);
caseAct.FORMAT_COLLECT:
returnBuzz.formatCollect(clone(model),act.bale,state);
caseAct.DOT_COLLECT:
returnBuzz.dotCollect(clone(model),act.bale,state);
caseAct.LIST_COLLECT:
returnBuzz.listCollect(clone(model),act.bale,state);
caseAct.HASH_COLLECT:
returnBuzz.hashCollect(clone(model),act.bale,state);
caseAct.SELECT_COLLECT:
returnBuzz.selectCollect(clone(model),act.bale,state);
default:
returnmodel;
import{Singleton}from"typescript-ioc";
importStatefrom"../99.core/state";
@Singleton
exportdefaultclassCollectUnit{
constructor(state:State){
exportdefaultinterfaceCaboodleBit{
idx:string;
dex:number;
bitList:any[];
bits:any;
exportdefaultinterfaceCollectBit{
idx?:string;
src?:string;
val?:number;
dex?:number;
dat?:any;
bit?:any;
slv?:Function;
lst?:any;
importCollectBitfrom"./collect.bit";
importCaboodleBitfrom"./caboodle.bit";
exportdefaultinterfaceCollect{
idx:string;
caboodleBitList:CaboodleBit[];
caboodleBits:any;
import{Action}from"../99.core/interface/action.interface";
importBusBitfrom"./fce/bus.bit";
exportconstINIT_BUS="[Busaction]InitBus";
exportclassInitBusimplementsAction{
readonlytype=INIT_BUS;
constructor(publicbale:BusBit){}
exportconstOPEN_BUS="[Busaction]OpenBus";
exportclassOpenBusimplementsAction{
readonlytype=OPEN_BUS;
constructor(publicbale:BusBit){}
exportconstCONNECT_BUS="[Busaction]ConnectBus";
exportclassConnectBusimplementsAction{
readonlytype=CONNECT_BUS;
constructor(publicbale:BusBit){}
exportconstMESSAGE_BUS="[Busaction]MessageBus";
exportclassMessageBusimplementsAction{
readonlytype=MESSAGE_BUS;
constructor(publicbale:BusBit){}
exportconstUPDATE_BUS="[Busaction]UpdateBus";
exportclassUpdateBusimplementsAction{
readonlytype=UPDATE_BUS;
constructor(publicbale:BusBit){}
exportconstCREATE_BUS="[Busaction]CreateBus";
exportclassCreateBusimplementsAction{
readonlytype=CREATE_BUS;
constructor(publicbale:BusBit){}
exporttypeActions=|InitBus|OpenBus|UpdateBus|ConnectBus|MessageBus|CreateBus;
export{initBus}from"./buz/bus.buzz";
export{openBus}from"./buz/bus.buzz";
export{updateBus}from"./buz/bus.buzz";
export{connectBus}from"./buz/bus.buzz";
export{messageBus}from"./buz/bus.buzz";
export{createBus}from"./buz/bus.buzz";
importBusfrom"./fce/bus.interface";
importBusBitfrom"./fce/bus.interface";
exportclassBusModelimplementsBus{
MQTT:any;
actList:any;
client:any;
bus:Function;
responseSuffix:string='-response'
promises:any={}
import*asclonefrom"clone-deep";
import*asActfrom"./bus.action";
import{BusModel}from"./bus.model";
import*asBuzzfrom"./bus.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:BusModel=newBusModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.UPDATE_BUS:
returnBuzz.updateBus(clone(model),act.bale,state);
caseAct.OPEN_BUS:
returnBuzz.openBus(clone(model),act.bale,state);
caseAct.CONNECT_BUS:
returnBuzz.connectBus(clone(model),act.bale,state);
caseAct.CREATE_BUS:
returnBuzz.createBus(clone(model),act.bale,state);
caseAct.MESSAGE_BUS:
returnBuzz.connectBus(clone(model),act.bale,state);
caseAct.INIT_BUS:
returnBuzz.initBus(clone(model),act.bale,state);
default:
returnmodel;
import{Singleton}from"typescript-ioc";
importStatefrom"../99.core/state";
@Singleton
exportdefaultclassBusUnit{
constructor(state:State){
import*asActBusfrom"../../99.bus.unit/bus.action";
import*asActColfrom"../../97.collect.unit/collect.action";
varlst,idx,bit,src,dat,dex;
varflag=false
exportconstinitBus=(cpy:BusModel,bal:BusBit,ste:State)=>{
setTimeout(()=>{flag=true},3333)
cpy.actList=[]
if(bal==null)bal={idx:null}
if(bal.lst==null)bal.lst=[]
if((bal.src!=null)&&(bal.src.constructor==Array))lst=bal.src;
bal.lst.forEach((a)=>{
for(varkeyina){
cpy.actList.push(a[key])
ste.bus=(idx,dat,bit)=>updateBus(cpy,{idx,dat,bit},ste)
if(bal.dat!=null){
cpy.MQTT=bal.dat;
else{
if(lst==null){
if(bal.src!=null)cpy.host=bal.src
cpy.client=cpy.MQTT.connect(cpy.host);
cpy.client.on('message',(tpc,msg)=>{messageBus(cpy,{idx:tpc,src:msg},ste)})
cpy.client.on('connect',async()=>{
openBus(cpy,{idx:'init-bus',lst:cpy.actList},ste)
if(bal.slv!=null)bal.slv({intBit:{idx:"init-bus"}})
}else{
varcomplete=(lst)=>{
lst.shift()
if(lst.length!=0)return
if(bal.slv!=null)bal.slv({intBit:{idx:"init-bus"}})
lst.forEach(async(a)=>{
bit=awaitste.hunt(ActCol.WRITE_COLLECT,{idx:a.idx,src:a.src,bit:ActBus.CREATE_BUS})
varclient=bit.clcBit.dat;
client.on('message',(tpc,msg)=>{messageBus(cpy,{idx:tpc,src:msg,bit:a.idx},ste)})
client.on('connect',async()=>{
if(flag==true){
openBus(cpy,{idx:'init-bus',lst:cpy.actList,bit:a.idx},ste)
complete(lst)
exportconstcreateBus=(cpy:BusModel,bal:BusBit,ste:State)=>{
varclient=cpy.MQTT.connect(bal.src);
if(bal.slv!=null)bal.slv({busBit:{idx:"create-bus",dat:client}});
exportconstopenBus=async(cpy:BusModel,bal:BusBit,ste:State)=>{
varout=[]
bal.lst.forEach((a)=>{
if(a==null)return
if(a.includes==null)return
if(a.includes('[')&&a.includes(']')==false)return
out.push(a)
varclient=cpy.client;
if(bal.bit!=null){
bit=awaitste.hunt(ActCol.READ_COLLECT,{idx:bal.bit,bit:ActBus.CREATE_BUS})
client=bit.clcBit.dat
out.forEach((a)=>{
client.subscribe(a,async(err)=>{
if(!err){
exportconstconnectBus=(cpy:BusModel,bal:BusBit,ste:State)=>{
varlst=[]
exportconstmessageBus=async(cpy:BusModel,bal:BusBit,ste:State)=>{
if(bal.src!=null)dat=bal.src.toString()
idx=bal.idx
dat=JSON.parse(dat)
varclient=cpy.client;
if(bal.bit!=null){
bit=awaitste.hunt(ActCol.READ_COLLECT,{idx:bal.bit,bit:ActBus.CREATE_BUS})
client=bit.clcBit.dat
if(idx.includes(cpy.responseSuffix)==true){
varresponseIDX=bal.idx;
varobj=cpy.promises[responseIDX];
if(obj.slv!=null)obj.slv(dat);
client.unsubscribe(responseIDX,(err)=>{
if(!err){
}else{
varbit=awaitste.hunt(idx,dat)
varcloneBit=clone(bit)
for(varkeyincloneBit){
varitm=cloneBit[key]
if(itm.dat!=null){
if(itm.dat.bit!=null)itm.dat.bit=null
cloneBit
client.publish(bal.idx+cpy.responseSuffix,JSON.stringify(cloneBit))
exportconstupdateBus=async(cpy:BusModel,bal:BusBit,ste:State)=>{
varclient=cpy.client;
if(bal.bit!=null){
bit=awaitste.hunt(ActCol.READ_COLLECT,{idx:bal.bit,bit:ActBus.CREATE_BUS})
client=bit.clcBit.dat
if((client==null)&&(bal.bit==null)){
bit=awaitste.hunt(ActCol.FETCH_COLLECT,{bit:ActBus.CREATE_BUS})
client=bit.clcBit.dat
varresponseIDX=bal.idx+cpy.responseSuffix;
varslv;
constpromo=newPromise((rslv,rjct)=>(slv=rslv));
varobj={slv:(val0)=>slv(val0)};
cpy.promises[responseIDX]=obj
client.subscribe(responseIDX,(err)=>{
if(!err){
client.publish(bal.idx,JSON.stringify(bal.dat))
returnpromo;
varpatch=(ste,type,bale)=>ste.dispatch({type,bale});
import{BusModel}from"../bus.model";
importBusBitfrom"../fce/bus.bit";
importStatefrom"../../99.core/state";
importSfrom"string";
import*asclonefrom"clone-deep";
"usestrict";
exports.__esModule=true;
exportdefaultinterfaceBusBit{
idx:string;
val?:number;
lst?:any;
src?:any;
bit?:string;
slv?:Function;
dat?:any;
"usestrict";
exports.__esModule=true;
importBusBitfrom"./bus.bit";
exportdefaultinterfaceBus{
exportinterfaceAction<T=any>{
type:string;
bale?:T;
exportdefaultinterfaceModel{}
import{BehaviorSubject}from"rx-lite";
import{Subject}from"rx-lite";
import{Action}from"./interface/action.interface";
importUnitModelfrom"../BEE";
import*asEffectfrom"../BEE";
exportdefaultclassStateextendsBehaviorSubject<any>{
publichunt:any;
publicvalue:any;
publicpivot:any;
publicbus:any;
privatedispatcher:Subject=newSubject();
constructor(init:UnitModel=newUnitModel()){
super(init);
this.dispatcher
.scan((state,action)=>this.reducedApp(state,action),init)
.subscribe((state)=>{
super.onNext(state);
});
reducedApp(nextState:any,key:any){
for(varkinEffect.reducer)Effect.reducer[k](nextState[k],key,this);
returnnextState;
dispatch(value:Action){
varresult=this.dispatcher.onNext(value);
returnresult;
pat(value:Action){
this.dispatch(value);
next(value:any){
this.dispatcher.onNext(value);
exportconstINIT_CANVAS="[Canvasaction]InitCanvas";
exportconstUPDATE_CANVAS="[Canvasaction]UpdateCanvas";
exportconstREAD_CANVAS="[Readaction]ReadCanvas";
exportconstWRITE_CANVAS="[Writeaction]WriteCanvas";
exportconstDELETE_CANVAS="[Deleteaction]DeleteCanvas";
exportconstREMOVE_CANVAS="[Removeaction]RemoveCanvas";
exportconstCREATE_CANVAS="[Createaction]CreateCanvas";
exportconstNEST_CANVAS="[Nestaction]NestCanvas";
exportconstINIT_CHOICE="[Choiceaction]InitChoice";
exportconstUPDATE_CHOICE="[Choiceaction]UpdateChoice";
exportconstOPEN_CHOICE="[Openaction]OpenChoice";
exportconstKEY_CHOICE="[Keyaction]KeyChoice";
exportconstTOWER_CHOICE="[Toweraction]TowerChoice";
exportconstINIT_CONSOLE="[Consoleaction]InitConsole";
exportconstUPDATE_CONSOLE="[Consoleaction]UpdateConsole";
exportconstREAD_CONSOLE="[Readaction]ReadConsole";
exportconstWRITE_CONSOLE="[Writeaction]WriteConsole";
exportconstREMOVE_CONSOLE="[Removeaction]RemoveConsole";
exportconstDELETE_CONSOLE="[Deleteaction]DeleteConsole";
exportconstCREATE_CONSOLE="[Createaction]CreateConsole";
"usestrict";
exports.__esModule=true;
exports.COPY_DISK=exports.LOAD_LIST_DISK=exports.LIST_DISK=exports.WRITE_DISK=exports.READ_DISK=exports.UPDATE_DISK=exports.INIT_DISK=void0;
exports.INIT_DISK="[Diskaction]InitDisk";
exports.UPDATE_DISK="[Diskaction]UpdateDisk";
exports.READ_DISK="[Diskaction]ReadDisk";
exports.WRITE_DISK="[Diskaction]WriteDisk";
exports.LIST_DISK="[Listaction]ListDisk";
exports.LOAD_LIST_DISK="[Load_listaction]Load_listDisk";
exports.COPY_DISK="[Copyaction]CopyDisk";
exportconstINIT_DISK='[Diskaction]InitDisk'
exportconstUPDATE_DISK='[Diskaction]UpdateDisk'
exportconstREAD_DISK='[Diskaction]ReadDisk'
exportconstWRITE_DISK='[Diskaction]WriteDisk'
exportconstINDEX_DISK='[Indexaction]IndexDisk'
exportconstLOAD_LIST_DISK='[Load_listaction]Load_listDisk'
exportconstCOPY_DISK='[Copyaction]CopyDisk'
exportconstFRAME_DISK='[Frameaction]FrameDisk'
exportconstBATCH_DISK='[Batchaction]BatchDisk'
exportconstTRASH_DISK='[Trashaction]TrashDisk'
exportconstENSURE_DISK='[Ensureaction]EnsureDisk'
exportconstDELETE_DISK='[Deleteaction]DeleteDisk'
exportconstINIT_ENGINE="[Engineaction]InitEngine";
exportconstUPDATE_ENGINE="[Engineaction]UpdateEngine";
exportconstMOVEMENT_ENGINE="[Movementaction]MovementEngine";
exportconstOPEN_ENGINE="[Openaction]OpenEngine";
exportconstCLOSE_ENGINE="[Closeaction]CloseEngine";
exportconstINIT_GITHUB="[Githubaction]InitGithub";
exportconstUPDATE_GITHUB="[Githubaction]UpdateGithub";
exportconstCOMMIT_GITHUB="[Commitaction]CommitGithub";
import{Action}from"../99.core/interface/action.interface";
exportconstINIT_GRAPHIC="[Graphicaction]InitGraphic";
exportconstUPDATE_GRAPHIC="[Graphicaction]UpdateGraphic";
exportconstREAD_GRAPHIC="[Readaction]ReadGraphic";
exportconstWRITE_GRAPHIC="[Writeaction]WriteGraphic";
exportconstCREATE_GRAPHIC="[Createaction]CreateGraphic";
exportconstINIT_GRID="[Gridaction]InitGrid";
exportconstUPDATE_GRID="[Gridaction]UpdateGrid";
exportconstINIT_HEXAGON="[Hexagonaction]InitHexagon";
exportconstUPDATE_HEXAGON="[Hexagonaction]UpdateHexagon";
exportconstREAD_HEXAGON="[Readaction]ReadHexagon";
exportconstWRITE_HEXAGON="[Writeaction]WriteHexagon";
exportconstCREATE_HEXAGON="[Createaction]CreateHexagon";
exportconstINIT_INPUT="[Inputaction]InitInput";
exportconstUPDATE_INPUT="[Inputaction]UpdateInput";
exportconstOPEN_INPUT="[Openaction]OpenInput";
exportconstINIT_PIVOT="[Pivotaction]InitPivot";
exportconstUPDATE_PIVOT="[Pivotaction]UpdatePivot";
exportconstOPEN_PIVOT="[Openaction]OpenPivot";
exportconstRUN_PIVOT="[Runaction]RunPivot";
exportconstEDIT_PIVOT="[Editaction]EditPivot";
exportconstPATCH_PIVOT="[Patchaction]PatchPivot";
exportconstCOUNT_PIVOT="[Patchaction]CountPivot";
exportconstLIST_PIVOT="[Patchaction]ListPivot";
exportconstCREATE_PIVOT="[Patchaction]CreatePivot";
exportconstCONTAINS_PIVOT="[Patchaction]ContainsPivot";
exportconstBUNDLE_PIVOT="[Patchaction]BundlePivot";
"usestrict";
exports.__esModule=true;
exports.OPEN_RENPY=exports.UPDATE_RENPY=exports.INIT_RENPY=void0;
exports.INIT_RENPY="[Renpyaction]InitRenpy";
exports.UPDATE_RENPY="[Renpyaction]UpdateRenpy";
exports.OPEN_RENPY="[Renpyaction]OpenRenpy";
exportconstINIT_RENPY="[Renpyaction]InitRenpy";
exportconstUPDATE_RENPY="[Renpyaction]UpdateRenpy";
exportconstOPEN_RENPY="[Renpyaction]OpenRenpy";
"usestrict";
exports.__esModule=true;
exports.OPEN_SHINY=exports.UPDATE_SHINY=exports.INIT_SHINY=void0;
exports.INIT_SHINY="[Shinyaction]InitShiny";
exports.UPDATE_SHINY="[Shinyaction]UpdateShiny";
exports.OPEN_SHINY="[Shinyaction]OpenShiny";
exportconstINIT_SHINY="[Shinyaction]InitShiny";
exportconstUPDATE_SHINY="[Shinyaction]UpdateShiny";
exportconstOPEN_SHINY="[Shinyaction]OpenShiny";
"usestrict";
exports.__esModule=true;
exports.READY_SPACE=exports.UPDATE_SPACE=exports.INIT_SPACE=void0;
exports.INIT_SPACE="[Spaceaction]InitSpace";
exports.UPDATE_SPACE="[Spaceaction]UpdateSpace";
exports.READY_SPACE="[Readyaction]ReadySpace";
exportconstINIT_SPACE="[Spaceaction]InitSpace";
exportconstUPDATE_SPACE="[Spaceaction]UpdateSpace";
exportconstREADY_SPACE="[Readyaction]ReadySpace";
"usestrict";
exports.__esModule=true;
exports.ADD_PORT=exports.CONTENT_TERMINAL=exports.ROOT_TERMINAL=exports.CLOSE_TERMINAL=exports.TABLE_TERMINAL=exports.INPUT_TERMINAL=exports.CLEAR_TERMINAL=exports.UPDATE_TERMINAL=exports.WRITE_TERMINAL=exports.FOCUS_TERMINAL=exports.OPEN_TERMINAL=exports.INIT_TERMINAL=void0;
exports.INIT_TERMINAL="[Terminalaction]InitTerminal";
exports.OPEN_TERMINAL="[Terminalaction]OpenTerminal";
exports.FOCUS_TERMINAL="[Terminalaction]FocusTerminal";
exports.WRITE_TERMINAL="[Terminalaction]WriteTerminal";
exports.UPDATE_TERMINAL="[Terminalaction]UpdateTerminal";
exports.CLEAR_TERMINAL="[Terminalaction]ClearTerminal";
exports.INPUT_TERMINAL="[Terminalaction]InputTerminal";
exports.TABLE_TERMINAL="[Terminalaction]TableTerminal";
exports.CLOSE_TERMINAL="[Terminalaction]CloseTerminal";
exports.ROOT_TERMINAL="[Terminalaction]RootTerminal";
exports.CONTENT_TERMINAL="[Terminalaction]ContentTerminal";
exports.ADD_PORT="[Terminalaction]AddPort";
exportconstINIT_TERMINAL="[Terminalaction]InitTerminal";
exportconstUPDATE_TERMINAL="[Terminalaction]UpdateTerminal";
exportconstRUN_TERMINAL="[Runaction]RunTerminal";
exportconstEDIT_TERMINAL="[Editaction]EditTerminal";
exportconstPRINT_TERMINAL="[Printaction]PrintTerminal";
exportconstCLOSE_TERMINAL="[Closeaction]CloseTerminal";
exportconstOPTION_TERMINAL="[Optionaction]OptionTerminal";
exportconstINPUT_TERMINAL="[Inputaction]InputTerminal";
exportconstLAYOUT_TERMINAL="[Layoutaction]LayoutTerminal";
exportconstOPEN_TERMINAL="[Layoutaction]OpenTerminal";
exportconstCLEAR_TERMINAL="[Layoutaction]ClearTerminal";
exportconstINIT_TEXT="[Textaction]InitText";
exportconstUPDATE_TEXT="[Textaction]UpdateText";
exportconstREAD_TEXT="[Readaction]ReadText";
exportconstWRITE_TEXT="[Writeaction]WriteText";
exportconstCREATE_TEXT="[Createaction]CreateText";
exportconstREMOVE_TEXT="[Removeaction]RemoveText";
exportconstDELETE_TEXT="[Deleteaction]DeleteText";
exportconstLIST_TEXT="[Listaction]ListText";
exportconstINIT_VISAGE="[Visageaction]InitVisage";
exportconstUPDATE_VISAGE="[Visageaction]UpdateVisage";
exportconstFULLSCREEN_VISAGE="[Fullscreenaction]FullscreenVisage";
exportconstREAD_VISAGE="[Readaction]ReadVisage";
exportconstWRITE_VISAGE="[Writeaction]WriteVisage";
exportconstCREATE_VISAGE="[Createaction]CreateVisage";
exportconstSIZE_VISAGE="[Sizeaction]SizeVisage";
exportconstRENDER_VISAGE="[Renderaction]RenderVisage";
"usestrict";
exports.__esModule=true;
exports.VALUE_VURT=exports.BUNDLE_VURT=exports.CONTAINS_VURT=exports.LIST_UNIT_VURT=exports.LIST_PIVOT_VURT=exports.COUNT_VURT=exports.UNIT_VURT=exports.REPLACE_VURT=exports.UPDATE_VURT=exports.FETCH_VURT=exports.TEST_CLOUD_VURT=exports.DELAY_VURT=exports.INIT_VURT=void0;
exports.INIT_VURT="[Vurtaction]InitVurt";
exports.DELAY_VURT="[Vurtaction]DelayVurt";
exports.TEST_CLOUD_VURT="[Vurtaction]TestCloudVurt";
exports.FETCH_VURT="[Vurtaction]FetchVurt";
exports.UPDATE_VURT="[Vurtaction]UpdateVurt";
exports.REPLACE_VURT="[Vurtaction]ReplaceVurt";
exports.UNIT_VURT="[Vurtaction]UnitVurt";
exports.COUNT_VURT="[Vurtaction]CountVurt";
exports.LIST_PIVOT_VURT="[Vurtaction]ListPivotVurt";
exports.LIST_UNIT_VURT="[Vurtaction]ListUnitVurt";
exports.CONTAINS_VURT="[Containsaction]ContainsVurt";
exports.BUNDLE_VURT="[Bundleaction]BundleVurt";
exports.VALUE_VURT="[Valueaction]ValueVurt";
exportconstINIT_VURT="[Vurtaction]InitVurt";
exportconstDELAY_VURT="[Vurtaction]DelayVurt";
exportconstTEST_CLOUD_VURT="[Vurtaction]TestCloudVurt";
exportconstFETCH_VURT="[Vurtaction]FetchVurt";
exportconstUPDATE_VURT="[Vurtaction]UpdateVurt";
exportconstREPLACE_VURT="[Vurtaction]ReplaceVurt";
exportconstUNIT_VURT="[Vurtaction]UnitVurt";
exportconstCOUNT_VURT="[Vurtaction]CountVurt";
exportconstLIST_PIVOT_VURT="[Vurtaction]ListPivotVurt";
exportconstLIST_UNIT_VURT="[Vurtaction]ListUnitVurt";
exportconstCONTAINS_VURT="[Containsaction]ContainsVurt";
exportconstBUNDLE_VURT="[Bundleaction]BundleVurt";
exportconstVALUE_VURT="[Valueaction]ValueVurt";
importModelfrom"./99.core/interface/model.interface";
importTimeUnitfrom"./00.time.unit/time.unit";
importClockUnitfrom"./03.clock.unit/clock.unit";
importCollectUnitfrom"./97.collect.unit/collect.unit";
importBusUnitfrom"./99.bus.unit/bus.unit";
importTimefrom"./00.time.unit/fce/time.interface";
import{TimeModel}from"./00.time.unit/time.model";
importClockfrom"./03.clock.unit/fce/clock.interface";
import{ClockModel}from"./03.clock.unit/clock.model";
importCollectfrom"./97.collect.unit/fce/collect.interface";
import{CollectModel}from"./97.collect.unit/collect.model";
importBusfrom"./99.bus.unit/fce/bus.interface";
import{BusModel}from"./99.bus.unit/bus.model";
exportconstlist:Array<any>=[TimeUnit,ClockUnit,CollectUnit,BusUnit];
import*asreduceFromTimefrom"./00.time.unit/time.reduce";
import*asreduceFromClockfrom"./03.clock.unit/clock.reduce";
import*asreduceFromCollectfrom"./97.collect.unit/collect.reduce";
import*asreduceFromBusfrom"./99.bus.unit/bus.reduce";
exportconstreducer:any={
time:reduceFromTime.reducer,
clock:reduceFromClock.reducer,
collect:reduceFromCollect.reducer,
bus:reduceFromBus.reducer,
exportdefaultclassUnitDataimplementsModel{
time:Time=newTimeModel();
clock:Clock=newClockModel();
collect:Collect=newCollectModel();
bus:Bus=newBusModel();
varsim={
hunt:null,
state:null
sim.hunt=(typ,obj)=>{returnhost(obj,typ)}
varhost=(obj,typ)=>{
init();
varslv;
constpromo=newPromise((rslv,rjct)=>(slv=rslv));
if(obj==null)obj={};
if(obj.slv==null)obj.slv=(val0)=>slv(val0);
sim.state.dispatch({type:typ,bale:obj});
returnpromo;
varinit=()=>{
if(sim.state!=null)return;
sim.state=newState();
sim.state.pivot=sim;
sim.state.hunt=sim.hunt
for(varkinImport.list)newImport.list[k](sim.state);
import*asImportfrom"./BEE";
importStatefrom"./99.core/state";
module.exports=sim;
exportconstVERTICAL="vertical";
exportconstHORIZONTAL="horizontal";
exportconstBLACK:string="black";
exportconstRED:string="red";
exportconstGREEN:string="green";
exportconstYELLOW:string="yellow";
exportconstMAGENTA:string="magenta";
exportconstCYAN:string="cyan";
exportconstWHITE:string="white";
exportconstBLUE:string="blue";
"usestrict";
exports.__esModule=true;
exports.CYAN=exports.MAGENTA=exports.YELLOW=exports.GREEN=exports.RED=void0;
exports.RED="\x1b[31m%s\x1b[0m";
exports.GREEN="\x1b[32m%s\x1b[0m";
exports.YELLOW="\x1b[33m%s\x1b[0m";
exports.MAGENTA="\x1b[34m%s\x1b[0m";
exports.CYAN="\x1b[36m%s\x1b[0m";
exportconstRED:string="\x1b[31m%s\x1b[0m";
exportconstGREEN:string="\x1b[32m%s\x1b[0m";
exportconstYELLOW:string="\x1b[33m%s\x1b[0m";
exportconstMAGENTA:string="\x1b[34m%s\x1b[0m";
exportconstCYAN:string="\x1b[36m%s\x1b[0m";
"usestrict";
exports.__esModule=true;
exports.WISE_NORTH_EAST=exports.WISE_NORTH=exports.WISE_NORTH_WEST=exports.WISE_WEST=exports.WISE_SOUTH_WEST=exports.WISE_SOUTH=exports.WISE_SOUTH_EAST=exports.WISE_EAST=exports.NORTH_EAST=exports.NORTH=exports.NORTH_WEST=exports.WEST=exports.SOUTH_WEST=exports.SOUTH=exports.SOUTH_EAST=exports.EAST=void0;
exports.EAST="E";
exports.SOUTH_EAST="SE";
exports.SOUTH="S";
exports.SOUTH_WEST="SW";
exports.WEST="W";
exports.NORTH_WEST="NW";
exports.NORTH="N";
exports.NORTH_EAST="NE";
exports.WISE_EAST="WiseE";
exports.WISE_SOUTH_EAST="WiseSE";
exports.WISE_SOUTH="WiseS";
exports.WISE_SOUTH_WEST="WiseSW";
exports.WISE_WEST="WiseW";
exports.WISE_NORTH_WEST="WiseNW";
exports.WISE_NORTH="WiseN";
exports.WISE_NORTH_EAST="WiseNE";
exportconstEAST="E";
exportconstSOUTH_EAST="SE";
exportconstSOUTH="S";
exportconstSOUTH_WEST="SW";
exportconstWEST="W";
exportconstNORTH_WEST="NW";
exportconstNORTH="N";
exportconstNORTH_EAST="NE";
exportconstWISE_EAST="WiseE";
exportconstWISE_SOUTH_EAST="WiseSE";
exportconstWISE_SOUTH="WiseS";
exportconstWISE_SOUTH_WEST="WiseSW";
exportconstWISE_WEST="WiseW";
exportconstWISE_NORTH_WEST="WiseNW";
exportconstWISE_NORTH="WiseN";
exportconstWISE_NORTH_EAST="WiseNE";
exportconstPLAT:string="plat";
exportconstAMBT:string="ambt";
exportconstAVAS:string="avas";
"usestrict";
exports.__esModule=true;
exports.CIRCLE=exports.ROUNDED_RECTANGLE=exports.RECTANGLE=void0;
exports.RECTANGLE="rectangle";
exports.ROUNDED_RECTANGLE="rounded-rectangle";
exports.CIRCLE="circle";
exportconstRECTANGLE:string="rectangle";
exportconstROUNDED_RECTANGLE:string="rounded-rectangle";
exportconstCIRCLE:string="circle";
exporttypePosition<Type>={
x:number;
y:number;
}&Type
exporttypeGridFill=Position<{
xSpan:number;
ySpan:number;
exportconstTOP_FULL_IDX='top-fill';
exportconstMID_FULL_IDX='mid-fill';
exportconstBOT_FULL_IDX='bot-fill';
exportconstTOP_FULL_BIT:GridFill={x:0,y:0,xSpan:12,ySpan:4};
exportconstMID_FULL_BIT:GridFill={x:0,y:4,xSpan:12,ySpan:5};
exportconstBOT_FULL_BIT:GridFill={x:0,y:8,xSpan:12,ySpan:4};
"usestrict";
exports.__esModule=true;
exports.HEXMAP=exports.FOCUS=void0;
exports.FOCUS="focus";
exports.HEXMAP="hexmap";
exportconstFOCUS:string="focus";
exportconstHEXMAP:string="hexmap";
"usestrict";
exports.__esModule=true;
exports.PASTURE=exports.FANG_SWAMP=exports.GEORGIA=exports.GALLBLADDER=void0;
exports.GALLBLADDER="00000.gallbladder";
exports.GEORGIA="00001.georgia";
exports.FANG_SWAMP="00002.fang-swamp";
exports.PASTURE="00003.pasture";
exportconstPLAT:string="plat";
exportconstAMBT:string="ambt";
exportconstAVAS:string="avas";
exportconstWELCOME_WINDOW:string="welcomeWindow";
exportconstPLAY_DATA_GROUP:string="playerDataGroup";
exportconstICON_WINDOW:string="iconWindow";
exportconstDEBUG_WINDOW:string="debugWindow";
exportconstACTION_BAR:string="actionBar";
exportconstCLOCK_BAR:string="clockBar";
exportconstERROR_MESSAGE:string="errorMessage";
exportconstCOVER_SCREEN:string="coverScreen";
"usestrict";
exports.__esModule=true;
exports.MAGENTA=exports.YELLOW=exports.BLUE=exports.GREEN=exports.RED=exports.CYAN=exports.CLEAN=exports.MENU_SINGLE=exports.TIMELINE=exports.SPACE=void0;
exports.SPACE="space";
exports.TIMELINE="timeline";
exports.MENU_SINGLE="menu_single";
exports.CLEAN="clean";
exports.CYAN="cyan";
exports.RED="red";
exports.GREEN="green";
exports.BLUE="blue";
exports.YELLOW="yellow";
exports.MAGENTA="magenta";
exportconstSPACE:string="space";
exportconstTIMELINE:string="timeline";
exportconstMENU_SINGLE:string="menu_single";
exportconstCLEAN:string="clean";
exportconstCYAN:string="cyan";
exportconstRED:string="red";
exportconstGREEN:string="green";
exportconstBLUE:string="blue";
exportconstYELLOW:string="yellow";
exportconstMAGENTA:string="magenta";
"usestrict";
exports.__esModule=true;
exports.LOOP=exports.VIDEO=exports.HEXAGON=exports.SPRITE=exports.TEXT=exports.GRAPHIC=exports.CONTAINER=exports.SURFACE=exports.VISAGE=void0;
exports.VISAGE="visage";
exports.SURFACE="surface";
exports.CONTAINER="container";
exports.GRAPHIC="graphic";
exports.TEXT="text";
exports.SPRITE="sprite";
exports.HEXAGON="hexagon";
exports.VIDEO="video";
exports.LOOP="loop";
exportconstVISAGE:string="visage";
exportconstSURFACE:string="surface";
exportconstCONTAINER:string="container";
exportconstGRAPHIC:string="graphic";
exportconstTEXT:string="text";
exportconstSPRITE:string="sprite";
exportconstHEXAGON:string="hexagon";
exportconstVIDEO:string="video";
exportconstLOOP:string="loop";
exportconstGEOJSON="geojson";
exportconstRECTANGLE="rectangle";
exportconstTRIANGLE="triangle";
exportconstHEXAGON="hexagon";
exportconstPARALLELOGRAM="parallelogram";
exportconstFOCUS="focus";
exportconstHEXMAP="hexmap";
exportconstCLOCK:string="clock";
"usestrict";
exports.__esModule=true;
exports.MOUNT_WIDTH=exports.MOUNT_HEIGHT=exports.MOUNT_PART=exports.MOUNT_FULL=exports.SCREEN=void0;
exports.SCREEN="screen-visage";
exports.MOUNT_FULL="mount-visage-full";
exports.MOUNT_PART="mount-visage-part";
exports.MOUNT_HEIGHT="mount-visage-height";
exports.MOUNT_WIDTH="mount-visage-width";
exportconstSCREEN:string="screen-visage";
exportconstMOUNT_FULL:string="mount-visage-full";
exportconstMOUNT_PART:string="mount-visage-part";
exportconstMOUNT_HEIGHT:string="mount-visage-height";
exportconstMOUNT_WIDTH:string="mount-visage-width";
import{SpaceModel}from"../space.model";
importSpaceBitfrom"../fce/space.bit";
importStatefrom"../../99.core/state";
import*asSfrom'string'
import*asActSpcfrom"../../00.space.unit/space.action";
import*asActGeofrom"../../02.geojson.unit/geojson.action";
import*asActMapfrom"../../03.hexmap.unit/hexmap.action";
import*asActFocfrom"../../01.focus.unit/focus.action";
import*asActColfrom"../../97.collect.unit/collect.action";
import*asActPvtfrom"../../act/pivot.action";
import*asActDskfrom"../../act/disk.action";
import*asActBusfrom"../../99.bus.unit/bus.action";
varbit,lst,dex,src,dat;
exportconstinitSpace=async(cpy:SpaceModel,bal:SpaceBit,ste:State)=>{
debugger
bal.slv({intBit:{idx:"init-space"}});
exportconstupdateSpace=(cpy:SpaceModel,bal:SpaceBit,ste:State)=>{
bal.slv({spcBit:{idx:"update-space"}});
exportconsttestSpace=async(cpy:SpaceModel,bal:SpaceBit,ste:State)=>{
bal.slv({spcBit:{idx:"test-space",src:"testing-space",val:1}});
varpatch=(ste,type,bale)=>ste.dispatch({type,bale});
exportdefaultinterfaceSpaceBit{
idx:string;
val?:number;
src?:string;
slv?:Function;
prt?:any;
dat?:any;
bit?:any;
importSpaceBitfrom"./space.bit";
exportdefaultinterfaceSpace{
import{Action}from"../99.core/interface/action.interface";
importSpaceBitfrom"./fce/space.bit";
exportconstINIT_SPACE="[Spaceaction]InitSpace";
exportclassInitSpaceimplementsAction{
readonlytype=INIT_SPACE;
constructor(publicbale:SpaceBit){}
exportconstUPDATE_SPACE="[Spaceaction]UpdateSpace";
exportclassUpdateSpaceimplementsAction{
readonlytype=UPDATE_SPACE;
constructor(publicbale:SpaceBit){}
exportconstTEST_SPACE="[Testaction]TestSpace";
exportclassTestSpaceimplementsAction{
readonlytype=TEST_SPACE;
constructor(publicbale:SpaceBit){}
exporttypeActions=|InitSpace|UpdateSpace
|TestSpace
export{initSpace}from"./buz/space.buzz";
export{updateSpace}from"./buz/space.buzz";
export{testSpace}from"./buz/space.buzz";
importSpacefrom"./fce/space.interface";
importSpaceBitfrom"./fce/space.interface";
exportclassSpaceModelimplementsSpace{
idx:string='002.space'
import*asclonefrom"clone-deep";
import*asActfrom"./space.action";
import{SpaceModel}from"./space.model";
import*asBuzzfrom"./space.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:SpaceModel=newSpaceModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.UPDATE_SPACE:
returnBuzz.updateSpace(clone(model),act.bale,state);
caseAct.INIT_SPACE:
returnBuzz.initSpace(clone(model),act.bale,state);
caseAct.TEST_SPACE:
returnBuzz.testSpace(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassSpaceUnit{
constructor(state:State){
global.SPACE=require("../dist/002.space/hunt");
import{Action}from"../99.core/interface/action.interface";
importBabylonBitfrom"./fce/babylon.bit";
exportconstINIT_BABYLON="[Babylonaction]InitBabylon";
exportclassInitBabylonimplementsAction{
readonlytype=INIT_BABYLON;
constructor(publicbale:BabylonBit){}
exportconstUPDATE_BABYLON="[Babylonaction]UpdateBabylon";
exportclassUpdateBabylonimplementsAction{
readonlytype=UPDATE_BABYLON;
constructor(publicbale:BabylonBit){}
exportconstOPEN_BABYLON="[Babylonaction]OpenBabylon";
exportclassOpenBabylonimplementsAction{
readonlytype=OPEN_BABYLON;
constructor(publicbale:BabylonBit){}
exportconstRECORD_BABYLON="[Babylonaction]RecordBabylon";
exportclassRecordBabylonimplementsAction{
readonlytype=RECORD_BABYLON;
constructor(publicbale:BabylonBit){}
exportconstACTION_BABYLON="[Babylonaction]ActionBabylon";
exportclassActionBabylonimplementsAction{
readonlytype=ACTION_BABYLON;
constructor(publicbale:BabylonBit){}
exportconstCUT_BABYLON="[Babylonaction]CutBabylon";
exportclassCutBabylonimplementsAction{
readonlytype=CUT_BABYLON;
constructor(publicbale:BabylonBit){}
exportconstCAMERA_BABYLON="[Babylonaction]CutBabylon";
exportclassCameraBabylonimplementsAction{
readonlytype=CAMERA_BABYLON;
constructor(publicbale:BabylonBit){}
exporttypeActions=|InitBabylon|UpdateBabylon|OpenBabylon|RecordBabylon
|ActionBabylon
|CutBabylon
|CameraBabylon
export{initBabylon}from"./buz/babylon.buzz";
export{updateBabylon}from"./buz/babylon.buzz";
export{openBabylon}from"./buz/babylon.buzz";
export{recordBabylon}from"./buz/babylon.buzz";
export{actionBabylon}from"./buz/babylon.buzz";
export{cutBabylon}from"./buz/babylon.buzz";
export{cameraBabylon}from"./buz/babylon.buzz";
importBabylonfrom"./fce/babylon.interface";
importBabylonBitfrom"./fce/babylon.interface";
exportclassBabylonModelimplementsBabylon{
recorder:any;
engine:any;
scene:any;
mmdRuntime:any;
motion:any;
import*asActfrom"./babylon.action";
import{BabylonModel}from"./babylon.model";
import*asBuzzfrom"./babylon.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:BabylonModel=newBabylonModel(),act:Act.Actions,state?:State){
varclone=require('clone-deep');
switch(act.type){
caseAct.UPDATE_BABYLON:
returnBuzz.updateBabylon(clone(model),act.bale,state);
caseAct.INIT_BABYLON:
returnBuzz.initBabylon(clone(model),act.bale,state);
caseAct.OPEN_BABYLON:
returnBuzz.openBabylon(clone(model),act.bale,state);
caseAct.RECORD_BABYLON:
returnBuzz.recordBabylon(clone(model),act.bale,state);
caseAct.ACTION_BABYLON:
returnBuzz.actionBabylon(clone(model),act.bale,state);
caseAct.CUT_BABYLON:
returnBuzz.cutBabylon(structuredClone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassBabylonUnit{
constructor(state:State){
import{Container,AnimatedSprite,Texture,Spritesheet,Assets,Sprite}from'pixi.js';
import*asBABYLONfrom'babylonjs'
importHavokPhysicsfrom"@babylonjs/havok";
import*asPIXIfrom'pixi.js'
import*asActMkufrom"../../10.miku.unit/miku.action"
import*asActScrfrom"../../08.screen.unit/screen.action"
declareconstBABYLONMMD:any;
import*asActBbyfrom"../../01.babylon.unit/babylon.action";
varbit
exportconstinitBabylon=async(cpy:BabylonModel,bal:BabylonBit,ste:State)=>{
debugger
bal.slv({intBit:{idx:"init-babylon"}});
varopened=false
varrecorder;
exportconstopenBabylon=async(cpy:BabylonModel,bal:BabylonBit,ste:State)=>{
if(opened==true){
return
opened=true;
asyncfunctiongetInitializedHavok(){
returnawaitHavokPhysics();
letcanvas=document.getElementById(bal.src)asany;
canvas=document.createElement("canvas");
canvas.style.width="100%";
canvas.style.height="100%";
canvas.id="gameCanvas";
document.body.appendChild(canvas);
constengine=newBABYLON.Engine(canvas,true);
constscene=newBABYLON.Scene(engine);
cpy.scene=scene;
varlight=newBABYLON.HemisphericLight('light1',newBABYLON.Vector3(0,1,0),scene);
engine.runRenderLoop(function(){
scene.render();
cpy.engine=engine
constcamera=newBABYLON.UniversalCamera("UniversalCamera",newBABYLON.Vector3(0,0,-10),scene);
constv0=newBABYLON.Vector3(0,0,0)
camera.setTarget(v0);
camera.attachControl(canvas,true);
recorder=newBABYLON.VideoRecorder(cpy.engine);
globalThis.HK=awaitgetInitializedHavok()
consthavokPlugin=newBABYLON.HavokPlugin();
scene.enablePhysics(newBABYLON.Vector3(0,-98,0),havokPlugin);
bit=awaitste.hunt(ActScr.WRITE_SCREEN,{idx:'src00'})
for(vari=0;i<100;i++){
bal.slv({intBit:{idx:"open-babylon"}});
exportconstupdateBabylon=(cpy:BabylonModel,bal:BabylonBit,ste:State)=>{
exportconstrecordBabylon=(cpy:BabylonModel,bal:BabylonBit,ste:State)=>{
recorder.startRecording("000.webm",22);
bal.slv({bbyBit:{idx:"record-babylon"}});
exportconstactionBabylon=async(cpy:BabylonModel,bal:BabylonBit,ste:State)=>{
recorder.startRecording("000.webm",60).then(async(videoBlob)=>{
constformData=newFormData();
try{
constresponse=awaitfetch('/api/upload-video',{
method:'POST',
body:formData,
if(response.ok){
constdata=awaitresponse.json();
}else{
console.error('Uploadfailed:',response.status,response.statusText);
}catch(error){
console.error('Errorduringupload:',error);
bal.slv({bbyBit:{idx:"action-babylon"}});
exportconstcutBabylon=(cpy:BabylonModel,bal:BabylonBit,ste:State)=>{
recorder.stopRecording()
bal.slv({bbyBit:{idx:"cut-babylon"}});
exportconstcameraBabylon=(cpy:BabylonModel,bal:BabylonBit,ste:State)=>{
bal.slv({bbyBit:{idx:"camera-babylon"}});
import{BabylonModel}from"../babylon.model";
importBabylonBitfrom"../fce/babylon.bit";
importStatefrom"../../99.core/state";
exportdefaultinterfaceBabylonBit{
idx:string;
src?:string;
val?:number;
dat?:any;
slv?:Function;
importBabylonBitfrom"./babylon.bit";
exportdefaultinterfaceBabylon{
import*asActFocfrom"../focus.action";
import*asActMapfrom"../../03.hexmap.unit/hexmap.action";
import*asActColfrom"../../97.collect.unit/collect.action";
varbit,val,idx,dex,lst,dat,src
exportconstinitFocus=(cpy:FocusModel,bal:FocusBit,ste:State)=>{
varlst=[ActFoc.OPEN_FOCUS];
bal.slv({intBit:{idx:"init-focus",lst}});
exportconstreadFocus=async(cpy:FocusModel,bal:FocusBit,ste:State)=>{
varslv=bal.slv;
if(bal.idx==null)bal.idx="foc00";
bit=awaitste.hunt(ActCol.READ_COLLECT,{idx:bal.idx,src:bal.src,bit:ActFoc.CREATE_FOCUS});
if(slv!=null)slv({focBit:{idx:"read-focus",dat:bit.clcBit.dat}});
exportconstwriteFocus=async(cpy:FocusModel,bal:FocusBit,ste:State)=>{
if(bal.idx==null)bal.idx="foc00";
bit=awaitste.hunt(ActCol.WRITE_COLLECT,{idx:bal.idx,src:bal.src,dat:bal.dat,bit:ActFoc.CREATE_FOCUS});
varspot:SpotBit=bit.clcBit.dat
if(bal.slv!=null)bal.slv({focBit:{idx:"write-focus",dat:spot}});
exportconstremoveFocus=(cpy:FocusModel,bal:FocusBit,ste:State)=>{
debugger
exportconstdeleteFocus=(cpy:FocusModel,bal:FocusBit,ste:State)=>{
debugger
exportconstlistFocus=async(cpy:FocusModel,bal:FocusBit,ste:State)=>{
dat=null
bit=awaitste.hunt(ActCol.FETCH_COLLECT,{val:0,bit:ActFoc.CREATE_FOCUS})
if(bal.src==null)bal.src=FOCUS.AMBT
src=bal.src
if(bit.clcBit.dat==null)lst=[]
elsedat=bit.clcBit.dat;
if(dat!=null){
lst=[]
varbitList=dat.bitList
varbits=dat.bits
dat.bitList.forEach((a)=>{
varitm=bitList[a.dex]
if(bal.src.toUpperCase()!=itm.typ.toUpperCase())return
lst.push(itm.idx)
if(bal.slv!=null)bal.slv({focBit:{idx:'list-focus',lst}});
exportconstcenterFocus=async(cpy:FocusModel,bal:FocusBit,ste:State)=>{
if(bal.slv!=null)bal.slv({focBit:{idx:"center-focus",dat}});
exportconstlocateFocus=async(cpy:FocusModel,bal:FocusBit,ste:State)=>{
bit=awaitste.hunt(ActFoc.READ_FOCUS,{idx:bal.idx})
varspot:SpotBit=bit.focBit.dat;
bit=awaitste.hunt(ActMap.READ_HEXMAP,{idx:spot.map})
varmap:MapBit=bit.mapBit.dat;
vargrid=map.dat;
varhex=grid.get({x:spot.x,y:spot.y});
varidx=spot.map+"-"+spot.x+"-"+spot.y;
spot.loc=hex;
if(bal.slv!=null)bal.slv({focBit:{idx:"locate-focus",dat:spot}});
exportconstselectFocus=async(cpy:FocusModel,bal:FocusBit,ste:State)=>{
bit=awaitste.hunt(ActFoc.READ_FOCUS,{idx:bal.idx})
varspot:SpotBit=bit.focBit.dat;
cpy.select=spot;
if(bal.slv!=null)bal.slv({focBit:{idx:"select-focus",dat:cpy.select}});
exportconstopenFocus=(cpy:FocusModel,bal:FocusBit,ste:State)=>{
if(bal.slv!=null)bal.slv({focBit:{idx:"open-focus",dat:{}}});
exportconstmodelFocus=async(cpy:FocusModel,bal:FocusBit,ste:State)=>{
if(bal.src==null)bal.src='GET'
switch(bal.src){
case'GET':
bit=awaitste.hunt(ActCol.GET_COLLECT,{idx:'focus'})
dat=bit.clcBit.dat;
break
case'PUT':
break
if(bal.slv!=null)bal.slv({focBit:{idx:"model-focus",dat}});
import{FocusModel}from"../focus.model";
importFocusBitfrom"../fce/focus.bit";
importStatefrom"../../99.core/state";
importSpotBitfrom"../fce/spot.bit";
import*asHoneycombfrom"honeycomb-grid";
import*asSHAPEfrom'../../val/shape'
import*asSPACEfrom"../../val/space"
import*asDIRECTIONfrom"../../val/direction"
import*asFOCUSfrom"../../val/focus"
importMapBitfrom"../../03.hexmap.unit/fce/map.bit";
import*asActFocfrom"../focus.action";
import*asActMapfrom"../../03.hexmap.unit/hexmap.action";
import*asActColfrom"../../97.collect.unit/collect.action";
varbit,val,idx,dex,lst,dat;
exportconstawakeFocus=async(cpy:FocusModel,bal:FocusBit,ste:State)=>{
if(bal.val==1){
bit=awaitste.hunt(ActFoc.WRITE_FOCUS,{idx:bal.idx,val:1,dat:{awake:true}})
bit=awaitste.hunt(ActFoc.UPDATE_FOCUS,{idx:bal.idx})
bit=awaitste.hunt(ActFoc.WRITE_FOCUS,{idx:bal.idx,val:1})
else{
bit=awaitste.hunt(ActFoc.WRITE_FOCUS,{idx:bal.idx,val:1,dat:{awake:false,viewList:[]}})
bit=awaitste.hunt(ActFoc.UPDATE_FOCUS,{idx:bal.idx})
bit=awaitste.hunt(ActFoc.WRITE_FOCUS,{idx:bal.idx,val:1})
if(bal.slv!=null)bal.slv({focBit:{idx:"awake-focus",dat}});
import{FocusModel}from"../focus.model";
importFocusBitfrom"../fce/focus.bit";
importStatefrom"../../99.core/state";
importSpotBitfrom"../fce/spot.bit";
import*asHoneycombfrom"honeycomb-grid";
import*asSHAPEfrom'../../val/shape'
import*asSPACEfrom"../../val/space"
import*asDIRECTIONfrom"../../val/direction"
import*asActFocfrom"../focus.action";
import*asActMapfrom"../../03.hexmap.unit/hexmap.action";
import*asActColfrom"../../97.collect.unit/collect.action";
varbit,val,idx,dex,lst,dat;
exportconstbackwardFocus=async(cpy:FocusModel,bal:FocusBit,ste:State)=>{
bit=awaitste.hunt(ActFoc.READ_FOCUS,{idx:bal.idx})
varspot:SpotBit=bit.focBit.dat;
varx=spot.x;
vary=spot.y;
varface=spot.face
varbonds,bond;
if(face==DIRECTION.WEST){
bit=awaitste.hunt(ActFoc.BOND_FOCUS,{idx:spot.idx,src:DIRECTION.EAST,dat:spot})
bonds=bit.focBit.dat
if(bonds!=null)bond=bonds[DIRECTION.EAST];
if(bond!=null){
x=bond.x;
y=bond.y;
if(face==DIRECTION.EAST){
bit=awaitste.hunt(ActFoc.BOND_FOCUS,{idx:spot.idx,src:DIRECTION.WEST,dat:spot})
bonds=bit.focBit.dat
if(bonds!=null)bond=bonds[DIRECTION.WEST];
if(bond!=null){
x=bond.x;
y=bond.y;
if(face==DIRECTION.NORTH_WEST){
bit=awaitste.hunt(ActFoc.BOND_FOCUS,{idx:spot.idx,src:DIRECTION.SOUTH_EAST,dat:spot})
bonds=bit.focBit.dat
if(bonds!=null)bond=bonds[DIRECTION.SOUTH_EAST];
if(bond!=null){
x=bond.x;
y=bond.y;
if(face==DIRECTION.NORTH_EAST){
bit=awaitste.hunt(ActFoc.BOND_FOCUS,{idx:spot.idx,src:DIRECTION.SOUTH_WEST,dat:spot})
bonds=bit.focBit.dat
if(bonds!=null)bond=bonds[DIRECTION.SOUTH_WEST];
if(bond!=null){
x=bond.x;
y=bond.y;
if(face==DIRECTION.SOUTH_WEST){
bit=awaitste.hunt(ActFoc.BOND_FOCUS,{idx:spot.idx,src:DIRECTION.NORTH_EAST,dat:spot})
bonds=bit.focBit.dat
if(bonds!=null)bond=bonds[DIRECTION.NORTH_EAST];
if(bond!=null){
x=bond.x;
y=bond.y;
if(face==DIRECTION.SOUTH_EAST){
bit=awaitste.hunt(ActFoc.BOND_FOCUS,{idx:spot.idx,src:DIRECTION.NORTH_WEST,dat:spot})
bonds=bit.focBit.dat
if(bonds!=null)bond=bonds[DIRECTION.NORTH_WEST];
if(bond!=null){
x=bond.x;
y=bond.y;
bit=awaitste.hunt(ActFoc.WRITE_FOCUS,{idx:bal.idx,dat:{x,y,bonds,face}})
if(bal.slv!=null)bal.slv({focBit:{idx:"backward-focus",dat:spot}});
import{FocusModel}from"../focus.model";
importFocusBitfrom"../fce/focus.bit";
importStatefrom"../../99.core/state";
importSpotBitfrom"../fce/spot.bit";
import*asHoneycombfrom"honeycomb-grid";
import*asSHAPEfrom'../../val/shape'
import*asSPACEfrom"../../val/space"
import*asDIRECTIONfrom"../../val/direction"
import*asActFocfrom"../focus.action";
import*asActMapfrom"../../03.hexmap.unit/hexmap.action";
import*asActColfrom"../../97.collect.unit/collect.action";
varbit,val,idx,dex,lst,dat;
exportconstbondFocus=async(cpy:FocusModel,bal:FocusBit,ste:State)=>{
varspot:SpotBit=bal.dat;
bit=awaitste.hunt(ActMap.READ_HEXMAP,{idx:spot.src})
varmap:MapBit=bit.mapBit.dat;
vargrid=map.grid;
if(grid==null)thrownewError("nomappresentfor"+bal.src);
varhex=grid.get({x:spot.x,y:spot.y});
varbonds={};
varitem;
varface=bal.src
if(face==null)face=spot.face
item=grid.neighborsOf(hex,compassConvertor(face));
if(item[0]==null){
bonds=null
else{
if(item[0]!=null)bonds[face]={x:item[0].x,y:item[0].y};
bonds
if(bal.slv!=null)bal.slv({focBit:{idx:"bond-focus",dat:bonds,bit:spot}});
constcompassConvertor=(val:string)=>{
varresult=0;
switch(val){
caseDIRECTION.NORTH_EAST:
result=5;
break;
caseDIRECTION.EAST:
result=0;
break;
caseDIRECTION.SOUTH_EAST:
result=1;
break;
caseDIRECTION.SOUTH_WEST:
result=2;
break;
caseDIRECTION.WEST:
result=3;
break;
caseDIRECTION.NORTH_WEST:
result=4;
break;
returnresult;
import{FocusModel}from"../focus.model";
importFocusBitfrom"../fce/focus.bit";
importStatefrom"../../99.core/state";
importSpotBitfrom"../fce/spot.bit";
import*asHoneycombfrom"honeycomb-grid";
import*asSHAPEfrom'../../val/shape'
import*asSPACEfrom"../../val/space"
import*asDIRECTIONfrom"../../val/direction"
importMapBitfrom"../../03.hexmap.unit/fce/map.bit";
import*asActFocfrom"../focus.action";
import*asActMapfrom"../../03.hexmap.unit/hexmap.action";
import*asActColfrom"../../97.collect.unit/collect.action";
varbit,val,idx,dex,lst,dat;
exportconstbrownianFocus=async(cpy:FocusModel,bal:FocusBit,ste:State)=>{
varspot:SpotBit;
varnow=Math.floor(Math.random()*11);
switch(now){
case0:
bit=awaitste.hunt(ActFoc.FORWARD_FOCUS,{idx:bal.idx})
spot=bit.focBit.bit;
break
case1:
bit=awaitste.hunt(ActFoc.FORWARD_FOCUS,{idx:bal.idx})
spot=bit.focBit.bit;
break
case2:
bit=awaitste.hunt(ActFoc.FORWARD_FOCUS,{idx:bal.idx})
spot=bit.focBit.bit;
break
case3:
bit=awaitste.hunt(ActFoc.FORWARD_FOCUS,{idx:bal.idx})
spot=bit.focBit.bit;
break
case4:
bit=awaitste.hunt(ActFoc.FORWARD_FOCUS,{idx:bal.idx})
spot=bit.focBit.bit;
break
case5:
bit=awaitste.hunt(ActFoc.FORWARD_FOCUS,{idx:bal.idx})
spot=bit.focBit.bit;
break
case6:
bit=awaitste.hunt(ActFoc.SPIN_LEFT_FOCUS,{idx:bal.idx})
spot=bit.focBit.bit;
break
case7:
bit=awaitste.hunt(ActFoc.SPIN_RIGHT_FOCUS,{idx:bal.idx})
spot=bit.focBit.bit;
break
case8:
bit=awaitste.hunt(ActFoc.SPIN_LEFT_FOCUS,{idx:bal.idx})
spot=bit.focBit.bit;
break
case9:
bit=awaitste.hunt(ActFoc.BACKWARD_FOCUS,{idx:bal.idx})
spot=bit.focBit.bit;
break
case10:
bit=awaitste.hunt(ActFoc.BACKWARD_FOCUS,{idx:bal.idx})
spot=bit.focBit.bit;
break
if(bal.slv!=null)bal.slv({focBit:{idx:"vision-focus",bit:spot}});
import{FocusModel}from"../focus.model";
importFocusBitfrom"../fce/focus.bit";
importStatefrom"../../99.core/state";
importSpotBitfrom"../fce/spot.bit";
import*asHoneycombfrom"honeycomb-grid";
import*asSHAPEfrom'../../val/shape'
import*asSPACEfrom"../../val/space"
import*asDIRECTIONfrom"../../val/direction"
importMapBitfrom"../../03.hexmap.unit/fce/map.bit";
import*asActFocfrom"../focus.action";
import*asActMapfrom"../../03.hexmap.unit/hexmap.action";
import*asActColfrom"../../97.collect.unit/collect.action";
varbit,val,idx,dex,lst,dat;
exportconstcornerFocus=async(cpy:FocusModel,bal:FocusBit,ste:State)=>{
varspot:SpotBit=bal.dat;
vargrid;
bit=awaitste.hunt(ActMap.READ_HEXMAP,{idx:spot.src})
grid=bit.mapBit.dat.grid;
if(grid==null)bal.slv({focBit:{idx:"corner-focus-error",lst,dat:spot}});
if(grid==null)return
varhex=grid.get({x:spot.x,y:spot.y});
constpoint=hex.toPoint();
lst=hex.corners().map((corner)=>corner.add(point));
spot.corners=lst
if(bal.slv!=null)bal.slv({focBit:{idx:"corner-focus",lst,bit:spot}});
import{FocusModel}from"../focus.model";
importFocusBitfrom"../fce/focus.bit";
importStatefrom"../../99.core/state";
importSpotBitfrom"../fce/spot.bit";
import*asHoneycombfrom"honeycomb-grid";
import*asSHAPEfrom'../../val/shape'
import*asSPACEfrom"../../val/space"
import*asFOCUSfrom"../../val/focus"
import*asDIRECTIONfrom"../../val/direction"
importMapBitfrom"../../03.hexmap.unit/fce/map.bit";
import*asActFocfrom"../focus.action";
import*asActMapfrom"../../03.hexmap.unit/hexmap.action";
import*asActColfrom"../../97.collect.unit/collect.action";
varbit,val,idx,dex,lst,dat;
exportconstcreateFocus=async(cpy:FocusModel,bal:FocusBit,ste:State)=>{
vardat:SpotBit={idx:bal.idx,src:bal.src,typ:FOCUS.AMBT};
for(varkeyinbal.dat){
dat[key]=bal.dat[key]
if(dat.gph==null)dat.gph='None'
dat.gph
if(dat.frm==null)dat.frm=SHAPE.RECTANGLE
if(dat.x==null)dat.x=0;
if(dat.y==null)dat.y=0;
if(dat.h==null)dat.h=1;
if(dat.w==null)dat.w=1;
if(dat.awake==null)dat.awake=false;
if(dat.face==null)dat.face='E'
if(dat.past==null)dat.past=[]
if(dat.update==null)dat.update=0;
if(dat.clock==null)dat.clock=0;
if(dat.updateSpeed==null)dat.updateSpeed=11;
if(dat.turnSpeed==null)dat.turnSpeed=11;
if(dat.spin==null)dat.spin=true
bit=awaitste.hunt(ActFoc.CORNER_FOCUS,{idx:dat.src,dat})
dat.corners=bit.focBit.lst;
bit=awaitste.hunt(ActFoc.BOND_FOCUS,{idx:bal.idx,src:dat.face,dat})
varbonds=bit.focBit.dat
dat.bonds=bonds
bal.slv({focBit:{idx:"create-focus",dat}});
import{FocusModel}from"../focus.model";
importFocusBitfrom"../fce/focus.bit";
importStatefrom"../../99.core/state";
importSpotBitfrom"../fce/spot.bit";
import*asHoneycombfrom"honeycomb-grid";
import*asSHAPEfrom'../../val/shape'
import*asSPACEfrom"../../val/space"
import*asFOCUSfrom"../../val/focus"
import*asDIRECTIONfrom"../../val/direction"
importMapBitfrom"../../03.hexmap.unit/fce/map.bit";
import*asActFocfrom"../focus.action";
import*asActMapfrom"../../03.hexmap.unit/hexmap.action";
import*asActColfrom"../../97.collect.unit/collect.action";
varbit,val,idx,dex,lst,dat;
exportconstforwardFocus=async(cpy:FocusModel,bal:FocusBit,ste:State)=>{
bit=awaitste.hunt(ActFoc.READ_FOCUS,{idx:bal.idx})
varspot:SpotBit=bit.focBit.dat;
varx=spot.x;
vary=spot.y;
varface=spot.face
varbonds=spot.bonds;
if(bonds==null){
bit=awaitste.hunt(ActFoc.BOND_FOCUS,{idx:bal.idx,src:face,dat:spot})
varbonds=bit.focBit.dat
spot.bonds=bonds
}else{
constnow=bonds[face]
if(now!=null){
x=now.x;
y=now.y;
spot.x=x
spot.y=y
bit=awaitste.hunt(ActFoc.BOND_FOCUS,{idx:bal.idx,src:face,dat:spot})
varbonds=bit.focBit.dat
spot.bonds=bonds
bit=awaitste.hunt(ActFoc.CORNER_FOCUS,{dat:spot})
spot.corners=bit.focBit.lst;
spot
bit=awaitste.hunt(ActFoc.WRITE_FOCUS,{idx:spot.idx,src:spot.src,dat:{x,y,bonds,face}})
if(bal.slv!=null)bal.slv({focBit:{idx:"forward-focus",bit:spot}});
import{FocusModel}from"../focus.model";
importFocusBitfrom"../fce/focus.bit";
importStatefrom"../../99.core/state";
importSpotBitfrom"../fce/spot.bit";
import*asHoneycombfrom"honeycomb-grid";
import*asSHAPEfrom'../../val/shape'
import*asSPACEfrom"../../val/space"
import*asDIRECTIONfrom"../../val/direction"
importMapBitfrom"../../03.hexmap.unit/fce/map.bit";
import*asActFocfrom"../focus.action";
import*asActMapfrom"../../03.hexmap.unit/hexmap.action";
import*asActColfrom"../../97.collect.unit/collect.action";
varbit,val,idx,dex,lst,dat;
exportconstspinLeftFocus=async(cpy:FocusModel,bal:FocusBit,ste:State)=>{
bit=awaitste.hunt(ActFoc.READ_FOCUS,{idx:bal.idx})
vardat:SpotBit=bit.focBit.dat;
varface;
switch(dat.face){
caseDIRECTION.NORTH_EAST:
face=DIRECTION.EAST;
break;
caseDIRECTION.NORTH_WEST:
face=DIRECTION.NORTH_EAST;
break;
caseDIRECTION.WEST:
face=DIRECTION.NORTH_WEST;
break;
caseDIRECTION.SOUTH_WEST:
face=DIRECTION.WEST;
break;
caseDIRECTION.SOUTH_EAST:
face=DIRECTION.SOUTH_WEST;
break;
caseDIRECTION.EAST:
face=DIRECTION.SOUTH_EAST;
break;
dat.move="";
dat.face=face;
bit=awaitste.hunt(ActFoc.BOND_FOCUS,{idx:dat.idx,src:dat.face,dat})
varbonds=bit.focBit.dat
dat.bonds=bonds
bit=awaitste.hunt(ActFoc.WRITE_FOCUS,{idx:dat.idx,dat})
if(bal.slv!=null)bal.slv({focBit:{idx:"spin-left-focus",bit:dat}});
import{FocusModel}from"../focus.model";
importFocusBitfrom"../fce/focus.bit";
importStatefrom"../../99.core/state";
importSpotBitfrom"../fce/spot.bit";
import*asHoneycombfrom"honeycomb-grid";
import*asSHAPEfrom'../../val/shape'
import*asSPACEfrom"../../val/space"
import*asDIRECTIONfrom"../../val/direction"
import*asActFocfrom"../focus.action";
import*asActMapfrom"../../03.hexmap.unit/hexmap.action";
import*asActColfrom"../../97.collect.unit/collect.action";
varbit,val,idx,dex,lst,dat;
exportconstspinRightFocus=async(cpy:FocusModel,bal:FocusBit,ste:State)=>{
bit=awaitste.hunt(ActFoc.READ_FOCUS,{idx:bal.idx})
vardat:SpotBit=bit.focBit.dat;
varface;
switch(dat.face){
caseDIRECTION.NORTH_EAST:
face=DIRECTION.NORTH_WEST;
break;
caseDIRECTION.NORTH_WEST:
face=DIRECTION.WEST;
break;
caseDIRECTION.WEST:
face=DIRECTION.SOUTH_WEST;
break;
caseDIRECTION.SOUTH_WEST:
face=DIRECTION.SOUTH_EAST;
break;
caseDIRECTION.SOUTH_EAST:
face=DIRECTION.EAST;
break;
caseDIRECTION.EAST:
face=DIRECTION.NORTH_EAST;
break;
dat.move="";
dat.face=face;
bit=awaitste.hunt(ActFoc.BOND_FOCUS,{idx:dat.idx,src:dat.face,dat})
varbonds=bit.focBit.dat
dat.bonds=bonds
bit=awaitste.hunt(ActFoc.WRITE_FOCUS,{idx:dat.idx,dat})
if(bal.slv!=null)bal.slv({focBit:{idx:"spin-right-focus",dat:{bit:dat}}});
import{FocusModel}from"../focus.model";
importFocusBitfrom"../fce/focus.bit";
importStatefrom"../../99.core/state";
importSpotBitfrom"../fce/spot.bit";
import*asHoneycombfrom"honeycomb-grid";
import*asSHAPEfrom'../../val/shape'
import*asSPACEfrom"../../val/space"
import*asDIRECTIONfrom"../../val/direction"
import*asActFocfrom"../focus.action";
import*asActMapfrom"../../03.hexmap.unit/hexmap.action";
import*asActColfrom"../../97.collect.unit/collect.action";
varbit,val,idx,dex,lst,dat;
varflag=false;
exportconstupdateFocus=async(cpy:FocusModel,bal:FocusBit,ste:State)=>{
if(flag==false){
flag=true;
if(bal.slv!=null)bal.slv({focBit:{idx:"update-focus"}});
return
bit=awaitste.hunt(ActFoc.READ_FOCUS,{idx:bal.idx})
varspot:SpotBit=bit.focBit.dat;
varviewList=[]
if(spot.awake==true){
bit=awaitste.hunt(ActFoc.VISION_FOCUS,{idx:bal.idx})
viewList=bit.focBit.lst;
else{
if(bal.slv!=null)bal.slv({focBit:{idx:"update-focus"}});
import{FocusModel}from"../focus.model";
importFocusBitfrom"../fce/focus.bit";
importStatefrom"../../99.core/state";
importSpotBitfrom"../fce/spot.bit";
import*asHoneycombfrom"honeycomb-grid";
import*asSHAPEfrom'../../val/shape'
import*asSPACEfrom"../../val/space"
import*asDIRECTIONfrom"../../val/direction"
importMapBitfrom"../../03.hexmap.unit/fce/map.bit";
import*asActFocfrom"../focus.action";
import*asActMapfrom"../../03.hexmap.unit/hexmap.action";
import*asActColfrom"../../97.collect.unit/collect.action";
varbit,val,idx,dex,lst,dat;
exportconstvisionFocus=async(cpy:FocusModel,bal:FocusBit,ste:State)=>{
bit=awaitste.hunt(ActFoc.READ_FOCUS,{idx:bal.idx})
varspot:SpotBit=bit.focBit.dat;
bit=awaitste.hunt(ActMap.READ_HEXMAP,{idx:spot.src})
varmap:MapBit=bit.mapBit.dat;
vargrid=map.grid;
varsize=3;
varcheck=[{face:spot.face,x:spot.x,y:spot.y}];
switch(spot.face){
caseDIRECTION.EAST:
check.push({face:spot.face,x:spot.x,y:spot.y+1});
check.push({face:spot.face,x:spot.x,y:spot.y-1});
break;
caseDIRECTION.WEST:
check.push({face:spot.face,x:spot.x,y:spot.y+1});
check.push({face:spot.face,x:spot.x,y:spot.y-1});
break;
caseDIRECTION.NORTH_EAST:
check.push({face:spot.face,x:spot.x,y:spot.y-1});
check.push({face:spot.face,x:spot.x,y:spot.y+1});
break;
caseDIRECTION.NORTH_WEST:
check.push({face:spot.face,x:spot.x,y:spot.y+1});
check.push({face:spot.face,x:spot.x,y:spot.y-1});
break;
caseDIRECTION.SOUTH_EAST:
check.push({face:spot.face,x:spot.x,y:spot.y+1});
check.push({face:spot.face,x:spot.x,y:spot.y-1});
break;
caseDIRECTION.SOUTH_WEST:
check.push({face:spot.face,x:spot.x,y:spot.y+1});
check.push({face:spot.face,x:spot.x,y:spot.y-1});
break;
caseDIRECTION.SOUTH_EAST:
check.push({face:spot.face,x:spot.x,y:spot.y+1});
check.push({face:spot.face,x:spot.x+1,y:spot.y-1});
break;
varoutput=[];
check.forEach((a,b)=>{
varlast=grid.get({x:a.x,y:a.y});
for(vari=0;i<size;i++){
if(last!=null){
varitem=grid.neighborsOf(last,compassConvertor(a.face));
if(item[0]!=null){
vardata={idx:"listing-vison-focus",src:spot.src,x:item[0].x,y:item[0].y,corners:[],h:null};
last=grid.get({x:data.x,y:data.y});
output.push(last.hex);
output
if(bal.slv!=null)bal.slv({focBit:{idx:"vision-focus",lst:output}});
constcompassConvertor=(val:string)=>{
varresult=0;
switch(val){
caseDIRECTION.NORTH_EAST:
result=5;
break;
caseDIRECTION.EAST:
result=0;
break;
caseDIRECTION.SOUTH_EAST:
result=1;
break;
caseDIRECTION.SOUTH_WEST:
result=2;
break;
caseDIRECTION.WEST:
result=3;
break;
caseDIRECTION.NORTH_WEST:
result=4;
break;
returnresult;
import{FocusModel}from"../focus.model";
importFocusBitfrom"../fce/focus.bit";
importStatefrom"../../99.core/state";
importSpotBitfrom"../fce/spot.bit";
import*asHoneycombfrom"honeycomb-grid";
import*asSHAPEfrom'../../val/shape'
import*asSPACEfrom"../../val/space"
import*asDIRECTIONfrom"../../val/direction"
importMapBitfrom"../../03.hexmap.unit/fce/map.bit";
exportdefaultinterfaceBondBit{
x:number;
y:number;
d?:string;
exportdefaultinterfaceFocusBit{
idx:string;
src?:string;
slv?:Function;
dat?:any;
bit?:any;
val:Number
importFocusBitfrom"./focus.bit";
exportdefaultinterfaceFocus{
importBondBitfrom"./bond.bit.interface";
exportdefaultinterfaceSpotBit{
idx:string;
src?:string;
typ?:string;
frm?:string;
map?:string;
slv?:Function;
sze?:number;
ort?:string;
x?:number;
y?:number;
w?:number;
h?:number;
awake?:boolean;
loc?:any;
face?:string;
past?:any[];
creation?:number;
bit?:any;
grid?:any;
update?:number;
clock?:number;
updateSpeed?:number;
turnSpeed?:number;
camX?:number;
camY?:number;
spin?:boolean
move?:string;
corners?:any;
area?:any;
vision?:any;
viewList?:BondBit[];
bonds?:any;
bondList?:BondBit[];
pastList?:string[];
import{Action}from"../99.core/interface/action.interface";
importFocusBitfrom"./fce/focus.bit";
exportconstINIT_FOCUS="[Focusaction]InitFocus";
exportclassInitFocusimplementsAction{
readonlytype=INIT_FOCUS;
constructor(publicbale:FocusBit){}
exportconstAWAKE_FOCUS="[Focusaction]AwakeFocus";
exportclassAwakeFocusimplementsAction{
readonlytype=AWAKE_FOCUS;
constructor(publicbale:FocusBit){}
exportconstUPDATE_FOCUS="[Focusaction]UpdateFocus";
exportclassUpdateFocusimplementsAction{
readonlytype=UPDATE_FOCUS;
constructor(publicbale:FocusBit){}
exportconstOPEN_FOCUS="[Focusaction]OpenFocus";
exportclassOpenFocusimplementsAction{
readonlytype=OPEN_FOCUS;
constructor(publicbale:FocusBit){}
exportconstCREATE_FOCUS="[Focusaction]CreateFocus";
exportclassCreateFocusimplementsAction{
readonlytype=CREATE_FOCUS;
constructor(publicbale:FocusBit){}
exportconstREAD_FOCUS="[Readaction]ReadFocus";
exportclassReadFocusimplementsAction{
readonlytype=READ_FOCUS;
constructor(publicbale:FocusBit){}
exportconstWRITE_FOCUS="[Writeaction]WriteFocus";
exportclassWriteFocusimplementsAction{
readonlytype=WRITE_FOCUS;
constructor(publicbale:FocusBit){}
exportconstREMOVE_FOCUS="[Removeaction]RemoveFocus";
exportclassRemoveFocusimplementsAction{
readonlytype=REMOVE_FOCUS;
constructor(publicbale:FocusBit){}
exportconstDELETE_FOCUS="[Deleteaction]DeleteFocus";
exportclassDeleteFocusimplementsAction{
readonlytype=DELETE_FOCUS;
constructor(publicbale:FocusBit){}
exportconstCORNER_FOCUS="[Corneraction]CornerFocus";
exportclassCornerFocusimplementsAction{
readonlytype=CORNER_FOCUS;
constructor(publicbale:FocusBit){}
exportconstLIST_FOCUS="[Listaction]ListFocus";
exportclassListFocusimplementsAction{
readonlytype=LIST_FOCUS;
constructor(publicbale:FocusBit){}
exportconstSPIN_RIGHT_FOCUS="[Listaction]SpinLeftFocus";
exportclassSpinRightFocusimplementsAction{
readonlytype=SPIN_RIGHT_FOCUS;
constructor(publicbale:FocusBit){}
exportconstSPIN_LEFT_FOCUS="[Listaction]SpinRightFocus";
exportclassSpinLeftFocusimplementsAction{
readonlytype=SPIN_LEFT_FOCUS;
constructor(publicbale:FocusBit){}
exportconstFORWARD_FOCUS="[Listaction]ForwardFocus";
exportclassForwardFocusimplementsAction{
readonlytype=FORWARD_FOCUS;
constructor(publicbale:FocusBit){}
exportconstBACKWARD_FOCUS="[Listaction]BackwardFocus";
exportclassBackwardFocusimplementsAction{
readonlytype=BACKWARD_FOCUS;
constructor(publicbale:FocusBit){}
exportconstCENTER_FOCUS="[Listaction]CenterFocus";
exportclassCenterFocusimplementsAction{
readonlytype=CENTER_FOCUS;
constructor(publicbale:FocusBit){}
exportconstBOND_FOCUS="[Bondaction]BondFocus";
exportclassBondFocusimplementsAction{
readonlytype=BOND_FOCUS;
constructor(publicbale:FocusBit){}
exportconstLOCATE_FOCUS="[Locateaction]LocateFocus";
exportclassLocateFocusimplementsAction{
readonlytype=LOCATE_FOCUS;
constructor(publicbale:FocusBit){}
exportconstVISION_FOCUS="[Visionaction]VisionFocus";
exportclassVisionFocusimplementsAction{
readonlytype=VISION_FOCUS;
constructor(publicbale:FocusBit){}
exportconstSELECT_FOCUS="[Selectaction]SelectFocus";
exportclassSelectFocusimplementsAction{
readonlytype=SELECT_FOCUS;
constructor(publicbale:FocusBit){}
exportconstMODEL_FOCUS="[Selectaction]ModelFocus";
exportclassModelFocusimplementsAction{
readonlytype=MODEL_FOCUS;
constructor(publicbale:FocusBit){}
exportconstBROWNIAN_FOCUS="[Selectaction]BrownianFocus";
exportclassBrownianFocusimplementsAction{
readonlytype=BROWNIAN_FOCUS;
constructor(publicbale:FocusBit){}
exporttypeActions=OpenFocus|InitFocus|UpdateFocus|CreateFocus
|ReadFocus
|WriteFocus
|RemoveFocus
|DeleteFocus
|CornerFocus
|ListFocus
|SpinLeftFocus
|SpinRightFocus
|BackwardFocus
|ForwardFocus
|CenterFocus
|BondFocus
|LocateFocus
|VisionFocus
|SelectFocus
|AwakeFocus
|ModelFocus
|BrownianFocus
export{initFocus}from"./buz/00.focus.buzz";
export{awakeFocus}from"./buz/awake-focus.buzz";
export{updateFocus}from"./buz/update-focus.buzz";
export{openFocus}from"./buz/00.focus.buzz";
export{createFocus}from"./buz/create-focus.buzz";
export{readFocus}from"./buz/00.focus.buzz";
export{writeFocus}from"./buz/00.focus.buzz";
export{removeFocus}from"./buz/00.focus.buzz";
export{deleteFocus}from"./buz/00.focus.buzz";
export{cornerFocus}from"./buz/corner-focus.buzz";
export{listFocus}from"./buz/00.focus.buzz";
export{spinLeftFocus}from"./buz/spin-left-focus.buzz";
export{spinRightFocus}from"./buz/spin-right-focus.buzz";
export{forwardFocus}from"./buz/forward-focus.buzz";
export{backwardFocus}from"./buz/backward-focus.buzz";
export{centerFocus}from"./buz/00.focus.buzz";
export{bondFocus}from"./buz/bond-focus.buzz";
export{locateFocus}from"./buz/00.focus.buzz";
export{visionFocus}from"./buz/vision-focus.buzz";
export{selectFocus}from"./buz/00.focus.buzz";
export{modelFocus}from"./buz/00.focus.buzz";
export{brownianFocus}from"./buz/brownian-focus.buzz";
importFocusfrom"./fce/focus.interface";
importFocusBitfrom"./fce/focus.bit";
importSpotBitfrom"./fce/spot.bit";
exportclassFocusModelimplementsFocus{
focusBitList:FocusBit[]=[];
focusBits:any={};
select:SpotBit
import*asclonefrom"clone-deep";
import*asActfrom"./focus.action";
import{FocusModel}from"./focus.model";
import*asBuzzfrom"./focus.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:FocusModel=newFocusModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.UPDATE_FOCUS:
returnBuzz.updateFocus(clone(model),act.bale,state);
caseAct.AWAKE_FOCUS:
returnBuzz.awakeFocus(clone(model),act.bale,state);
caseAct.OPEN_FOCUS:
returnBuzz.openFocus(clone(model),act.bale,state);
caseAct.CREATE_FOCUS:
returnBuzz.createFocus(clone(model),act.bale,state);
caseAct.INIT_FOCUS:
returnBuzz.initFocus(clone(model),act.bale,state);
caseAct.READ_FOCUS:
returnBuzz.readFocus(clone(model),act.bale,state);
caseAct.WRITE_FOCUS:
returnBuzz.writeFocus(clone(model),act.bale,state);
caseAct.REMOVE_FOCUS:
returnBuzz.removeFocus(clone(model),act.bale,state);
caseAct.DELETE_FOCUS:
returnBuzz.deleteFocus(clone(model),act.bale,state);
caseAct.CORNER_FOCUS:
returnBuzz.cornerFocus(clone(model),act.bale,state);
caseAct.LIST_FOCUS:
returnBuzz.listFocus(clone(model),act.bale,state);
caseAct.SPIN_LEFT_FOCUS:
returnBuzz.spinLeftFocus(clone(model),act.bale,state);
caseAct.SPIN_RIGHT_FOCUS:
returnBuzz.spinRightFocus(clone(model),act.bale,state);
caseAct.FORWARD_FOCUS:
returnBuzz.forwardFocus(clone(model),act.bale,state);
caseAct.BACKWARD_FOCUS:
returnBuzz.backwardFocus(clone(model),act.bale,state);
caseAct.CENTER_FOCUS:
returnBuzz.centerFocus(clone(model),act.bale,state);
caseAct.BOND_FOCUS:
returnBuzz.bondFocus(clone(model),act.bale,state);
caseAct.LOCATE_FOCUS:
returnBuzz.locateFocus(clone(model),act.bale,state);
caseAct.VISION_FOCUS:
returnBuzz.visionFocus(clone(model),act.bale,state);
caseAct.SELECT_FOCUS:
returnBuzz.selectFocus(clone(model),act.bale,state);
caseAct.MODEL_FOCUS:
returnBuzz.modelFocus(clone(model),act.bale,state);
caseAct.BROWNIAN_FOCUS:
returnBuzz.brownianFocus(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassFocusUnit{
constructor(state:State){
import{CameraModel}from"../camera.model";
importCameraBitfrom"../fce/camera.bit";
importStatefrom"../../99.core/state";
import*asActColfrom"../../97.collect.unit/collect.action";
import*asActCamfrom"../camera.action";
importCamBitfrom"../fce/camera.bit"
import{BabylonModel}from"../../01.babylon.unit/babylon.model";
varbit,dat;
exportconstinitCamera=(cpy:CameraModel,bal:CameraBit,ste:State)=>{
debugger
exportconstupdateCamera=async(cpy:CameraModel,bal:CameraBit,ste:State)=>{
bal.slv({mkuBit:{idx:"update-camera"}});
exportconstreadCamera=async(cpy:CameraModel,bal:CameraBit,ste:State)=>{
varslv=bal.slv;
if(bal.idx==null)bal.idx='can00';
bit=awaitste.hunt(ActCol.READ_COLLECT,{idx:bal.idx,bit:ActCam.CREATE_CAMERA})
bal.slv({mkuBit:{idx:"read-camera",dat:bit.clcBit.dat}});
exportconstwriteCamera=async(cpy:CameraModel,bal:CameraBit,ste:State)=>{
if(typeofwindow!="object")returnbal.slv({canBit:{idx:"error-write-camera",dat:{}}});
bit=awaitste.hunt(ActCol.WRITE_COLLECT,{idx:bal.idx,src:bal.src,dat:bal.dat,bit:ActCam.CREATE_CAMERA})
if(bit.clcBit.val!=0)ste.hunt(ActCam.UPDATE_CAMERA,{idx:bal.idx})
bal.slv({mkuBit:{idx:"write-camera",dat:bit.clcBit.dat}});
exportconstremoveCamera=async(cpy:CameraModel,bal:CameraBit,ste:State)=>{
bit=awaitste.hunt(ActCol.REMOVE_COLLECT,{idx:bal.idx,src:bal.src,dat:bal.dat,bit:ActCam.CREATE_CAMERA})
if(bal.slv!=null)bal.slv({vsgBit:{idx:"remove-container",dat:bit.clcBit}});
bal.slv({mkuBit:{idx:"remove-miku"}});
exportconstdeleteCamera=async(cpy:CameraModel,bal:CameraBit,ste:State)=>{
bal.slv({mkuBit:{idx:"delete-miku"}});
exportconstcreateCamera=async(cpy:CameraModel,bal:CameraBit,ste:State)=>{
if(ste.value.babylon==null){
returnalert("babylonerror")
varmodBab:BabylonModel=ste.value.babylon
if(typeofwindow!="object")returnbal.slv({canBit:{idx:"error-create-container",dat:{}}});
vardat:CamBit={
idx:bal.idx,src:bal.src,
for(varkeyinbal.dat){
dat[key]=bal.dat[key]
bal.slv({mkuBit:{idx:"create-camera",dat}});
import{Action}from"../99.core/interface/action.interface";
importCameraBitfrom"./fce/camera.bit";
exportconstINIT_CAMERA="[Cameraaction]InitCamera";
exportclassInitCameraimplementsAction{
readonlytype=INIT_CAMERA;
constructor(publicbale:CameraBit){}
exportconstUPDATE_CAMERA="[Cameraaction]UpdateCamera";
exportclassUpdateCameraimplementsAction{
readonlytype=UPDATE_CAMERA;
constructor(publicbale:CameraBit){}
exportconstREAD_CAMERA="[Readaction]ReadCamera";
exportclassReadCameraimplementsAction{
readonlytype=READ_CAMERA;
constructor(publicbale:CameraBit){}
exportconstWRITE_CAMERA="[Writeaction]WriteCamera";
exportclassWriteCameraimplementsAction{
readonlytype=WRITE_CAMERA;
constructor(publicbale:CameraBit){}
exportconstREMOVE_CAMERA="[Removeaction]RemoveCamera";
exportclassRemoveCameraimplementsAction{
readonlytype=REMOVE_CAMERA;
constructor(publicbale:CameraBit){}
exportconstDELETE_CAMERA="[Deleteaction]DeleteCamera";
exportclassDeleteCameraimplementsAction{
readonlytype=DELETE_CAMERA;
constructor(publicbale:CameraBit){}
exportconstCREATE_CAMERA="[Createaction]CreateCamera";
exportclassCreateCameraimplementsAction{
readonlytype=CREATE_CAMERA;
constructor(publicbale:CameraBit){}
exporttypeActions=|InitCamera|UpdateCamera
|ReadCamera
|WriteCamera
|RemoveCamera
|DeleteCamera
|CreateCamera
export{initCamera}from"./buz/camera.buzz";
export{updateCamera}from"./buz/camera.buzz";
export{readCamera}from"./buz/camera.buzz";
export{writeCamera}from"./buz/camera.buzz";
export{removeCamera}from"./buz/camera.buzz";
export{deleteCamera}from"./buz/camera.buzz";
export{createCamera}from"./buz/camera.buzz";
importCamerafrom"./fce/camera.interface";
importCameraBitfrom"./fce/camera.interface";
exportclassCameraModelimplementsCamera{
import*asclonefrom"clone-deep";
import*asActfrom"./camera.action";
import{CameraModel}from"./camera.model";
import*asBuzzfrom"./camera.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:CameraModel=newCameraModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.UPDATE_CAMERA:
returnBuzz.updateCamera(clone(model),act.bale,state);
caseAct.INIT_CAMERA:
returnBuzz.initCamera(clone(model),act.bale,state);
caseAct.READ_CAMERA:
returnBuzz.readCamera(clone(model),act.bale,state);
caseAct.WRITE_CAMERA:
returnBuzz.writeCamera(clone(model),act.bale,state);
caseAct.REMOVE_CAMERA:
returnBuzz.removeCamera(clone(model),act.bale,state);
caseAct.DELETE_CAMERA:
returnBuzz.deleteCamera(clone(model),act.bale,state);
caseAct.CREATE_CAMERA:
returnBuzz.createCamera(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassCameraUnit{
constructor(state:State){
exportdefaultinterfaceCameraBit{
idx:string;
exportdefaultinterfaceCameraBit{
idx:string;
src?:string;
val?:number;
dat?:any;
slv?:Function;
importCameraBitfrom"./camera.bit";
exportdefaultinterfaceCamera{
import*asActGeofrom"../geojson.action";
import*asActMapfrom"../../03.hexmap.unit/hexmap.action";
import*asActColfrom"../../97.collect.unit/collect.action";
varbit,val,idx,dex,lst,dat,src;
exportconstinitGeojson=(cpy:GeojsonModel,bal:GeojsonBit,ste:State)=>{
debugger
exportconstupdateGeojson=(cpy:GeojsonModel,bal:GeojsonBit,ste:State)=>{
exportconstloadGeojson=async(cpy:GeojsonModel,bal:GeojsonBit,ste:State)=>{
src=bal.src
if(bal.val!=null){
val=bal.val
lst=bit.dskBit.lst
varitm=lst[val]
varwant=cpy.geoSrc+'/'+itm;
dat=bit.dskBit.dat;
src=itm.split('.')[0]+'.'+itm.split('.')[1]
cpy.geojsonData=JSON.parse(dat)
dat=cpy.geojsonData
bal.slv({geoBit:{idx:"load-geojson",dat,src}});
}else{
dat=bit.dskBit.dat;
cpy.geojsonData=dat;
src=bal.src.split('.')[0]+'.'+bal.src.split('.')[1]
bal.slv({geoBit:{idx:"load-geojson",dat,src}});
exportconstindexGeojson=async(cpy:GeojsonModel,bal:GeojsonBit,ste:State)=>{
dat=null
lst=bit.dskBit.lst
if(bal.slv!=null)bal.slv({geoBit:{idx:"list-geojson",lst}});
exportconstcaptureGeojson=async(cpy:GeojsonModel,bal:GeojsonBit,ste:State)=>{
if(bal.slv!=null)bal.slv({geoBit:{idx:"capture-geojson",src:bal.src}});
exportconstsaveGeojson=async(cpy:GeojsonModel,bal:GeojsonBit,ste:State)=>{
lst=bit.dskBit.lst;
vardex=lst.length
varout=String(dex).padStart(3,'0');
varsrcDir="./data/geojson/"+out+'.'+bal.src+'.json';
varclipboardy=require("clipboardy");
vargeo;
try{
geo=clipboardy.readSync();
}catch(e){
if(bal.slv!=null)bal.slv({geoBit:{idx:"save-geojson-error"}});
return;
if(geo.includes("coordinates")==false){
if(bal.slv!=null)bal.slv({geoBit:{idx:"save-geojson-error"}});
return
if(geo.includes("type")==false){
if(bal.slv!=null)bal.slv({geoBit:{idx:"save-geojson-error"}});
return
if(bal.slv!=null)bal.slv({geoBit:{idx:"save-geojson",src:bal.src}});
import{GeojsonModel}from"../geojson.model";
importGeojsonBitfrom"../fce/geojson.bit";
importStatefrom"../../99.core/state";
exportdefaultinterfaceGeojsonBit{
idx:string;
src?:string;
val?:number;
dat?:any;
slv?:Function;
bit?:any;
importGeojsonBitfrom"./geojson.bit";
exportdefaultinterfaceGeojson{
import{Action}from"../99.core/interface/action.interface";
importGeojsonBitfrom"./fce/geojson.bit";
exportconstINIT_GEOJSON="[Geojsonaction]InitGeojson";
exportclassInitGeojsonimplementsAction{
readonlytype=INIT_GEOJSON;
constructor(publicbale:GeojsonBit){}
exportconstUPDATE_GEOJSON="[Geojsonaction]UpdateGeojson";
exportclassUpdateGeojsonimplementsAction{
readonlytype=UPDATE_GEOJSON;
constructor(publicbale:GeojsonBit){}
exportconstLOAD_GEOJSON="[Loadaction]LoadGeojson";
exportclassLoadGeojsonimplementsAction{
readonlytype=LOAD_GEOJSON;
constructor(publicbale:GeojsonBit){}
exportconstINDEX_GEOJSON="[Indexaction]IndexGeojson";
exportclassIndexGeojsonimplementsAction{
readonlytype=INDEX_GEOJSON;
constructor(publicbale:GeojsonBit){}
exportconstCAPTURE_GEOJSON="[Captureaction]CaptureGeojson";
exportclassCaptureGeojsonimplementsAction{
readonlytype=CAPTURE_GEOJSON;
constructor(publicbale:GeojsonBit){}
exportconstSAVE_GEOJSON="[Saveaction]SaveGeojson";
exportclassSaveGeojsonimplementsAction{
readonlytype=SAVE_GEOJSON;
constructor(publicbale:GeojsonBit){}
exporttypeActions=|InitGeojson|UpdateGeojson
|LoadGeojson
|IndexGeojson
|CaptureGeojson
|SaveGeojson
export{initGeojson}from"./buz/geojson.buzz";
export{updateGeojson}from"./buz/geojson.buzz";
export{loadGeojson}from"./buz/geojson.buzz";
export{indexGeojson}from"./buz/geojson.buzz";
export{captureGeojson}from"./buz/geojson.buzz";
export{saveGeojson}from"./buz/geojson.buzz";
importGeojsonfrom"./fce/geojson.interface";
importGeojsonBitfrom"./fce/geojson.interface";
exportclassGeojsonModelimplementsGeojson{
geojsonData:any;
geoSrc:string='./data/geojson'
import*asclonefrom"clone-deep";
import*asActfrom"./geojson.action";
import{GeojsonModel}from"./geojson.model";
import*asBuzzfrom"./geojson.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:GeojsonModel=newGeojsonModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.UPDATE_GEOJSON:
returnBuzz.updateGeojson(clone(model),act.bale,state);
caseAct.INIT_GEOJSON:
returnBuzz.initGeojson(clone(model),act.bale,state);
caseAct.LOAD_GEOJSON:
returnBuzz.loadGeojson(clone(model),act.bale,state);
caseAct.INDEX_GEOJSON:
returnBuzz.indexGeojson(clone(model),act.bale,state);
caseAct.CAPTURE_GEOJSON:
returnBuzz.captureGeojson(clone(model),act.bale,state);
caseAct.SAVE_GEOJSON:
returnBuzz.saveGeojson(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassGeojsonUnit{
constructor(state:State){
import{HexmapModel}from"../hexmap.model";
importHexmapBitfrom"../fce/hexmap.bit";
importStatefrom"../../99.core/state";
import*asSHAPEfrom"../../val/shape";
import*asHoneycombfrom"honeycomb-grid";
import*asHEXMAPfrom"../../val/hexmap";
import*asSfrom'string'
importMapBitfrom"../fce/map.bit";
import*asSPACEfrom'../../val/space'
importSpotBitfrom"../../01.focus.unit/fce/spot.bit";
import*asActMapfrom"../hexmap.action";
import*asActFocfrom"../../01.focus.unit/focus.action";
import*asActSpcfrom"../../00.space.unit/space.action";
import*asActColfrom"../../97.collect.unit/collect.action";
import*asActVrtfrom"../../act/vurt.action";
varbit,idx,lst,dat,val,src;
exportconstinitHexmap=(cpy:HexmapModel,bal:HexmapBit,ste:State)=>{
varlst=[ActMap.OPEN_HEXMAP];
bal.slv({intBit:{idx:"init-focus",lst}});
exportconstupdateHexmap=(cpy:HexmapModel,bal:HexmapBit,ste:State)=>{
exportconstfocusingHexmap=async(cpy:HexmapModel,bal:HexmapBit,ste:State)=>{
bit=awaitste.hunt(ActMap.READ_HEXMAP,{idx:bal.idx})
varhexmap:MapBit=bit.mapBit.dat;
bit=awaitste.hunt(ActFoc.READ_FOCUS,{idx:bal.src})
varfocus:SpotBit=bit.focBit.dat;
bit=awaitste.hunt(ActFoc.WRITE_FOCUS,{idx:focus.idx,dat:{map:hexmap.idx}})
varfocus:SpotBit=bit.focBit.dat;
if(bal.slv!=null)bal.slv({mapBit:{idx:"focusing-hexmap",dat:{idx:hexmap.idx,src:focus.idx,dat:focus}}});
exportconstdefocusHexmap=(cpy:HexmapModel,bal:HexmapBit,ste:State)=>{
debugger
exportconstopenHexmap=async(cpy:HexmapModel,bal:HexmapBit,ste:State)=>{
if(bal.idx.includes('.')==false)bal.idx=bal.src;
bit=awaitfetch(url,{method:'GET',headers:{'head':'none'}})
dat=awaitbit.json()
bit=awaitste.hunt(ActMap.ADD_HEXMAP,{idx:bal.idx,dat:{dat,gph:'gph00'}})
if(bal.slv!=null)bal.slv({mapBit:{idx:"open-hexmap",dat}});
exportconstaddHexmap=async(cpy:HexmapModel,bal:HexmapBit,ste:State)=>{
if(bal.idx==null)bal.idx='hex000'
dat={frm:'geojson',bit:bal.dat.dat,gph:bal.dat.gph}
bit=awaitste.hunt(ActMap.WRITE_HEXMAP,{idx:bal.idx,dat})
if(bal.slv!=null)bal.slv({mapBit:{idx:"add-hexmap",dat:bit.mapBit.dat}});
exportconstwriteHexmap=async(cpy:HexmapModel,bal:HexmapBit,ste:State)=>{
if(bal.val!=null)bal.dat.val=bal.val
bit=awaitste.hunt(ActCol.WRITE_COLLECT,{idx:bal.idx,dat:bal.dat,bit:ActMap.CREATE_HEXMAP})
if(bal.slv!=null)bal.slv({mapBit:{idx:"write-hexmap",dat:bit.clcBit.dat}});
exportconstreadHexmap=async(cpy:HexmapModel,bal:HexmapBit,ste:State)=>{
varslv=bal.slv;
if(bal.idx==null)bal.idx='map00';
bit=awaitste.hunt(ActCol.READ_COLLECT,{idx:bal.idx,bit:ActMap.CREATE_HEXMAP})
if(slv!=null)slv({mapBit:{idx:"read-hexmap",dat:bit.clcBit.dat}});
exportconstcopyHexmap=async(cpy:HexmapModel,bal:HexmapBit,ste:State)=>{
vargeojson=false;
exportconstgeojsonHexmap=async(cpy:HexmapModel,bal:HexmapBit,ste:State)=>{
debugger
if(bal.slv!=null)bal.slv({mapBit:{idx:"geojson-hexmap",dat:cpy.geoJsonNow}});
exportconsttoolHexmap=async(cpy:HexmapModel,bal:HexmapBit,ste:State)=>{
if(geojson==true){
if(bal.slv!=null)bal.slv({mapBit:{idx:"tool-hexmap"}});
return
geojson=true;
varChance=require("chance");
varfate=newChance();
varnow=fate.pickone(link);
if(bal.slv!=null)bal.slv({mapBit:{idx:"tool-hexmap",src:now}});
exportconststoreHexmap=async(cpy:HexmapModel,bal:HexmapBit,ste:State)=>{
bit=awaitste.hunt(ActMap.ADD_HEXMAP,{idx:bal.idx,dat:{gph:bal.src,dat:bal.dat}});
if(bal.slv!=null)bal.slv({mapBit:{idx:"store-hexmap",dat:bal.dat}});
exportconstlistHexmap=async(cpy:HexmapModel,bal:HexmapBit,ste:State)=>{
dat=null
bit=awaitste.hunt(ActCol.FETCH_COLLECT,{val:0,bit:ActMap.CREATE_HEXMAP})
if(bit.clcBit.dat==null)lst=[]
elsedat=bit.clcBit.dat;
if(dat!=null){
lst=[]
dat.bitList.forEach((a)=>{
lst.push((a.idx))
if(bal.slv!=null)bal.slv({mapBit:{idx:"list-hexmap",lst}});
exportconstnameHexmap=(cpy:HexmapModel,bal:HexmapBit,ste:State)=>{
cpy.mapNomNow=bal.idx;
if(bal.slv!=null)bal.slv({mapBit:{idx:"name-hexmap",dat:cpy.atlasNow}});
exportconstreplaceHexmap=(cpy:HexmapModel,bal:HexmapBit,ste:State)=>{
cpy.atlasNow=bal.dat;
cpy.sizeNow=cpy.atlasNow.length;
if(bal.slv!=null)bal.slv({mapBit:{idx:"replace-hexmap",dat:cpy.atlasNow}});
exportconstseekHexmap=(cpy:HexmapModel,bal:HexmapBit,ste:State)=>{
debugger
exportconstselectHexmap=async(cpy:HexmapModel,bal:HexmapBit,ste:State)=>{
bit=awaitste.hunt(ActMap.READ_HEXMAP,{idx:bal.idx})
varhexmap:MapBit=bit.mapBit.dat;
cpy.select=hexmap;
if(bal.slv!=null)bal.slv({mapBit:{idx:"select-hexmap",dat:cpy.select}});
import*asActMapfrom"../hexmap.action";
import*asActFocfrom"../../01.focus.unit/focus.action";
import*asActSpcfrom"../../00.space.unit/space.action";
import*asActColfrom"../../97.collect.unit/collect.action";
import*asActDskfrom"../../act/disk.action";
import*asActVrtfrom"../../act/vurt.action";
varbit,idx,lst,dat,val,src;
exportconstatlasHexmap=async(cpy:HexmapModel,bal:HexmapBit,ste:State)=>{
vardetailList=bal.lst
if(detailList==null)detailList=['black',"white"]
if(bal.idx==null)bal.idx='map00'
if(bal.val==null)bal.val=10;
varh3=require("h3-js");
varclone=require("clone-deep");
varFate=require('chance');
varfate=newFate();
varh3ToGeo=h3.h3ToGeo;
varhexRing=h3.hexRing;
varpolyfill=h3.polyfill;
varname=bal.idx;
varscale=bal.val;
vardata=bal.dat;
varhex=[];
varmap=[];
varcords=data.coordinates;
if(cords==null){
if(data.features!=null){
cords=data.features[0].geometry.coordinates;
vartrim=(val)=>{
vardat=0;
switch(val){
case1:
dat=0;
break;
case2:
dat=0;
break;
case3:
dat=0;
break;
case4:
dat=1;
break;
case5:
dat=1;
break;
case6:
dat=5;
break;
case7:
dat=5;
break;
case8:
dat=5;
break;
case9:
dat=5;
break;
case10:
dat=5;
break;
case11:
dat=6;
break;
case12:
dat=6;
break;
case13:
dat=6;
break;
case14:
dat=6;
break;
default:
dat=6;
returndat;
hex=polyfill(cords,scale,true);
if(hex.length==0){
if(bal.slv!=null)bal.slv({mapBit:{idx:"no-atlas-hexmap"}});
return
varmsg="SCALE:"+scale+"SIZE:"+hex.length;
varleft=null;
varright=null;
vartop=null;
varbottom=null;
varwidth=0;
varheight=0;
varedge={};
hex.forEach((a,b)=>{
varcenter=h3ToGeo(a);
vart=trim(scale);
varxDex=Math.abs(Number(center[1].toFixed(t)));
varyDex=Math.abs(Number(center[0].toFixed(t)));
center[1]=xDex=Math.ceil(xDex*Math.pow(10,t));
center[0]=yDex=Math.ceil(yDex*Math.pow(10,t));
if(right==null)right=xDex;
elseif(xDex<right)right=xDex;
if(left==null)left=xDex;
elseif(xDex>left)left=xDex;
if(top==null)top=yDex;
elseif(yDex>top)top=yDex;
if(bottom==null)bottom=yDex;
elseif(yDex<bottom)bottom=yDex;
varsaveData={hex:a,center:center,color:null};
edge[a]=saveData;
map.push(saveData);
map.forEach((a,b)=>{
varcenter=a.center;
center[1]=left-center[1];
center[0]=top-center[0];
map[b].center=center;
vargrid0=[];
map.forEach((a)=>{
varx=a.center[1];
vary=a.center[0];
grid0.push({hex:a.hex,x:x,y:y});
grid0.sort(function(a,b){
returna.y-b.y;
grid0.forEach((a,b)=>{
grid0[b]={hex:a.hex,x:a.x,y:b};
grid0.sort(function(a,b){
returna.x-b.x;
varmaxX=0;
varmaxY=0;
grid0.forEach((a,b)=>{
grid0[b]={hex:a.hex,x:b,y:a.y};
edge[a.h]=grid0[b];
if(grid0[b].x>maxX)maxX=grid0[b].x;
if(grid0[b].y>maxY)maxY=grid0[b].y;
varconnect={};
grid0.forEach((a,b)=>{
varhex=a.hex;
varring0=hexRing(hex,1);
ring0.forEach((c,d)=>{
ring0[d]={dex:d,hex:c,x:a.x,y:a.y};
varring1=[];
ring0.forEach((c)=>{
if(edge[c.hex]==null)return;
c.x=edge[c.hex].x;
c.y=edge[c.hex].y;
ring1.push(c);
varid=hex;
connect[id]=ring1;
varcubeList=[];
varcube={};
varnow={q:0,r:0,s:0};
varcubeCount=hex.length;
varcubeCheck=(hex,q,r,s)=>{
varlst=connect[hex];
lst.forEach((a)=>{
varnext={hex:a.hex,q:q,r:r,s:s,lst:[]};
if(detailList.length>0){
next.lst.push(fate.pickone(detailList))
next.lst.push(fate.pickone(detailList))
next.lst.push(fate.pickone(detailList))
next.lst
switch(a.dex){
case0:
next.q+=1;
next.r-=1;
next.s+=0;
break;
case1:
next.q+=0;
next.r-=1;
next.s+=1;
break;
case2:
next.q-=1;
next.r+=0;
next.s+=1;
break;
case3:
next.q-=1;
next.r+=1;
next.s+=0;
break;
case4:
next.q+=0;
next.r+=1;
next.s-=1;
break;
case5:
next.q+=1;
next.r+=0;
next.s-=1;
break;
if(cube[a.hex]!=null)return;
cube[a.hex]=next;
cubeCount-=1;
process.nextTick(()=>cubeCheck(a.hex,next.q,next.r,next.s));
varopen=grid0[0];
if(open==null)return;
varvalue={hex:open.hex,q:0,r:0,s:0};
cube[open.hex]=value;
cubeCheck(open.hex,0,0,0);
varendCheck=async()=>{
if(cubeCount>1)returnprocess.nextTick(endCheck);
for(varkeyincube)cubeList.push(cube[key]);
varendMap={};
map.forEach((a)=>{
endMap[a.hex]=a;
vardat={
name:data.name,
nom:data.nom,
type:data.territory,
ambit:data.territory,
lot:"lot",
slot:"slot",
space:data.nom,
flavor:"",
scale:scale,
size:hex.length,
width:maxX,
height:maxY,
left:0,
right:0,
top:0,
bottom:0,
map:endMap,
cube:cubeList,
grid:null,
constHex=Honeycomb.extendHex({
orientation:"flat",
constGrid=Honeycomb.defineGrid(Hex);
varcopied=clone(dat);
copied.cube.forEach((a,b)=>{
consthexPrototype={size:1,hex:"value"};
varHex=Honeycomb.extendHex(hexPrototype);
copied.cube[b]=Hex().cubeToCartesian({q:a.q,r:a.r,s:a.s});
copied.cube[b].hex=a.hex;
varlesserX=0;
varlesserY=0;
varmightyX=0;
varmightyY=0;
copied.cube.forEach((a)=>{
if(a.x<lesserX)lesserX=a.x;
if(a.x>mightyX)mightyX=a.x;
if(a.y<lesserY)lesserY=a.y;
if(a.y>mightyY)mightyY=a.y;
dat.left=lesserX;
dat.right=mightyX;
dat.top=lesserY;
dat.bottom=mightyY;
constgrid=Grid(copied.cube);
varhY=grid.pointHeight();
varwX=grid.pointWidth();
dat.width=grid.pointWidth();
dat.height=grid.pointHeight();
dat.grid=grid;
cpy.atlasNow=dat;
if(bal.slv!=null)bal.slv({mapBit:{idx:"atlas-hexmap",dat}});
process.nextTick(endCheck);
import{HexmapModel}from"../hexmap.model";
importHexmapBitfrom"../fce/hexmap.bit";
importStatefrom"../../99.core/state";
import*asSHAPEfrom"../../val/shape";
import*asHoneycombfrom"honeycomb-grid";
import*asHEXMAPfrom"../../val/hexmap";
import*asSfrom'string'
importMapBitfrom"../fce/map.bit";
import*asSPACEfrom'../../val/space'
importSpotBitfrom"../../01.focus.unit/fce/spot.bit";
import{HexmapModel}from"../hexmap.model";
importHexmapBitfrom"../fce/hexmap.bit";
importStatefrom"../../99.core/state";
import*asSHAPEfrom"../../val/shape";
import*asHoneycombfrom"honeycomb-grid";
import*asHEXMAPfrom"../../val/hexmap";
import*asSfrom'string'
importMapBitfrom"../fce/map.bit";
import*asSPACEfrom'../../val/space'
importSpotBitfrom"../../01.focus.unit/fce/spot.bit";
import*asActMapfrom"../hexmap.action";
import*asActFocfrom"../../01.focus.unit/focus.action";
import*asActSpcfrom"../../00.space.unit/space.action";
import*asActColfrom"../../97.collect.unit/collect.action";
import*asActDskfrom"../../act/disk.action";
import*asActVrtfrom"../../act/vurt.action";
varbit,idx,lst,dat,val,src;
exportconstcreateHexmap=async(cpy:HexmapModel,bal:HexmapBit,ste:State)=>{
if(bal.dat.bit!=null){
bal.slv({mapBit:{idx:"create-hexmap",dat:bal.dat.bit}});
return
varclone=require("clone-deep");
vardat:MapBit={idx:bal.idx,typ:HEXMAP.AMBT,val:bal.dat.val,ver:'00.00'}
for(varkeyinbal.dat){
dat[key]=bal.dat[key]
constHex=Honeycomb.extendHex({
orientation:"flat",
constGrid=Honeycomb.defineGrid(Hex);
dat.bit
if(dat.bit==null)bal.slv({mapBit:{idx:"create-hexmap-error",src:"nobitpresent"}});
dat.bit.grid
varcopied=clone(dat.bit.grid);
dat.grid=Grid(copied);
varsize=dat.grid.length
if(dat.bit==null){
if(bal.slv!=null)bal.slv({mapBit:{idx:"create-hexmap-error",src:"nobitpresent"}});
return
bal.slv({mapBit:{idx:"create-hexmap",dat}});
import{HexmapModel}from"../hexmap.model";
importHexmapBitfrom"../fce/hexmap.bit";
importStatefrom"../../99.core/state";
import*asActMapfrom"../hexmap.action";
import*asActDskfrom"../../act/disk.action";
letbit;
exportconstloadHexmap=async(cpy:HexmapModel,bal:HexmapBit,ste:State)=>{
bit=awaitste.hunt(ActDsk.READ_DISK,{src:bal.src})
varmapBit=JSON.parse(bit.dskBit.dat)
bit=awaitste.hunt(ActMap.WRITE_HEXMAP,{idx:bal.idx,dat:{bit:mapBit}})
debugger
bal.slv({mapBit:{idx:"load-hexmap",dat:{}}});
import{HexmapModel}from"../hexmap.model";
importHexmapBitfrom"../fce/hexmap.bit";
importStatefrom"../../99.core/state";
import*asSHAPEfrom"../../val/shape";
import*asHoneycombfrom"honeycomb-grid";
import*asHEXMAPfrom"../../val/hexmap";
import*asSfrom'string'
importMapBitfrom"../fce/map.bit";
import*asSPACEfrom'../../val/space'
importSpotBitfrom"../../01.focus.unit/fce/spot.bit";
import*asActMapfrom"../hexmap.action";
import*asActFocfrom"../../01.focus.unit/focus.action";
import*asActSpcfrom"../../00.space.unit/space.action";
import*asActColfrom"../../97.collect.unit/collect.action";
import*asActDskfrom"../../act/disk.action";
import*asActVrtfrom"../../act/vurt.action";
varbit,idx,lst,dat,val,src;
exportconstpouchHexmap=async(cpy:HexmapModel,bal:HexmapBit,ste:State)=>{
vardir='./data/mapbit';
dat={}
bit=awaitste.hunt(ActDsk.INDEX_DISK,{src:dir})
lst=bit.dskBit.lst
varout=[]
lst.forEach((a)=>{
varme=a.split('.')
me.pop()
idx=me.join('')
vardata={idx,src:dir+'/'+a}
out.push(data)
bit=awaitste.hunt(ActDsk.WRITE_DISK,{idx:'./data/mapbit.json',dat:JSON.stringify(out)})
bal.slv({mapBit:{idx:"pouch-hexmap",lst:out}});
import{HexmapModel}from"../hexmap.model";
importHexmapBitfrom"../fce/hexmap.bit";
importStatefrom"../../99.core/state";
import*asSHAPEfrom"../../val/shape";
import*asHoneycombfrom"honeycomb-grid";
import*asHEXMAPfrom"../../val/hexmap";
import*asSfrom'string'
importMapBitfrom"../fce/map.bit";
import*asSPACEfrom'../../val/space'
importSpotBitfrom"../../01.focus.unit/fce/spot.bit";
import*asActMapfrom"../hexmap.action";
import*asActFocfrom"../../01.focus.unit/focus.action";
import*asActSpcfrom"../../00.space.unit/space.action";
import*asActColfrom"../../97.collect.unit/collect.action";
import*asActDskfrom"../../act/disk.action";
import*asActVrtfrom"../../act/vurt.action";
varbit,idx,lst,dat,val,src;
exportconstsaveHexmap=async(cpy:HexmapModel,bal:HexmapBit,ste:State)=>{
bit=awaitste.hunt(ActMap.READ_HEXMAP,{idx:bal.idx});
dat=bit.mapBit.dat;
dat.idx=S(dat.idx).slugify().s
if(bal.val==null)bal.val=10
val=String(bal.val).padStart(5,'0');
bit=awaitste.bus(ActDsk.ENSURE_DISK,{src:cpy.hexmapLoc})
src=cpy.hexmapLoc+bal.idx+'.'+val+'.json';
bit=awaitste.bus(ActDsk.WRITE_DISK,{idx:null,src,dat,val:1})
bal.slv({mapBit:{idx:"save-hexmap",src,dat}});
import{HexmapModel}from"../hexmap.model";
importHexmapBitfrom"../fce/hexmap.bit";
importStatefrom"../../99.core/state";
import*asSHAPEfrom"../../val/shape";
import*asHoneycombfrom"honeycomb-grid";
import*asHEXMAPfrom"../../val/hexmap";
import*asSfrom'string'
importMapBitfrom"../fce/map.bit";
import*asSPACEfrom'../../val/space'
importSpotBitfrom"../../01.focus.unit/fce/spot.bit";
import*asActMapfrom"../hexmap.action";
import*asActFocfrom"../../01.focus.unit/focus.action";
import*asActSpcfrom"../../00.space.unit/space.action";
import*asActColfrom"../../97.collect.unit/collect.action";
import*asActDskfrom"../../act/disk.action";
import*asActVrtfrom"../../act/vurt.action";
varbit,idx,lst,dat,val,src;
exportconstshapeHexmap=async(cpy:HexmapModel,bal:HexmapBit,ste:State)=>{
vardat:MapBit=bal.dat
if(dat==null)returnbal.slv({mapBit:{idx:"shape-hexmap-error"}});
if(dat.frm==null)dat.frm=SHAPE.RECTANGLE;
if(dat.w==null)dat.w=3;
if(dat.h==null)dat.h=3;
constHex:Honeycomb.HexFactory=Honeycomb.extendHex({
constGrid:Honeycomb.GridFactory<any>=Honeycomb.defineGrid(Hex);
vargrid;
switch(dat.frm){
caseSHAPE.RECTANGLE:
grid=Grid.rectangle({width:dat.w,height:dat.h});
break;
caseSHAPE.TRIANGLE:
grid=Grid.triangle({size:dat.w});
break;
caseSHAPE.HEXAGON:
grid=Grid.hexagon({radius:dat.w,center:[dat.w,dat.w]});
break;
caseSHAPE.PARALLELOGRAM:
grid=Grid.parallelogram({width:dat.w,height:dat.h});
break;
varChance=require('chance');
varchance=newChance();
grid.forEach((a)=>{
a.hex=chance.bb_pin()
dat.bit=grid
varshape={frm:dat.frm,bit:dat.bit,w:dat.w,h:dat.h}
if(bal.slv!=null)bal.slv({mapBit:{idx:"shape-hexmap",dat:{idx:bal.idx,dat:shape}}});
exportdefaultinterfaceHexmapBit{
idx:string;
src:string;
frm:string;
val:number;
slv?:any;
dex?:number;
sze?:number;
typ:string;
size?:number;
orient?:string;
h?:number;
w?:number;
dat?:any;
lst?:any;
importHexmapBitfrom"./hexmap.bit";
exportdefaultinterfaceHexmap{
import*asHoneycombfrom"honeycomb-grid";
exportdefaultinterfaceHoneycombCollection{
hexFactoryList:Honeycomb.HexFactory[];
hexFactories:any;
gridFactoryList:Honeycomb.GridFactory<any>[];
gridFactories:any;
gridList:any[];
grids:any;
hexList:Honeycomb.Hex<any>[];
hexs:any;
exportdefaultinterfaceMapBit{
idx:string;
src?:string;
typ?:string;
frm?:string;
dex?:number;
sze?:number;
size?:number;
orient?:string;
h?:number;
w?:number;
dat?:any
bit?:any;
grid?:any;
ver?:any;
val:number
exportdefaultinterfaceVergeBit{
idx:string;
src?:string;
slv?:any;
dex?:number;
sze?:number;
typ:string;
size?:number;
orient?:string;
h?:number;
w?:number;
import{Action}from"../99.core/interface/action.interface";
importHexmapBitfrom"./fce/hexmap.bit";
exportconstINIT_HEXMAP="[Hexmapaction]InitHexmap";
exportclassInitHexmapimplementsAction{
readonlytype=INIT_HEXMAP;
constructor(publicbale:HexmapBit){}
exportconstUPDATE_HEXMAP="[Hexmapaction]UpdateHexmap";
exportclassUpdateHexmapimplementsAction{
readonlytype=UPDATE_HEXMAP;
constructor(publicbale:HexmapBit){}
exportconstOPEN_HEXMAP="[Hexmapaction]OpenHexmap";
exportclassOpenHexmapimplementsAction{
readonlytype=OPEN_HEXMAP;
constructor(publicbale:HexmapBit){}
exportconstREAD_HEXMAP="[Readaction]ReadHexmap";
exportclassReadHexmapimplementsAction{
readonlytype=READ_HEXMAP;
constructor(publicbale:HexmapBit){}
exportconstWRITE_HEXMAP="[Writeaction]WriteHexmap";
exportclassWriteHexmapimplementsAction{
readonlytype=WRITE_HEXMAP;
constructor(publicbale:HexmapBit){}
exportconstCREATE_HEXMAP="[Createaction]CreateHexmap";
exportclassCreateHexmapimplementsAction{
readonlytype=CREATE_HEXMAP;
constructor(publicbale:HexmapBit){}
exportconstCOPY_HEXMAP="[Copyaction]CopyHexmap";
exportclassCopyHexmapimplementsAction{
readonlytype=COPY_HEXMAP;
constructor(publicbale:HexmapBit){}
exportconstATLAS_HEXMAP="[Atlasaction]AtlasHexmap";
exportclassAtlasHexmapimplementsAction{
readonlytype=ATLAS_HEXMAP;
constructor(publicbale:HexmapBit){}
exportconstGEOJSON_HEXMAP="[Geojsonaction]GeojsonHexmap";
exportclassGeojsonHexmapimplementsAction{
readonlytype=GEOJSON_HEXMAP;
constructor(publicbale:HexmapBit){}
exportconstTOOL_HEXMAP="[Toolaction]ToolHexmap";
exportclassToolHexmapimplementsAction{
readonlytype=TOOL_HEXMAP;
constructor(publicbale:HexmapBit){}
exportconstSAVE_HEXMAP="[Saveaction]SaveHexmap";
exportclassSaveHexmapimplementsAction{
readonlytype=SAVE_HEXMAP;
constructor(publicbale:HexmapBit){}
exportconstSTORE_HEXMAP="[Storeaction]StoreHexmap";
exportclassStoreHexmapimplementsAction{
readonlytype=STORE_HEXMAP;
constructor(publicbale:HexmapBit){}
exportconstSHAPE_HEXMAP="[Shapeaction]ShapeHexmap";
exportclassShapeHexmapimplementsAction{
readonlytype=SHAPE_HEXMAP;
constructor(publicbale:HexmapBit){}
exportconstLOAD_HEXMAP="[Loadaction]LoadHexmap";
exportclassLoadHexmapimplementsAction{
readonlytype=LOAD_HEXMAP;
constructor(publicbale:HexmapBit){}
exportconstLIST_HEXMAP="[Listaction]ListHexmap";
exportclassListHexmapimplementsAction{
readonlytype=LIST_HEXMAP;
constructor(publicbale:HexmapBit){}
exportconstREPLACE_HEXMAP="[Replaceaction]ReplaceHexmap";
exportclassReplaceHexmapimplementsAction{
readonlytype=REPLACE_HEXMAP;
constructor(publicbale:HexmapBit){}
exportconstNAME_HEXMAP="[Nameaction]NameHexmap";
exportclassNameHexmapimplementsAction{
readonlytype=NAME_HEXMAP;
constructor(publicbale:HexmapBit){}
exportconstSEEK_HEXMAP="[Seekaction]SeekHexmap";
exportclassSeekHexmapimplementsAction{
readonlytype=SEEK_HEXMAP;
constructor(publicbale:HexmapBit){}
exportconstFOCUSING_HEXMAP="[Focusingaction]FocusingHexmap";
exportclassFocusingHexmapimplementsAction{
readonlytype=FOCUSING_HEXMAP;
constructor(publicbale:HexmapBit){}
exportconstDEFOCUS_HEXMAP="[Defocusaction]DefocusHexmap";
exportclassDefocusHexmapimplementsAction{
readonlytype=DEFOCUS_HEXMAP;
constructor(publicbale:HexmapBit){}
exportconstSELECT_HEXMAP="[Selectaction]SelectHexmap";
exportclassSelectHexmapimplementsAction{
readonlytype=SELECT_HEXMAP;
constructor(publicbale:HexmapBit){}
exportconstADD_HEXMAP="[Selectaction]AddHexmap";
exportclassAddHexmapimplementsAction{
readonlytype=ADD_HEXMAP;
constructor(publicbale:HexmapBit){}
exportconstPOUCH_HEXMAP="[Selectaction]PouchHexmap";
exportclassPouchHexmapimplementsAction{
readonlytype=POUCH_HEXMAP;
constructor(publicbale:HexmapBit){}
exporttypeActions=OpenHexmap|InitHexmap|UpdateHexmap
|ReadHexmap
|WriteHexmap
|CreateHexmap
|CopyHexmap
|AtlasHexmap
|GeojsonHexmap
|ToolHexmap
|SaveHexmap
|StoreHexmap
|ShapeHexmap
|ShapeHexmap
|LoadHexmap
|ListHexmap
|ReplaceHexmap
|NameHexmap
|SeekHexmap
|FocusingHexmap
|DefocusHexmap
|SelectHexmap
|AddHexmap
|PouchHexmap
export{initHexmap}from"./buz/00.hexmap.buzz";
export{updateHexmap}from"./buz/00.hexmap.buzz";
export{openHexmap}from"./buz/00.hexmap.buzz";
export{readHexmap}from"./buz/00.hexmap.buzz";
export{writeHexmap}from"./buz/00.hexmap.buzz";
export{createHexmap}from"./buz/create-hexmap";
export{copyHexmap}from"./buz/00.hexmap.buzz";
export{atlasHexmap}from"./buz/atlas-hexmap.buzz";
export{geojsonHexmap}from"./buz/00.hexmap.buzz";
export{toolHexmap}from"./buz/00.hexmap.buzz";
export{saveHexmap}from"./buz/save-hexmap";
export{storeHexmap}from"./buz/00.hexmap.buzz";
export{shapeHexmap}from"./buz/shape-hexmap";
export{loadHexmap}from"./buz/load-hexmap";
export{listHexmap}from"./buz/00.hexmap.buzz";
export{replaceHexmap}from"./buz/00.hexmap.buzz";
export{nameHexmap}from"./buz/00.hexmap.buzz";
export{seekHexmap}from"./buz/00.hexmap.buzz";
export{focusingHexmap}from"./buz/00.hexmap.buzz";
export{defocusHexmap}from"./buz/00.hexmap.buzz";
export{selectHexmap}from"./buz/00.hexmap.buzz";
export{addHexmap}from"./buz/00.hexmap.buzz";
export{pouchHexmap}from"./buz/pouch-hexmap";
importHexmapfrom"./fce/hexmap.interface";
importHexmapBitfrom"./fce/hexmap.bit";
importHoneycombCollectionfrom"./fce/honeycomb-collection.bit";
importSpotBitfrom"../01.focus.unit/fce/spot.bit";
importMapBitfrom"./fce/map.bit";
exportclassHexmapModelimplementsHexmap{
select:MapBit;
geoJsonNow:any;
atlasNow:any;
sizeNow:any=0;
mapNomNow:string='none'
platBits:any={};
hexmapLoc:string='./data/mapbit/';
hexmapBitList:HexmapBit[]=[];
hexmapBits:any={};
hc:HoneycombCollection={
hexFactoryList:[],
hexFactories:{},
gridFactoryList:[],
gridFactories:{},
gridList:[],
grids:{},
hexList:[],
hexs:{},
dex:number=0;
count:number=0;
import*asclonefrom"clone-deep";
import*asActfrom"./hexmap.action";
import{HexmapModel}from"./hexmap.model";
import*asBuzzfrom"./hexmap.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:HexmapModel=newHexmapModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.OPEN_HEXMAP:
returnBuzz.openHexmap(clone(model),act.bale,state);
caseAct.UPDATE_HEXMAP:
returnBuzz.updateHexmap(clone(model),act.bale,state);
caseAct.INIT_HEXMAP:
returnBuzz.initHexmap(clone(model),act.bale,state);
caseAct.READ_HEXMAP:
returnBuzz.readHexmap(clone(model),act.bale,state);
caseAct.WRITE_HEXMAP:
returnBuzz.writeHexmap(clone(model),act.bale,state);
caseAct.CREATE_HEXMAP:
returnBuzz.createHexmap(clone(model),act.bale,state);
caseAct.COPY_HEXMAP:
returnBuzz.copyHexmap(clone(model),act.bale,state);
caseAct.ATLAS_HEXMAP:
returnBuzz.atlasHexmap(clone(model),act.bale,state);
caseAct.GEOJSON_HEXMAP:
returnBuzz.geojsonHexmap(clone(model),act.bale,state);
caseAct.TOOL_HEXMAP:
returnBuzz.toolHexmap(clone(model),act.bale,state);
caseAct.SAVE_HEXMAP:
returnBuzz.saveHexmap(clone(model),act.bale,state);
caseAct.STORE_HEXMAP:
returnBuzz.storeHexmap(clone(model),act.bale,state);
caseAct.SHAPE_HEXMAP:
returnBuzz.shapeHexmap(clone(model),act.bale,state);
caseAct.LOAD_HEXMAP:
returnBuzz.loadHexmap(clone(model),act.bale,state);
caseAct.LIST_HEXMAP:
returnBuzz.listHexmap(clone(model),act.bale,state);
caseAct.REPLACE_HEXMAP:
returnBuzz.replaceHexmap(clone(model),act.bale,state);
caseAct.NAME_HEXMAP:
returnBuzz.nameHexmap(clone(model),act.bale,state);
caseAct.SEEK_HEXMAP:
returnBuzz.seekHexmap(clone(model),act.bale,state);
caseAct.FOCUSING_HEXMAP:
returnBuzz.focusingHexmap(clone(model),act.bale,state);
caseAct.DEFOCUS_HEXMAP:
returnBuzz.defocusHexmap(clone(model),act.bale,state);
caseAct.SELECT_HEXMAP:
returnBuzz.selectHexmap(clone(model),act.bale,state);
caseAct.ADD_HEXMAP:
returnBuzz.addHexmap(clone(model),act.bale,state);
caseAct.POUCH_HEXMAP:
returnBuzz.pouchHexmap(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassHexmapUnit{
constructor(state:State){
import{LightModel}from"../light.model";
importLightBitfrom"../fce/light.bit";
importStatefrom"../../99.core/state";
import*asActColfrom"../../97.collect.unit/collect.action";
import*asActLgtfrom"../light.action";
importLgtBitfrom"../fce/light.bit"
import{BabylonModel}from"../../01.babylon.unit/babylon.model";
importLitBitfrom"../fce/lit.bit";
varbit,dat;
exportconstinitLight=(cpy:LightModel,bal:LightBit,ste:State)=>{
debugger
exportconstupdateLight=async(cpy:LightModel,bal:LightBit,ste:State)=>{
bit=awaitste.hunt(ActLgt.READ_LIGHT,{idx:bal.idx})
dat=bit.lgtBit.dat
bal.slv({lgtBit:{idx:"update-light"}});
exportconstreadLight=async(cpy:LightModel,bal:LightBit,ste:State)=>{
varslv=bal.slv;
if(bal.idx==null)bal.idx='lgt00';
bit=awaitste.hunt(ActCol.READ_COLLECT,{idx:bal.idx,bit:ActLgt.CREATE_LIGHT})
bal.slv({mkuBit:{idx:"read-light",dat:bit.clcBit.dat}});
exportconstwriteLight=async(cpy:LightModel,bal:LightBit,ste:State)=>{
if(typeofwindow!="object")returnbal.slv({canBit:{idx:"error-write-light",dat:{}}});
bit=awaitste.hunt(ActCol.WRITE_COLLECT,{idx:bal.idx,src:bal.src,dat:bal.dat,bit:ActLgt.CREATE_LIGHT})
if(bit.clcBit.val!=0)ste.hunt(ActLgt.UPDATE_LIGHT,{idx:bal.idx})
bal.slv({mkuBit:{idx:"write-light",dat:bit.clcBit.dat}});
exportconstremoveLight=async(cpy:LightModel,bal:LightBit,ste:State)=>{
bit=awaitste.hunt(ActCol.REMOVE_COLLECT,{idx:bal.idx,src:bal.src,dat:bal.dat,bit:ActLgt.DELETE_LIGHT})
if(bal.slv!=null)bal.slv({vsgBit:{idx:"remove-light",dat:bit.clcBit}});
bal.slv({mkuBit:{idx:"remove-light"}});
exportconstdeleteLight=(cpy:LightModel,bal:LightBit,ste:State)=>{
debugger
exportconstcreateLight=async(cpy:LightModel,bal:LightBit,ste:State)=>{
if(ste.value.babylon==null){
returnalert("babylonerror")
varmodBab:BabylonModel=ste.value.babylon
if(typeofwindow!="object")returnbal.slv({canBit:{idx:"error-create-light",dat:{}}});
vardat:LitBit={idx:bal.idx}
for(varkeyinbal.dat){
dat[key]=bal.dat[key]
bal.slv({mkuBit:{idx:"create-light",dat}});
exportdefaultinterfaceLightBit{
idx:string;
src?:string;
val?:number;
dat?:any;
slv?:Function;
importLightBitfrom"./light.bit";
exportdefaultinterfaceLight{
exportdefaultinterfaceLitBit{
idx:string;
import{Action}from"../99.core/interface/action.interface";
importLightBitfrom"./fce/light.bit";
exportconstINIT_LIGHT="[Lightaction]InitLight";
exportclassInitLightimplementsAction{
readonlytype=INIT_LIGHT;
constructor(publicbale:LightBit){}
exportconstUPDATE_LIGHT="[Lightaction]UpdateLight";
exportclassUpdateLightimplementsAction{
readonlytype=UPDATE_LIGHT;
constructor(publicbale:LightBit){}
exportconstREAD_LIGHT="[Readaction]ReadLight";
exportclassReadLightimplementsAction{
readonlytype=READ_LIGHT;
constructor(publicbale:LightBit){}
exportconstWRITE_LIGHT="[Writeaction]WriteLight";
exportclassWriteLightimplementsAction{
readonlytype=WRITE_LIGHT;
constructor(publicbale:LightBit){}
exportconstREMOVE_LIGHT="[Removeaction]RemoveLight";
exportclassRemoveLightimplementsAction{
readonlytype=REMOVE_LIGHT;
constructor(publicbale:LightBit){}
exportconstDELETE_LIGHT="[Deleteaction]DeleteLight";
exportclassDeleteLightimplementsAction{
readonlytype=DELETE_LIGHT;
constructor(publicbale:LightBit){}
exportconstCREATE_LIGHT="[Createaction]CreateLight";
exportclassCreateLightimplementsAction{
readonlytype=CREATE_LIGHT;
constructor(publicbale:LightBit){}
exporttypeActions=|InitLight|UpdateLight
|ReadLight
|WriteLight
|RemoveLight
|DeleteLight
|CreateLight
export{initLight}from"./buz/light.buzz";
export{updateLight}from"./buz/light.buzz";
export{readLight}from"./buz/light.buzz";
export{writeLight}from"./buz/light.buzz";
export{removeLight}from"./buz/light.buzz";
export{deleteLight}from"./buz/light.buzz";
export{createLight}from"./buz/light.buzz";
importLightfrom"./fce/light.interface";
importLightBitfrom"./fce/light.interface";
exportclassLightModelimplementsLight{
import*asclonefrom"clone-deep";
import*asActfrom"./light.action";
import{LightModel}from"./light.model";
import*asBuzzfrom"./light.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:LightModel=newLightModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.UPDATE_LIGHT:
returnBuzz.updateLight(clone(model),act.bale,state);
caseAct.INIT_LIGHT:
returnBuzz.initLight(clone(model),act.bale,state);
caseAct.READ_LIGHT:
returnBuzz.readLight(clone(model),act.bale,state);
caseAct.WRITE_LIGHT:
returnBuzz.writeLight(clone(model),act.bale,state);
caseAct.REMOVE_LIGHT:
returnBuzz.removeLight(clone(model),act.bale,state);
caseAct.DELETE_LIGHT:
returnBuzz.deleteLight(clone(model),act.bale,state);
caseAct.CREATE_LIGHT:
returnBuzz.createLight(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassLightUnit{
constructor(state:State){
import{PrimativeModel}from"../primative.model";
importPrimativeBitfrom"../fce/primative.bit";
importStatefrom"../../99.core/state";
import*asActColfrom"../../97.collect.unit/collect.action";
import*asActPrmfrom"../primative.action";
importPrimBitfrom"../fce/prim.bit";
varbit;
exportconstinitPrimative=(cpy:PrimativeModel,bal:PrimativeBit,ste:State)=>{
debugger
exportconstupdatePrimative=(cpy:PrimativeModel,bal:PrimativeBit,ste:State)=>{
exportconstreadPrimative=async(cpy:PrimativeModel,bal:PrimativeBit,ste:State)=>{
if(bal.idx==null)bal.idx='can00';
bit=awaitste.hunt(ActCol.READ_COLLECT,{idx:bal.idx,bit:ActPrm.CREATE_PRIMATIVE})
bal.slv({prmBit:{idx:"read-primative",dat:bit.clcBit.dat}});
exportconstwritePrimative=async(cpy:PrimativeModel,bal:PrimativeBit,ste:State)=>{
bit=awaitste.hunt(ActCol.WRITE_COLLECT,{idx:bal.idx,src:bal.src,dat:bal.dat,bit:ActPrm.CREATE_PRIMATIVE})
if(bit.clcBit.val!=0)ste.hunt(ActPrm.UPDATE_PRIMATIVE,{idx:bal.idx})
bal.slv({prmBit:{idx:"write-primvative",dat:bit.clcBit.dat}});
exportconstremovePrimative=async(cpy:PrimativeModel,bal:PrimativeBit,ste:State)=>{
bit=awaitste.hunt(ActCol.REMOVE_COLLECT,{idx:bal.idx,src:bal.src,dat:bal.dat,bit:ActPrm.REMOVE_PRIMATIVE})
if(bal.slv!=null)bal.slv({vsgBit:{idx:"remove-screen",dat:bit.clcBit}});
bal.slv({prmBit:{idx:"remove-primative"}});
exportconstdeletePrimative=(cpy:PrimativeModel,bal:PrimativeBit,ste:State)=>{
debugger
exportconstcreatePrimative=(cpy:PrimativeModel,bal:PrimativeBit,ste:State)=>{
vardat:PrimBit={
idx:bal.idx,src:bal.src,
bit:null
for(varkeyinbal.dat){
dat[key]=bal.dat[key]
bal.slv({prmBit:{idx:"create-primative",dat}});
exportdefaultinterfacePrimBit{
idx:string;
src?:string;
bit?:any;
exportdefaultinterfacePrimativeBit{
idx:string;
src?:string;
val?:number;
dat?:any;
slv?:Function;
importPrimativeBitfrom"./primative.bit";
exportdefaultinterfacePrimative{
import{Action}from"../99.core/interface/action.interface";
importPrimativeBitfrom"./fce/primative.bit";
exportconstINIT_PRIMATIVE="[Primativeaction]InitPrimative";
exportclassInitPrimativeimplementsAction{
readonlytype=INIT_PRIMATIVE;
constructor(publicbale:PrimativeBit){}
exportconstUPDATE_PRIMATIVE="[Primativeaction]UpdatePrimative";
exportclassUpdatePrimativeimplementsAction{
readonlytype=UPDATE_PRIMATIVE;
constructor(publicbale:PrimativeBit){}
exportconstREAD_PRIMATIVE="[Readaction]ReadPrimative";
exportclassReadPrimativeimplementsAction{
readonlytype=READ_PRIMATIVE;
constructor(publicbale:PrimativeBit){}
exportconstWRITE_PRIMATIVE="[Writeaction]WritePrimative";
exportclassWritePrimativeimplementsAction{
readonlytype=WRITE_PRIMATIVE;
constructor(publicbale:PrimativeBit){}
exportconstREMOVE_PRIMATIVE="[Removeaction]RemovePrimative";
exportclassRemovePrimativeimplementsAction{
readonlytype=REMOVE_PRIMATIVE;
constructor(publicbale:PrimativeBit){}
exportconstDELETE_PRIMATIVE="[Deleteaction]DeletePrimative";
exportclassDeletePrimativeimplementsAction{
readonlytype=DELETE_PRIMATIVE;
constructor(publicbale:PrimativeBit){}
exportconstCREATE_PRIMATIVE="[Createaction]CreatePrimative";
exportclassCreatePrimativeimplementsAction{
readonlytype=CREATE_PRIMATIVE;
constructor(publicbale:PrimativeBit){}
exporttypeActions=|InitPrimative|UpdatePrimative
|ReadPrimative
|WritePrimative
|RemovePrimative
|DeletePrimative
|CreatePrimative
export{initPrimative}from"./buz/primative.buzz";
export{updatePrimative}from"./buz/primative.buzz";
export{readPrimative}from"./buz/primative.buzz";
export{writePrimative}from"./buz/primative.buzz";
export{removePrimative}from"./buz/primative.buzz";
export{deletePrimative}from"./buz/primative.buzz";
export{createPrimative}from"./buz/primative.buzz";
importPrimativefrom"./fce/primative.interface";
importPrimativeBitfrom"./fce/primative.interface";
exportclassPrimativeModelimplementsPrimative{
import*asclonefrom"clone-deep";
import*asActfrom"./primative.action";
import{PrimativeModel}from"./primative.model";
import*asBuzzfrom"./primative.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:PrimativeModel=newPrimativeModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.UPDATE_PRIMATIVE:
returnBuzz.updatePrimative(clone(model),act.bale,state);
caseAct.INIT_PRIMATIVE:
returnBuzz.initPrimative(clone(model),act.bale,state);
caseAct.READ_PRIMATIVE:
returnBuzz.readPrimative(clone(model),act.bale,state);
caseAct.WRITE_PRIMATIVE:
returnBuzz.writePrimative(clone(model),act.bale,state);
caseAct.REMOVE_PRIMATIVE:
returnBuzz.removePrimative(clone(model),act.bale,state);
caseAct.DELETE_PRIMATIVE:
returnBuzz.deletePrimative(clone(model),act.bale,state);
caseAct.CREATE_PRIMATIVE:
returnBuzz.createPrimative(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassPrimativeUnit{
constructor(state:State){
import{ScreenModel}from"../screen.model";
importScreenBitfrom"../fce/screen.bit";
importStatefrom"../../99.core/state";
import*asActColfrom"../../97.collect.unit/collect.action";
import*asActScrfrom"../screen.action";
importSeeBitfrom"../fce/see.bit";
import{BabylonModel}from"../../01.babylon.unit/babylon.model";
varbit
exportconstinitScreen=(cpy:ScreenModel,bal:ScreenBit,ste:State)=>{
debugger
exportconstupdateScreen=(cpy:ScreenModel,bal:ScreenBit,ste:State)=>{
exportconstreadScreen=async(cpy:ScreenModel,bal:ScreenBit,ste:State)=>{
if(bal.idx==null)bal.idx='can00';
bit=awaitste.hunt(ActCol.READ_COLLECT,{idx:bal.idx,bit:ActScr.CREATE_SCREEN})
bal.slv({scrBit:{idx:"read-screen",dat:bit.clcBit.dat}});
exportconstwriteScreen=async(cpy:ScreenModel,bal:ScreenBit,ste:State)=>{
bit=awaitste.hunt(ActCol.WRITE_COLLECT,{idx:bal.idx,src:bal.src,dat:bal.dat,bit:ActScr.CREATE_SCREEN})
if(bit.clcBit.val!=0)ste.hunt(ActScr.UPDATE_SCREEN,{idx:bal.idx})
bal.slv({srcBit:{idx:"write-screen",dat:bit.clcBit.dat}});
exportconstremoveScreen=async(cpy:ScreenModel,bal:ScreenBit,ste:State)=>{
bit=awaitste.hunt(ActCol.REMOVE_COLLECT,{idx:bal.idx,src:bal.src,dat:bal.dat,bit:ActScr.REMOVE_SCREEN})
if(bal.slv!=null)bal.slv({vsgBit:{idx:"remove-screen",dat:bit.clcBit}});
bal.slv({mkuBit:{idx:"remove-screen"}});
exportconstdeleteScreen=(cpy:ScreenModel,bal:ScreenBit,ste:State)=>{
debugger
exportconstcreateScreen=async(cpy:ScreenModel,bal:ScreenBit,ste:State)=>{
vardat:SeeBit={
idx:bal.idx,src:bal.src,
bit:null
for(varkeyinbal.dat){
dat[key]=bal.dat[key]
if(ste.value.babylon==null){
returnalert("babylonerror")
varmodBab:BabylonModel=ste.value.babylon
if(typeofwindow!="object")returnbal.slv({canBit:{idx:"error-create-container",dat:{}}});
varscene=modBab.scene;
if(scene==null){
bal.slv({scrBit:{idx:"create-screen-err",dat:{bit:null}}});
return
constapp=bit.fceBit.dat.bit
awaitapp.init({background:'#ff00ff',resizeTo:window});
conststageSize=newBABYLON.Vector2(1280,720)
constout=BABYLON.MeshBuilder.CreateGround('out',{width:1,height:1},scene)
constbaseOutScale=stageSize.clone().scale(0.05)
out.scaling.set(baseOutScale.x,1,baseOutScale.y)
out.rotation.x=-Math.PI*0.5
constoutMat=newBABYLON.StandardMaterial('outMat',scene)
out.material=outMat
out.isVisible=true
out.position.z=130;
out.position.y=10;
out.position.x=-10;
constpixiDt=newBABYLON.DynamicTexture('pixi-extract',{width:stageSize.x,height:stageSize.y},scene,false)
constpCtx=pixiDt.getContext()
outMat.emissiveTexture=pixiDt
outMat.diffuseTexture=pixiDt
outMat.opacityTexture=pixiDt
pixiDt.hasAlpha=true
outMat.disableLighting=true
scene.onBeforeRenderObservable.add(()=>{
pCtx.clearRect(0,0,app.canvas.width,app.canvas.height)
pCtx.drawImage(app.canvas,0,0)
pixiDt.update()
scene.onAfterRenderObservable.add(()=>{
app.renderer.clear()
dat.bit=out
bal.slv({scrBit:{idx:"create-screen",dat}});
exportdefaultinterfaceScreenBit{
idx:string;
src?:string;
val?:number;
dat?:any;
slv?:Function;
importScreenBitfrom"./screen.bit";
exportdefaultinterfaceScreen{
exportdefaultinterfaceSeeBit{
idx:string;
src?:string;
bit?:any;
import{Action}from"../99.core/interface/action.interface";
importScreenBitfrom"./fce/screen.bit";
exportconstINIT_SCREEN="[Screenaction]InitScreen";
exportclassInitScreenimplementsAction{
readonlytype=INIT_SCREEN;
constructor(publicbale:ScreenBit){}
exportconstUPDATE_SCREEN="[Screenaction]UpdateScreen";
exportclassUpdateScreenimplementsAction{
readonlytype=UPDATE_SCREEN;
constructor(publicbale:ScreenBit){}
exportconstREAD_SCREEN="[Readaction]ReadScreen";
exportclassReadScreenimplementsAction{
readonlytype=READ_SCREEN;
constructor(publicbale:ScreenBit){}
exportconstWRITE_SCREEN="[Writeaction]WriteScreen";
exportclassWriteScreenimplementsAction{
readonlytype=WRITE_SCREEN;
constructor(publicbale:ScreenBit){}
exportconstREMOVE_SCREEN="[Removeaction]RemoveScreen";
exportclassRemoveScreenimplementsAction{
readonlytype=REMOVE_SCREEN;
constructor(publicbale:ScreenBit){}
exportconstDELETE_SCREEN="[Deleteaction]DeleteScreen";
exportclassDeleteScreenimplementsAction{
readonlytype=DELETE_SCREEN;
constructor(publicbale:ScreenBit){}
exportconstCREATE_SCREEN="[Createaction]CreateScreen";
exportclassCreateScreenimplementsAction{
readonlytype=CREATE_SCREEN;
constructor(publicbale:ScreenBit){}
exporttypeActions=|InitScreen|UpdateScreen
|ReadScreen
|WriteScreen
|RemoveScreen
|DeleteScreen
|CreateScreen
export{initScreen}from"./buz/screen.buzz";
export{updateScreen}from"./buz/screen.buzz";
export{readScreen}from"./buz/screen.buzz";
export{writeScreen}from"./buz/screen.buzz";
export{removeScreen}from"./buz/screen.buzz";
export{deleteScreen}from"./buz/screen.buzz";
export{createScreen}from"./buz/screen.buzz";
importScreenfrom"./fce/screen.interface";
importScreenBitfrom"./fce/screen.interface";
exportclassScreenModelimplementsScreen{
import*asclonefrom"clone-deep";
import*asActfrom"./screen.action";
import{ScreenModel}from"./screen.model";
import*asBuzzfrom"./screen.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:ScreenModel=newScreenModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.UPDATE_SCREEN:
returnBuzz.updateScreen(clone(model),act.bale,state);
caseAct.INIT_SCREEN:
returnBuzz.initScreen(clone(model),act.bale,state);
caseAct.READ_SCREEN:
returnBuzz.readScreen(clone(model),act.bale,state);
caseAct.WRITE_SCREEN:
returnBuzz.writeScreen(clone(model),act.bale,state);
caseAct.REMOVE_SCREEN:
returnBuzz.removeScreen(clone(model),act.bale,state);
caseAct.DELETE_SCREEN:
returnBuzz.deleteScreen(clone(model),act.bale,state);
caseAct.CREATE_SCREEN:
returnBuzz.createScreen(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassScreenUnit{
constructor(state:State){
import{GlopModel}from"../glop.model";
importGlopBitfrom"../fce/glop.bit";
importStatefrom"../../99.core/state";
import*asActColfrom"../../97.collect.unit/collect.action";
import*asActGlpfrom"../glop.action";
importGlpBitfrom"../fce/glp.bit";
import{BabylonModel}from"../../01.babylon.unit/babylon.model";
varbit,dat;
exportconstinitGlop=(cpy:GlopModel,bal:GlopBit,ste:State)=>{
debugger
exportconstupdateGlop=async(cpy:GlopModel,bal:GlopBit,ste:State)=>{
bit=awaitste.hunt(ActGlp.READ_GLOP,{idx:bal.idx})
dat=bit.mkuBit.dat
bal.slv({mkuBit:{idx:"update-miku"}});
exportconstreadGlop=async(cpy:GlopModel,bal:GlopBit,ste:State)=>{
varslv=bal.slv;
if(bal.idx==null)bal.idx='can00';
bit=awaitste.hunt(ActCol.READ_COLLECT,{idx:bal.idx,bit:ActGlp.CREATE_GLOP})
bal.slv({glpBit:{idx:"read-glop",dat:bit.clcBit.dat}});
exportconstwriteGlop=async(cpy:GlopModel,bal:GlopBit,ste:State)=>{
if(typeofwindow!="object")returnbal.slv({canBit:{idx:"error-write-miku",dat:{}}});
bit=awaitste.hunt(ActCol.WRITE_COLLECT,{idx:bal.idx,src:bal.src,dat:bal.dat,bit:ActGlp.CREATE_GLOP})
if(bit.clcBit.val!=0)ste.hunt(ActGlp.UPDATE_GLOP,{idx:bal.idx})
bal.slv({glpBit:{idx:"write-glop",dat:bit.clcBit.dat}});
exportconstdeleteGlop=async(cpy:GlopModel,bal:GlopBit,ste:State)=>{
bit=awaitste.hunt(ActCol.REMOVE_COLLECT,{idx:bal.idx,src:bal.src,dat:bal.dat,bit:ActGlp.CREATE_GLOP})
bal.slv({glpBit:{idx:"remove-miku"}});
exportconstcreateGlop=async(cpy:GlopModel,bal:GlopBit,ste:State)=>{
vardat:GlpBit={idx:bal.idx,src:''}
for(varkeyinbal.dat){
dat[key]=bal.dat[key]
varmodBab:BabylonModel=ste.value.babylon
constmesh=awaitBABYLON.SceneLoader.ImportMeshAsync(undefined,'./hexTile.glb',undefined,modBab.scene).then((result)=>result.meshes[0]);
debugger
modBab.scene.stopAllAnimations();
bal.slv({mkuBit:{idx:"create-miku",dat}});
exportconstremoveGlop=(cpy:GlopModel,bal:GlopBit,ste:State)=>{
debugger
exportdefaultinterfaceGlopBit{
idx:string;
src?:string;
val?:number;
dat?:any;
slv?:Function;
importGlopBitfrom"./glop.bit";
exportdefaultinterfaceGlop{
exportdefaultinterfaceGlpBit{
idx:string;
src:string;
import{Action}from"../99.core/interface/action.interface";
importGlopBitfrom"./fce/glop.bit";
exportconstINIT_GLOP="[Glopaction]InitGlop";
exportclassInitGlopimplementsAction{
readonlytype=INIT_GLOP;
constructor(publicbale:GlopBit){}
exportconstUPDATE_GLOP="[Glopaction]UpdateGlop";
exportclassUpdateGlopimplementsAction{
readonlytype=UPDATE_GLOP;
constructor(publicbale:GlopBit){}
exportconstREAD_GLOP="[Readaction]ReadGlop";
exportclassReadGlopimplementsAction{
readonlytype=READ_GLOP;
constructor(publicbale:GlopBit){}
exportconstWRITE_GLOP="[Writeaction]WriteGlop";
exportclassWriteGlopimplementsAction{
readonlytype=WRITE_GLOP;
constructor(publicbale:GlopBit){}
exportconstDELETE_GLOP="[Deleteaction]DeleteGlop";
exportclassDeleteGlopimplementsAction{
readonlytype=DELETE_GLOP;
constructor(publicbale:GlopBit){}
exportconstCREATE_GLOP="[Createaction]CreateGlop";
exportclassCreateGlopimplementsAction{
readonlytype=CREATE_GLOP;
constructor(publicbale:GlopBit){}
exportconstREMOVE_GLOP="[Removeaction]RemoveGlop";
exportclassRemoveGlopimplementsAction{
readonlytype=REMOVE_GLOP;
constructor(publicbale:GlopBit){}
exporttypeActions=|InitGlop|UpdateGlop
|ReadGlop
|WriteGlop
|DeleteGlop
|CreateGlop
|RemoveGlop
export{initGlop}from"./buz/glop.buzz";
export{updateGlop}from"./buz/glop.buzz";
export{readGlop}from"./buz/glop.buzz";
export{writeGlop}from"./buz/glop.buzz";
export{deleteGlop}from"./buz/glop.buzz";
export{createGlop}from"./buz/glop.buzz";
export{removeGlop}from"./buz/glop.buzz";
importGlopfrom"./fce/glop.interface";
importGlopBitfrom"./fce/glop.interface";
exportclassGlopModelimplementsGlop{
import*asclonefrom"clone-deep";
import*asActfrom"./glop.action";
import{GlopModel}from"./glop.model";
import*asBuzzfrom"./glop.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:GlopModel=newGlopModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.UPDATE_GLOP:
returnBuzz.updateGlop(clone(model),act.bale,state);
caseAct.INIT_GLOP:
returnBuzz.initGlop(clone(model),act.bale,state);
caseAct.READ_GLOP:
returnBuzz.readGlop(clone(model),act.bale,state);
caseAct.WRITE_GLOP:
returnBuzz.writeGlop(clone(model),act.bale,state);
caseAct.DELETE_GLOP:
returnBuzz.deleteGlop(clone(model),act.bale,state);
caseAct.CREATE_GLOP:
returnBuzz.createGlop(clone(model),act.bale,state);
caseAct.REMOVE_GLOP:
returnBuzz.removeGlop(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassGlopUnit{
constructor(state:State){
import{MikuModel}from"../miku.model";
importMikuBitfrom"../fce/miku.bit";
importStatefrom"../../99.core/state";
import*asActColfrom"../../97.collect.unit/collect.action";
import*asActMkufrom"../miku.action";
importMmdBitfrom"../fce/mmd.bit"
import{BabylonModel}from"../../01.babylon.unit/babylon.model";
varbit,dat;
exportconstinitMiku=async(cpy:MikuModel,bal:MikuBit,ste:State)=>{
debugger
exportconstupdateMiku=async(cpy:MikuModel,bal:MikuBit,ste:State)=>{
bit=awaitste.hunt(ActMku.READ_MIKU,{idx:bal.idx})
dat=bit.mkuBit.dat
dat.bit.position=newBABYLON.Vector3(dat.position.x,dat.position.y,dat.position.z);
bal.slv({mkuBit:{idx:"update-miku"}});
exportconstreadMiku=async(cpy:MikuModel,bal:MikuBit,ste:State)=>{
if(bal.idx==null)bal.idx='can00';
bit=awaitste.hunt(ActCol.READ_COLLECT,{idx:bal.idx,bit:ActMku.CREATE_MIKU})
bal.slv({mkuBit:{idx:"read-miku",dat:bit.clcBit.dat}});
exportconstwriteMiku=async(cpy:MikuModel,bal:MikuBit,ste:State)=>{
if(typeofwindow!="object")returnbal.slv({canBit:{idx:"error-write-miku",dat:{}}});
bit=awaitste.hunt(ActCol.WRITE_COLLECT,{idx:bal.idx,src:bal.src,dat:bal.dat,bit:ActMku.CREATE_MIKU})
if(bit.clcBit.val!=0)ste.hunt(ActMku.UPDATE_MIKU,{idx:bal.idx})
bal.slv({mkuBit:{idx:"write-miku",dat:bit.clcBit.dat}});
exportconstremoveMiku=async(cpy:MikuModel,bal:MikuBit,ste:State)=>{
bit=awaitste.hunt(ActCol.REMOVE_COLLECT,{idx:bal.idx,src:bal.src,dat:bal.dat,bit:ActMku.DELETE_MIKU})
if(bal.slv!=null)bal.slv({vsgBit:{idx:"remove-container",dat:bit.clcBit}});
bal.slv({mkuBit:{idx:"remove-miku"}});
exportconstdeleteMiku=async(cpy:MikuModel,bal:MikuBit,ste:State)=>{
bal.slv({mkuBit:{idx:"delete-miku"}});
exportconstcreateMiku=async(cpy:MikuModel,bal:MikuBit,ste:State)=>{
if(ste.value.babylon==null){
returnalert("babylonerror")
varmodBab:BabylonModel=ste.value.babylon
if(typeofwindow!="object")returnbal.slv({canBit:{idx:"error-create-container",dat:{}}});
vardat:MmdBit={
idx:bal.idx,src:bal.src,
postition:{x:0,y:0,z:0},
scale:{x:0,y:0,z:0},
rotation:{x:0,y:0,z:0},
bit:null
for(varkeyinbal.dat){
dat[key]=bal.dat[key]
constmmdMesh=awaitBABYLON.SceneLoader.ImportMeshAsync(undefined,bal.src,undefined,modBab.scene).then((result)=>result.meshes[0]);
constmodelMesh=mmdMeshasBABYLON.Mesh
constmmdModel=modBab.mmdRuntime.createMmdModel(modelMesh);
mmdModel.addAnimation(modBab.motion);
mmdModel.setAnimation("motion");
modBab.mmdRuntime.playAnimation();
dat.bit=modelMesh
bal.slv({mkuBit:{idx:"create-miku",dat}});
exportdefaultinterfaceMikuBit{
idx:string;
src?:string;
val?:number;
dat?:any;
slv?:Function;
importMikuBitfrom"./miku.bit";
exportdefaultinterfaceMiku{
importVBitfrom"./v.bit";
exportdefaultinterfaceMmdBit{
idx:string;
src:string;
postition:VBit;
scale:VBit;
rotation:VBit;
bit:any;
exportdefaultinterfaceVBit{
x:number;
y:number;
z:number;
import{Action}from"../99.core/interface/action.interface";
importMikuBitfrom"./fce/miku.bit";
exportconstINIT_MIKU="[Mikuaction]InitMiku";
exportclassInitMikuimplementsAction{
readonlytype=INIT_MIKU;
constructor(publicbale:MikuBit){}
exportconstUPDATE_MIKU="[Mikuaction]UpdateMiku";
exportclassUpdateMikuimplementsAction{
readonlytype=UPDATE_MIKU;
constructor(publicbale:MikuBit){}
exportconstREAD_MIKU="[Mikuaction]ReadMiku";
exportclassReadMikuimplementsAction{
readonlytype=READ_MIKU;
constructor(publicbale:MikuBit){}
exportconstWRITE_MIKU="[Mikuaction]WriteMiku";
exportclassWriteMikuimplementsAction{
readonlytype=WRITE_MIKU;
constructor(publicbale:MikuBit){}
exportconstDELETE_MIKU="[Mikuaction]DeleteMiku";
exportclassDeleteMikuimplementsAction{
readonlytype=DELETE_MIKU;
constructor(publicbale:MikuBit){}
exportconstREMOVE_MIKU="[Mikuaction]RemoveMiku";
exportclassRemoveMikuimplementsAction{
readonlytype=REMOVE_MIKU;
constructor(publicbale:MikuBit){}
exportconstCREATE_MIKU="[Mikuaction]CreateMiku";
exportclassCreateMikuimplementsAction{
readonlytype=CREATE_MIKU;
constructor(publicbale:MikuBit){}
exporttypeActions=|InitMiku|UpdateMiku|ReadMiku|WriteMiku|DeleteMiku|RemoveMiku|CreateMiku;
export{initMiku}from"./buz/miku.buzz";
export{updateMiku}from"./buz/miku.buzz";
export{readMiku}from"./buz/miku.buzz";
export{writeMiku}from"./buz/miku.buzz";
export{removeMiku}from"./buz/miku.buzz";
export{deleteMiku}from"./buz/miku.buzz";
export{createMiku}from"./buz/miku.buzz";
importMikufrom"./fce/miku.interface";
importMikuBitfrom"./fce/miku.interface";
exportclassMikuModelimplementsMiku{
import*asActfrom"./miku.action";
import{MikuModel}from"./miku.model";
import*asBuzzfrom"./miku.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:MikuModel=newMikuModel(),act:Act.Actions,state?:State){
varclone=require('clone-deep');
switch(act.type){
caseAct.UPDATE_MIKU:
returnBuzz.updateMiku(clone(model),act.bale,state);
caseAct.INIT_MIKU:
returnBuzz.initMiku(clone(model),act.bale,state);
caseAct.READ_MIKU:
returnBuzz.readMiku(clone(model),act.bale,state);
caseAct.WRITE_MIKU:
returnBuzz.writeMiku(clone(model),act.bale,state);
caseAct.REMOVE_MIKU:
returnBuzz.removeMiku(clone(model),act.bale,state);
caseAct.DELETE_MIKU:
returnBuzz.deleteMiku(clone(model),act.bale,state);
caseAct.CREATE_MIKU:
returnBuzz.createMiku(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassMikuUnit{
constructor(state:State){
import*asActColfrom'../../97.collect.unit/collect.action';
varbit,lst,dat,idx,val,src,dex;
exportconstinitCollect=(cpy:CollectModel,bal:CollectBit,ste:State)=>{
exportconstupdateCollect=(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
exportconstfetchCollect=(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
if(bal.val==null)bal.val=1;
if(bal.bit==null)
bal.slv({clcBit:{idx:'fetch-collect-err',src:'no-bit'}});
vartype=bal.bit.split('').slice(-1).pop().toLowerCase();
varcabBit:CaboodleBit=cpy.caboodleBitList[cpy.caboodleBits[type]];
if(bal.val==1)bit=cabBit.bitList[0];
elsebit=cabBit;
if(bal.slv!=null)bal.slv({clcBit:{idx:'fetch-collect',dat:bit}});
exportconstreadCollect=async(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
if(bal.bit==null)
bal.slv({clcBit:{idx:'read-collect-err',src:'no-bit'}});
vartype=bal.bit.split('').slice(-1).pop().toLowerCase();
if(cpy.caboodleBits[type]==null)createCollect(cpy,{idx:type},ste);
varcabBit:CaboodleBit=cpy.caboodleBitList[cpy.caboodleBits[type]];
if(cabBit.bits[bal.idx]==null){
bit=awaitste.hunt(ActCol.WRITE_COLLECT,{
idx:bal.idx,
src:bal.src,
bit:bal.bit,
}else{
dat=cabBit.bitList[cabBit.bits[bal.idx]];
if(bal.slv!=null)bal.slv({clcBit:{idx:'read-collect',dat}});
exportconstwriteCollect=async(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
dat=null;
vartype=bal.bit.split('').slice(-1).pop().toLowerCase();
if(cpy.caboodleBits[type]==null)createCollect(cpy,{idx:type},ste);
if(bal.bit==null)
bal.slv({rskBit:{idx:'write-collect-err',src:'no-bit'}});
varcabBit:CaboodleBit=cpy.caboodleBitList[cpy.caboodleBits[type]];
bal.idx;
val=0;
if(cabBit.bits[bal.idx]==null){
bit=awaitste.hunt(bal.bit,{idx:bal.idx,src:bal.src,dat:bal.dat});
varobjDat=bit[Object.keys(bit)[0]];
dat=objDat.dat;
if(dat==null)dat={};
dat.dex=cabBit.bitList.length;
cabBit.bitList.push(dat);
varidx=bal.idx;
if(idx==null)idx=dat.idx;
if(idx==null)thrownewError('writecollecthasnoidx');
cabBit.bits[idx]=dat.dex;
}else{
varcabDat=cabBit.bitList[cabBit.bits[bal.idx]];
bal.dat;
val=1;
for(varkeyinbal.dat){
if(cabDat==null)cabDat={};
cabDat[key]=bal.dat[key];
cabBit.bitList[cabBit.bits[bal.idx]]=cabDat;
dat=cabDat;
if(dat==null&&bal.slv!=null)
bal.slv({rskBit:{idx:'write-collect-err',src:'no-dat'}});
if(bal.slv!=null)bal.slv({clcBit:{idx:'write-collect',val,dat}});
exportconstcreateCollect=(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
varcabBit:CaboodleBit={idx:bal.idx,dex:0,bits:{},bitList:[]};
cabBit.dex=cpy.caboodleBitList.length;
cpy.caboodleBitList.push(cabBit);
cpy.caboodleBits[cabBit.idx]=cabBit.dex;
if(bal.slv!=null)
bal.slv({clcBit:{idx:'create-collect',dat:cabBit}});
exportconstremoveCollect=async(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
vartype=bal.bit.split('').slice(-1).pop().toLowerCase();
if(cpy.caboodleBits[type]==null)
returnbal.slv({rskBit:{idx:'remove-collect-not-present'}});
varcabBit:CaboodleBit=cpy.caboodleBitList[cpy.caboodleBits[type]];
if(cabBit.bits[bal.idx]==null)
returnbal.slv({rskBit:{idx:'remove-collect-idx-not-present'}});
bit=awaitste.hunt(bal.bit,{idx:bal.idx,src:bal.src,dat:bal.dat});
varobjDat=bit[Object.keys(bit)[0]];
dat=objDat.dat;
dex=dat.dex;
for(vari=dex;i<cabBit.bitList.length-1;i++){
varupdate=cabBit.bitList[i];
update.dex-=1;
for(varkeyindat){
dat[key]=null;
deletecabBit.bits[bal.idx];
varitm=cabBit.bitList.splice(dex,1);
cabBit.dex-=1;
if(bal.slv!=null)
bal.slv({clcBit:{idx:'remove-collect',dat:itm[0]}});
exportconstputCollect=(cpy:CollectModel,bal:CollectBit,ste:State)=>{
cpy.caboodleBits[bal.idx]=bal.val;
cpy.caboodleBitList[bal.val]=bal.dat;
if(bal.slv!=null)
bal.slv({clcBit:{idx:'put-collect',dat:bal.dat}});
exportconstgetCollect=(cpy:CollectModel,bal:CollectBit,ste:State)=>{
val=cpy.caboodleBits[bal.idx];
dat=cpy.caboodleBitList[val];
if(bal.slv!=null)bal.slv({clcBit:{idx:'get-collect',val,dat}});
exportconstmodelCollect=(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
if(bal.slv!=null)bal.slv({clcBit:{idx:'model-collect',dat:cpy}});
exportconstdeleteCollect=(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
exportconstemptyCollect=(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
exportconstdotCollect=(cpy:CollectModel,bal:CollectBit,ste:State)=>{
vargel=bal.dat;
varout=[];
bal.src.split('\n').forEach((a,b)=>{
vardoTCompiled=doT.template(a);
varoutLine=doTCompiled(gel);
out.push(outLine);
if(bal.slv!=null)
bal.slv({clcBit:{idx:'dot-vurt',lst:out,src:out.join('\n')}});
exportconstformatCollect=(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
lst=bal.src.split(':');
varidx=lst[0];
varout=[];
idx=S(idx).collapseWhitespace().s;
varopt=lst[1].split(',');
opt.forEach((a,b)=>{
varnow=S(a).collapseWhitespace().s;
if(a.length<1)return;
out.push(now);
dat=[idx,out];
bal.slv({clcBit:{idx:'format-collect',dat}});
exportconstlistCollect=(cpy:CollectModel,bal:CollectBit,ste:State)=>{
vartype=bal.bit.split('').slice(-1).pop().toLowerCase();
if(cpy.caboodleBits[type]==null)createCollect(cpy,{idx:type},ste);
varcabBit:CaboodleBit=cpy.caboodleBitList[cpy.caboodleBits[type]];
lst=[];
cabBit.bitList.forEach((a)=>{
if(a.idx!=null)lst.push(a.idx);
if(a.id!=null)lst.push(a.id);
bal.slv({clcBit:{idx:'list-collect',lst}});
exportconsthashCollect=(cpy:CollectModel,bal:CollectBit,ste:State)=>{
if(bal.src==null)bal.src='';
lst=bal.src.split('\n');
dat={};
lst.forEach((a)=>{
a=S(a).collapseWhitespace().s;
if(a.length<3)return;
varhold=a.split(':');
vardom=hold[0];
varsub=hold[1];
varnow=sub.split(',');
now.forEach((b,c)=>{
now[c]=S(b).collapseWhitespace().s;
dat[dom]=now;
bal.slv({clcBit:{idx:'hash-collect',dat}});
import{CollectModel}from'../collect.model';
importCollectBitfrom'../fce/collect.bit';
importStatefrom'../../99.core/state';
importCaboodleBitfrom'../fce/caboodle.bit';
import*asSfrom'string';
import*asdoTfrom'dot';
import{Action}from"../99.core/interface/action.interface";
importCollectBitfrom"./fce/collect.bit";
exportconstINIT_COLLECT="[Collectaction]InitCollect";
exportclassInitCollectimplementsAction{
readonlytype=INIT_COLLECT;
constructor(publicbale:CollectBit){}
exportconstUPDATE_COLLECT="[Collectaction]UpdateCollect";
exportclassUpdateCollectimplementsAction{
readonlytype=UPDATE_COLLECT;
constructor(publicbale:CollectBit){}
exportconstFETCH_COLLECT="[Collectaction]FetchCollect";
exportclassFetchCollectimplementsAction{
readonlytype=FETCH_COLLECT;
constructor(publicbale:CollectBit){}
exportconstREAD_COLLECT="[Readaction]ReadCollect";
exportclassReadCollectimplementsAction{
readonlytype=READ_COLLECT;
constructor(publicbale:CollectBit){}
exportconstWRITE_COLLECT="[Writeaction]WriteCollect";
exportclassWriteCollectimplementsAction{
readonlytype=WRITE_COLLECT;
constructor(publicbale:CollectBit){}
exportconstCREATE_COLLECT="[Createaction]CreateCollect";
exportclassCreateCollectimplementsAction{
readonlytype=CREATE_COLLECT;
constructor(publicbale:CollectBit){}
exportconstREMOVE_COLLECT="[Createaction]RemoveCollect";
exportclassRemoveCollectimplementsAction{
readonlytype=REMOVE_COLLECT;
constructor(publicbale:CollectBit){}
exportconstDELETE_COLLECT="[Createaction]DeleteCollect";
exportclassDeleteCollectimplementsAction{
readonlytype=DELETE_COLLECT;
constructor(publicbale:CollectBit){}
exportconstEMPTY_COLLECT="[Emptyaction]EmptyCollect";
exportclassEmptyCollectimplementsAction{
readonlytype=EMPTY_COLLECT;
constructor(publicbale:CollectBit){}
exportconstMODEL_COLLECT="[Emptyaction]ModelCollect";
exportclassModelCollectimplementsAction{
readonlytype=MODEL_COLLECT;
constructor(publicbale:CollectBit){}
exportconstPUT_COLLECT="[Emptyaction]PutCollect";
exportclassPutCollectimplementsAction{
readonlytype=PUT_COLLECT;
constructor(publicbale:CollectBit){}
exportconstGET_COLLECT="[Emptyaction]GetCollect";
exportclassGetCollectimplementsAction{
readonlytype=GET_COLLECT;
constructor(publicbale:CollectBit){}
exportconstFORMAT_COLLECT="[Formataction]FormatCollect";
exportclassFormatCollectimplementsAction{
readonlytype=FORMAT_COLLECT;
constructor(publicbale:CollectBit){}
exportconstDOT_COLLECT="[Formataction]DotCollect";
exportclassDotCollectimplementsAction{
readonlytype=DOT_COLLECT;
constructor(publicbale:CollectBit){}
exportconstLIST_COLLECT="[Listaction]ListCollect";
exportclassListCollectimplementsAction{
readonlytype=LIST_COLLECT;
constructor(publicbale:CollectBit){}
exportconstHASH_COLLECT="[Hashaction]HashCollect";
exportclassHashCollectimplementsAction{
readonlytype=HASH_COLLECT;
constructor(publicbale:CollectBit){}
exporttypeActions=|InitCollect|UpdateCollect
|ReadCollect
|WriteCollect
|CreateCollect
|EmptyCollect
|FetchCollect
|DeleteCollect
|RemoveCollect
|ModelCollect
|GetCollect
|PutCollect
|FormatCollect
|DotCollect
|ListCollect
|HashCollect
export{initCollect}from"./buz/collect.buzz";
export{updateCollect}from"./buz/collect.buzz";
export{readCollect}from"./buz/collect.buzz";
export{writeCollect}from"./buz/collect.buzz";
export{createCollect}from"./buz/collect.buzz";
export{emptyCollect}from"./buz/collect.buzz";
export{fetchCollect}from"./buz/collect.buzz";
export{deleteCollect}from"./buz/collect.buzz";
export{removeCollect}from"./buz/collect.buzz";
export{modelCollect}from"./buz/collect.buzz";
export{putCollect}from"./buz/collect.buzz";
export{getCollect}from"./buz/collect.buzz";
export{formatCollect}from"./buz/collect.buzz";
export{dotCollect}from"./buz/collect.buzz";
export{listCollect}from"./buz/collect.buzz";
export{hashCollect}from"./buz/collect.buzz";
importCaboodleBitfrom"./fce/caboodle.bit";
importCollectfrom"./fce/collect.interface";
importCollectBitfrom"./fce/collect.interface";
exportclassCollectModelimplementsCollect{
idx:string='23.11.14';
caboodleBitList:CaboodleBit[]=[];
caboodleBits:any={};
import*asActfrom"./collect.action";
import{CollectModel}from"./collect.model";
import*asBuzzfrom"./collect.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:CollectModel=newCollectModel(),act:Act.Actions,state?:State){
varclone=require('clone-deep');
switch(act.type){
caseAct.UPDATE_COLLECT:
returnBuzz.updateCollect(clone(model),act.bale,state);
caseAct.INIT_COLLECT:
returnBuzz.initCollect(clone(model),act.bale,state);
caseAct.READ_COLLECT:
returnBuzz.readCollect(clone(model),act.bale,state);
caseAct.WRITE_COLLECT:
returnBuzz.writeCollect(clone(model),act.bale,state);
caseAct.CREATE_COLLECT:
returnBuzz.createCollect(clone(model),act.bale,state);
caseAct.DELETE_COLLECT:
returnBuzz.deleteCollect(clone(model),act.bale,state);
caseAct.REMOVE_COLLECT:
returnBuzz.removeCollect(clone(model),act.bale,state);
caseAct.EMPTY_COLLECT:
returnBuzz.emptyCollect(clone(model),act.bale,state);
caseAct.FETCH_COLLECT:
returnBuzz.fetchCollect(clone(model),act.bale,state);
caseAct.MODEL_COLLECT:
returnBuzz.modelCollect(clone(model),act.bale,state);
caseAct.GET_COLLECT:
returnBuzz.getCollect(clone(model),act.bale,state);
caseAct.PUT_COLLECT:
returnBuzz.putCollect(clone(model),act.bale,state);
caseAct.FORMAT_COLLECT:
returnBuzz.formatCollect(clone(model),act.bale,state);
caseAct.DOT_COLLECT:
returnBuzz.dotCollect(clone(model),act.bale,state);
caseAct.LIST_COLLECT:
returnBuzz.listCollect(clone(model),act.bale,state);
caseAct.HASH_COLLECT:
returnBuzz.hashCollect(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassCollectUnit{
constructor(state:State){
exportdefaultinterfaceCaboodleBit{
idx:string;
dex:number;
bitList:any[];
bits:any;
exportdefaultinterfaceCollectBit{
idx?:string;
src?:string;
val?:number;
dex?:number;
dat?:any;
bit?:any;
slv?:Function;
importCollectBitfrom"./collect.bit";
importCaboodleBitfrom"./caboodle.bit";
exportdefaultinterfaceCollect{
idx:string;
caboodleBitList:CaboodleBit[];
caboodleBits:any;
import{Action}from"../99.core/interface/action.interface";
importBusBitfrom"./fce/bus.bit";
exportconstINIT_BUS="[Busaction]InitBus";
exportclassInitBusimplementsAction{
readonlytype=INIT_BUS;
constructor(publicbale:BusBit){}
exportconstOPEN_BUS="[Busaction]OpenBus";
exportclassOpenBusimplementsAction{
readonlytype=OPEN_BUS;
constructor(publicbale:BusBit){}
exportconstCONNECT_BUS="[Busaction]ConnectBus";
exportclassConnectBusimplementsAction{
readonlytype=CONNECT_BUS;
constructor(publicbale:BusBit){}
exportconstMESSAGE_BUS="[Busaction]MessageBus";
exportclassMessageBusimplementsAction{
readonlytype=MESSAGE_BUS;
constructor(publicbale:BusBit){}
exportconstUPDATE_BUS="[Busaction]UpdateBus";
exportclassUpdateBusimplementsAction{
readonlytype=UPDATE_BUS;
constructor(publicbale:BusBit){}
exportconstCREATE_BUS="[Busaction]CreateBus";
exportclassCreateBusimplementsAction{
readonlytype=CREATE_BUS;
constructor(publicbale:BusBit){}
exporttypeActions=|InitBus|OpenBus|UpdateBus|ConnectBus|MessageBus|CreateBus;
export{initBus}from"./buz/bus.buzz";
export{openBus}from"./buz/bus.buzz";
export{updateBus}from"./buz/bus.buzz";
export{connectBus}from"./buz/bus.buzz";
export{messageBus}from"./buz/bus.buzz";
export{createBus}from"./buz/bus.buzz";
importBusfrom"./fce/bus.interface";
importBusBitfrom"./fce/bus.interface";
exportclassBusModelimplementsBus{
MQTT:any;
actList:any;
client:any;
bus:Function;
responseSuffix:string='-response'
promises:any={}
import*asActfrom"./bus.action";
import{BusModel}from"./bus.model";
import*asBuzzfrom"./bus.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:BusModel=newBusModel(),act:Act.Actions,state?:State){
varclone=require('clone-deep');
switch(act.type){
caseAct.UPDATE_BUS:
returnBuzz.updateBus(clone(model),act.bale,state);
caseAct.OPEN_BUS:
returnBuzz.openBus(clone(model),act.bale,state);
caseAct.CONNECT_BUS:
returnBuzz.connectBus(clone(model),act.bale,state);
caseAct.CREATE_BUS:
returnBuzz.createBus(clone(model),act.bale,state);
caseAct.MESSAGE_BUS:
returnBuzz.connectBus(clone(model),act.bale,state);
caseAct.INIT_BUS:
returnBuzz.initBus(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassBusUnit{
constructor(state:State){
import*asActBusfrom"../../99.bus.unit/bus.action";
import*asActColfrom"../../97.collect.unit/collect.action";
varlst,idx,bit,src,dat,dex;
exportconstinitBus=(cpy:BusModel,bal:BusBit,ste:State)=>{
cpy.actList=[]
if(bal==null)bal={idx:null}
if(bal.lst==null)bal.lst=[]
if((bal.src!=null)&&(bal.src.constructor==Array))lst=bal.src;
bal.lst.forEach((a)=>{
for(varkeyina){
cpy.actList.push(a[key])
ste.bus=(idx,dat,bit)=>updateBus(cpy,{idx,dat,bit},ste)
if(bal.dat!=null){
cpy.MQTT=bal.dat;
else{
if(lst==null){
if(bal.src!=null)cpy.host=bal.src
cpy.client=cpy.MQTT.connect(cpy.host);
cpy.client.on('message',(tpc,msg)=>{messageBus(cpy,{idx:tpc,src:msg},ste)})
cpy.client.on('connect',()=>{
openBus(cpy,{idx:'init-bus',lst:cpy.actList},ste)
if(bal.slv!=null)bal.slv({intBit:{idx:"init-bus"}})
}else{
varcomplete=(lst)=>{
lst.shift()
if(lst.length!=0)return
if(bal.slv!=null)bal.slv({intBit:{idx:"init-bus"}})
lst.forEach(async(a)=>{
bit=awaitste.hunt(ActCol.WRITE_COLLECT,{idx:a.idx,src:a.src,bit:ActBus.CREATE_BUS})
varclient=bit.clcBit.dat;
client.on('message',(tpc,msg)=>{messageBus(cpy,{idx:tpc,src:msg,bit:a.idx},ste)})
client.on('connect',()=>{
openBus(cpy,{idx:'init-bus',lst:cpy.actList,bit:a.idx},ste)
complete(lst)
exportconstcreateBus=(cpy:BusModel,bal:BusBit,ste:State)=>{
varclient=cpy.MQTT.connect(bal.src);
if(bal.slv!=null)bal.slv({busBit:{idx:"create-bus",dat:client}});
exportconstopenBus=async(cpy:BusModel,bal:BusBit,ste:State)=>{
varout=[]
bal.lst.forEach((a)=>{
if(a==null)return
if(a.includes==null)return
if(a.includes('[')&&a.includes(']')==false)return
out.push(a)
varclient=cpy.client;
if(bal.bit!=null){
bit=awaitste.hunt(ActCol.READ_COLLECT,{idx:bal.bit,bit:ActBus.CREATE_BUS})
client=bit.clcBit.dat
out.forEach((a)=>{
client.subscribe(a,(err)=>{
if(!err){
exportconstconnectBus=(cpy:BusModel,bal:BusBit,ste:State)=>{
varlst=[]
exportconstmessageBus=async(cpy:BusModel,bal:BusBit,ste:State)=>{
if(bal.src!=null)dat=bal.src.toString()
idx=bal.idx
dat=JSON.parse(dat)
varclient=cpy.client;
if(bal.bit!=null){
bit=awaitste.hunt(ActCol.READ_COLLECT,{idx:bal.bit,bit:ActBus.CREATE_BUS})
client=bit.clcBit.dat
if(idx.includes(cpy.responseSuffix)==true){
varresponseIDX=bal.idx;
varobj=cpy.promises[responseIDX];
if(obj.slv!=null)obj.slv(dat);
client.unsubscribe(responseIDX,(err)=>{
if(!err){
}else{
varbit=awaitste.hunt(idx,dat)
varcloneBit=clone(bit)
for(varkeyincloneBit){
varitm=cloneBit[key]
if(itm.dat!=null){
if(itm.dat.bit!=null)itm.dat.bit=null
cloneBit
client.publish(bal.idx+cpy.responseSuffix,JSON.stringify(cloneBit))
exportconstupdateBus=async(cpy:BusModel,bal:BusBit,ste:State)=>{
varclient=cpy.client;
if(bal.bit!=null){
bit=awaitste.hunt(ActCol.READ_COLLECT,{idx:bal.bit,bit:ActBus.CREATE_BUS})
client=bit.clcBit.dat
if((client==null)&&(bal.bit==null)){
bit=awaitste.hunt(ActCol.FETCH_COLLECT,{bit:ActBus.CREATE_BUS})
client=bit.clcBit.dat
varresponseIDX=bal.idx+cpy.responseSuffix;
varslv;
constpromo=newPromise((rslv,rjct)=>(slv=rslv));
varobj={slv:(val0)=>slv(val0)};
cpy.promises[responseIDX]=obj
client.subscribe(responseIDX,(err)=>{
if(!err){
client.publish(bal.idx,JSON.stringify(bal.dat))
returnpromo;
varpatch=(ste,type,bale)=>ste.dispatch({type,bale});
import{BusModel}from"../bus.model";
importBusBitfrom"../fce/bus.bit";
importStatefrom"../../99.core/state";
importSfrom"string";
import*asclonefrom"clone-deep";
"usestrict";
exports.__esModule=true;
exportdefaultinterfaceBusBit{
idx:string;
val?:number;
lst?:any;
src?:any;
bit?:string;
slv?:Function;
dat?:any;
"usestrict";
exports.__esModule=true;
importBusBitfrom"./bus.bit";
exportdefaultinterfaceBus{
exportinterfaceAction<T=any>{
type:string;
bale?:T;
exportdefaultinterfaceModel{}
import{BehaviorSubject}from"rx-lite";
import{Subject}from"rx-lite";
import{Action}from"./interface/action.interface";
importUnitModelfrom"../BEE";
import*asEffectfrom"../BEE";
exportdefaultclassStateextendsBehaviorSubject<any>{
publichunt:any;
publicvalue:any;
publicpivot:any;
publicbus:any;
privatedispatcher:Subject=newSubject();
constructor(init:UnitModel=newUnitModel()){
super(init);
this.dispatcher
.scan((state,action)=>this.reducedApp(state,action),init)
.subscribe((state)=>{
super.onNext(state);
reducedApp(nextState:any,key:any){
for(varkinEffect.reducer)Effect.reducer[k](nextState[k],key,this);
returnnextState;
dispatch(value:Action){
varresult=this.dispatcher.onNext(value);
returnresult;
pat(value:Action){
this.dispatch(value);
next(value:any){
this.dispatcher.onNext(value);
exportconstINIT_CANVAS="[Canvasaction]InitCanvas";
exportconstUPDATE_CANVAS="[Canvasaction]UpdateCanvas";
exportconstREAD_CANVAS="[Readaction]ReadCanvas";
exportconstWRITE_CANVAS="[Writeaction]WriteCanvas";
exportconstDELETE_CANVAS="[Deleteaction]DeleteCanvas";
exportconstREMOVE_CANVAS="[Removeaction]RemoveCanvas";
exportconstCREATE_CANVAS="[Createaction]CreateCanvas";
exportconstNEST_CANVAS="[Nestaction]NestCanvas";
exportconstINIT_CHOICE="[Choiceaction]InitChoice";
exportconstUPDATE_CHOICE="[Choiceaction]UpdateChoice";
exportconstOPEN_CHOICE="[Openaction]OpenChoice";
exportconstKEY_CHOICE="[Keyaction]KeyChoice";
exportconstTOWER_CHOICE="[Toweraction]TowerChoice";
exportconstINIT_CONSOLE="[Consoleaction]InitConsole";
exportconstUPDATE_CONSOLE="[Consoleaction]UpdateConsole";
exportconstREAD_CONSOLE="[Readaction]ReadConsole";
exportconstWRITE_CONSOLE="[Writeaction]WriteConsole";
exportconstREMOVE_CONSOLE="[Removeaction]RemoveConsole";
exportconstDELETE_CONSOLE="[Deleteaction]DeleteConsole";
exportconstCREATE_CONSOLE="[Createaction]CreateConsole";
"usestrict";
exports.__esModule=true;
exports.COPY_DISK=exports.LOAD_LIST_DISK=exports.LIST_DISK=exports.WRITE_DISK=exports.READ_DISK=exports.UPDATE_DISK=exports.INIT_DISK=void0;
exports.INIT_DISK="[Diskaction]InitDisk";
exports.UPDATE_DISK="[Diskaction]UpdateDisk";
exports.READ_DISK="[Diskaction]ReadDisk";
exports.WRITE_DISK="[Diskaction]WriteDisk";
exports.LIST_DISK="[Listaction]ListDisk";
exports.LOAD_LIST_DISK="[Load_listaction]Load_listDisk";
exports.COPY_DISK="[Copyaction]CopyDisk";
exportconstINIT_DISK='[Diskaction]InitDisk'
exportconstUPDATE_DISK='[Diskaction]UpdateDisk'
exportconstREAD_DISK='[Diskaction]ReadDisk'
exportconstWRITE_DISK='[Diskaction]WriteDisk'
exportconstINDEX_DISK='[Indexaction]IndexDisk'
exportconstLOAD_LIST_DISK='[Load_listaction]Load_listDisk'
exportconstCOPY_DISK='[Copyaction]CopyDisk'
exportconstFRAME_DISK='[Frameaction]FrameDisk'
exportconstBATCH_DISK='[Batchaction]BatchDisk'
exportconstTRASH_DISK='[Trashaction]TrashDisk'
exportconstENSURE_DISK='[Ensureaction]EnsureDisk'
exportconstDELETE_DISK='[Deleteaction]DeleteDisk'
exportconstINIT_ENGINE="[Engineaction]InitEngine";
exportconstUPDATE_ENGINE="[Engineaction]UpdateEngine";
exportconstMOVEMENT_ENGINE="[Movementaction]MovementEngine";
exportconstOPEN_ENGINE="[Openaction]OpenEngine";
exportconstCLOSE_ENGINE="[Closeaction]CloseEngine";
exportconstINIT_GITHUB="[Githubaction]InitGithub";
exportconstUPDATE_GITHUB="[Githubaction]UpdateGithub";
exportconstCOMMIT_GITHUB="[Commitaction]CommitGithub";
import{Action}from"../99.core/interface/action.interface";
exportconstINIT_GRAPHIC="[Graphicaction]InitGraphic";
exportconstUPDATE_GRAPHIC="[Graphicaction]UpdateGraphic";
exportconstREAD_GRAPHIC="[Readaction]ReadGraphic";
exportconstWRITE_GRAPHIC="[Writeaction]WriteGraphic";
exportconstCREATE_GRAPHIC="[Createaction]CreateGraphic";
exportconstINIT_GRID="[Gridaction]InitGrid";
exportconstUPDATE_GRID="[Gridaction]UpdateGrid";
exportconstINIT_HEXAGON="[Hexagonaction]InitHexagon";
exportconstUPDATE_HEXAGON="[Hexagonaction]UpdateHexagon";
exportconstREAD_HEXAGON="[Readaction]ReadHexagon";
exportconstWRITE_HEXAGON="[Writeaction]WriteHexagon";
exportconstCREATE_HEXAGON="[Createaction]CreateHexagon";
exportconstINIT_INPUT="[Inputaction]InitInput";
exportconstUPDATE_INPUT="[Inputaction]UpdateInput";
exportconstOPEN_INPUT="[Openaction]OpenInput";
exportconstINIT_PIVOT="[Pivotaction]InitPivot";
exportconstUPDATE_PIVOT="[Pivotaction]UpdatePivot";
exportconstOPEN_PIVOT="[Openaction]OpenPivot";
exportconstRUN_PIVOT="[Runaction]RunPivot";
exportconstEDIT_PIVOT="[Editaction]EditPivot";
exportconstPATCH_PIVOT="[Patchaction]PatchPivot";
exportconstCOUNT_PIVOT="[Patchaction]CountPivot";
exportconstLIST_PIVOT="[Patchaction]ListPivot";
exportconstCREATE_PIVOT="[Patchaction]CreatePivot";
exportconstCONTAINS_PIVOT="[Patchaction]ContainsPivot";
exportconstBUNDLE_PIVOT="[Patchaction]BundlePivot";
"usestrict";
exports.__esModule=true;
exports.OPEN_RENPY=exports.UPDATE_RENPY=exports.INIT_RENPY=void0;
exports.INIT_RENPY="[Renpyaction]InitRenpy";
exports.UPDATE_RENPY="[Renpyaction]UpdateRenpy";
exports.OPEN_RENPY="[Renpyaction]OpenRenpy";
exportconstINIT_RENPY="[Renpyaction]InitRenpy";
exportconstUPDATE_RENPY="[Renpyaction]UpdateRenpy";
exportconstOPEN_RENPY="[Renpyaction]OpenRenpy";
"usestrict";
exports.__esModule=true;
exports.OPEN_SHINY=exports.UPDATE_SHINY=exports.INIT_SHINY=void0;
exports.INIT_SHINY="[Shinyaction]InitShiny";
exports.UPDATE_SHINY="[Shinyaction]UpdateShiny";
exports.OPEN_SHINY="[Shinyaction]OpenShiny";
exportconstINIT_SHINY="[Shinyaction]InitShiny";
exportconstUPDATE_SHINY="[Shinyaction]UpdateShiny";
exportconstOPEN_SHINY="[Shinyaction]OpenShiny";
"usestrict";
exports.__esModule=true;
exports.READY_SPACE=exports.UPDATE_SPACE=exports.INIT_SPACE=void0;
exports.INIT_SPACE="[Spaceaction]InitSpace";
exports.UPDATE_SPACE="[Spaceaction]UpdateSpace";
exports.READY_SPACE="[Readyaction]ReadySpace";
exportconstINIT_SPACE="[Spaceaction]InitSpace";
exportconstUPDATE_SPACE="[Spaceaction]UpdateSpace";
exportconstREADY_SPACE="[Readyaction]ReadySpace";
"usestrict";
exports.__esModule=true;
exports.ADD_PORT=exports.CONTENT_TERMINAL=exports.ROOT_TERMINAL=exports.CLOSE_TERMINAL=exports.TABLE_TERMINAL=exports.INPUT_TERMINAL=exports.CLEAR_TERMINAL=exports.UPDATE_TERMINAL=exports.WRITE_TERMINAL=exports.FOCUS_TERMINAL=exports.OPEN_TERMINAL=exports.INIT_TERMINAL=void0;
exports.INIT_TERMINAL="[Terminalaction]InitTerminal";
exports.OPEN_TERMINAL="[Terminalaction]OpenTerminal";
exports.FOCUS_TERMINAL="[Terminalaction]FocusTerminal";
exports.WRITE_TERMINAL="[Terminalaction]WriteTerminal";
exports.UPDATE_TERMINAL="[Terminalaction]UpdateTerminal";
exports.CLEAR_TERMINAL="[Terminalaction]ClearTerminal";
exports.INPUT_TERMINAL="[Terminalaction]InputTerminal";
exports.TABLE_TERMINAL="[Terminalaction]TableTerminal";
exports.CLOSE_TERMINAL="[Terminalaction]CloseTerminal";
exports.ROOT_TERMINAL="[Terminalaction]RootTerminal";
exports.CONTENT_TERMINAL="[Terminalaction]ContentTerminal";
exports.ADD_PORT="[Terminalaction]AddPort";
exportconstINIT_TERMINAL="[Terminalaction]InitTerminal";
exportconstUPDATE_TERMINAL="[Terminalaction]UpdateTerminal";
exportconstRUN_TERMINAL="[Runaction]RunTerminal";
exportconstEDIT_TERMINAL="[Editaction]EditTerminal";
exportconstPRINT_TERMINAL="[Printaction]PrintTerminal";
exportconstCLOSE_TERMINAL="[Closeaction]CloseTerminal";
exportconstOPTION_TERMINAL="[Optionaction]OptionTerminal";
exportconstINPUT_TERMINAL="[Inputaction]InputTerminal";
exportconstLAYOUT_TERMINAL="[Layoutaction]LayoutTerminal";
exportconstOPEN_TERMINAL="[Layoutaction]OpenTerminal";
exportconstCLEAR_TERMINAL="[Layoutaction]ClearTerminal";
exportconstINIT_TEXT="[Textaction]InitText";
exportconstUPDATE_TEXT="[Textaction]UpdateText";
exportconstREAD_TEXT="[Readaction]ReadText";
exportconstWRITE_TEXT="[Writeaction]WriteText";
exportconstCREATE_TEXT="[Createaction]CreateText";
exportconstREMOVE_TEXT="[Removeaction]RemoveText";
exportconstDELETE_TEXT="[Deleteaction]DeleteText";
exportconstLIST_TEXT="[Listaction]ListText";
exportconstINIT_VISAGE="[Visageaction]InitVisage";
exportconstUPDATE_VISAGE="[Visageaction]UpdateVisage";
exportconstFULLSCREEN_VISAGE="[Fullscreenaction]FullscreenVisage";
exportconstREAD_VISAGE="[Readaction]ReadVisage";
exportconstWRITE_VISAGE="[Writeaction]WriteVisage";
exportconstCREATE_VISAGE="[Createaction]CreateVisage";
exportconstSIZE_VISAGE="[Sizeaction]SizeVisage";
exportconstRENDER_VISAGE="[Renderaction]RenderVisage";
"usestrict";
exports.__esModule=true;
exports.VALUE_VURT=exports.BUNDLE_VURT=exports.CONTAINS_VURT=exports.LIST_UNIT_VURT=exports.LIST_PIVOT_VURT=exports.COUNT_VURT=exports.UNIT_VURT=exports.REPLACE_VURT=exports.UPDATE_VURT=exports.FETCH_VURT=exports.TEST_CLOUD_VURT=exports.DELAY_VURT=exports.INIT_VURT=void0;
exports.INIT_VURT="[Vurtaction]InitVurt";
exports.DELAY_VURT="[Vurtaction]DelayVurt";
exports.TEST_CLOUD_VURT="[Vurtaction]TestCloudVurt";
exports.FETCH_VURT="[Vurtaction]FetchVurt";
exports.UPDATE_VURT="[Vurtaction]UpdateVurt";
exports.REPLACE_VURT="[Vurtaction]ReplaceVurt";
exports.UNIT_VURT="[Vurtaction]UnitVurt";
exports.COUNT_VURT="[Vurtaction]CountVurt";
exports.LIST_PIVOT_VURT="[Vurtaction]ListPivotVurt";
exports.LIST_UNIT_VURT="[Vurtaction]ListUnitVurt";
exports.CONTAINS_VURT="[Containsaction]ContainsVurt";
exports.BUNDLE_VURT="[Bundleaction]BundleVurt";
exports.VALUE_VURT="[Valueaction]ValueVurt";
exportconstINIT_VURT="[Vurtaction]InitVurt";
exportconstDELAY_VURT="[Vurtaction]DelayVurt";
exportconstTEST_CLOUD_VURT="[Vurtaction]TestCloudVurt";
exportconstFETCH_VURT="[Vurtaction]FetchVurt";
exportconstUPDATE_VURT="[Vurtaction]UpdateVurt";
exportconstREPLACE_VURT="[Vurtaction]ReplaceVurt";
exportconstUNIT_VURT="[Vurtaction]UnitVurt";
exportconstCOUNT_VURT="[Vurtaction]CountVurt";
exportconstLIST_PIVOT_VURT="[Vurtaction]ListPivotVurt";
exportconstLIST_UNIT_VURT="[Vurtaction]ListUnitVurt";
exportconstCONTAINS_VURT="[Containsaction]ContainsVurt";
exportconstBUNDLE_VURT="[Bundleaction]BundleVurt";
exportconstVALUE_VURT="[Valueaction]ValueVurt";
importModelfrom"./99.core/interface/model.interface";
importSpaceUnitfrom"./00.space.unit/space.unit";
importBabylonUnitfrom"./01.babylon.unit/babylon.unit";
importFocusUnitfrom"./01.focus.unit/focus.unit";
importCameraUnitfrom"./02.camera.unit/camera.unit";
importGeojsonUnitfrom"./02.geojson.unit/geojson.unit";
importHexmapUnitfrom"./03.hexmap.unit/hexmap.unit";
importLightUnitfrom"./03.light.unit/light.unit";
importPrimativeUnitfrom"./04.primative.unit/primative.unit";
importScreenUnitfrom"./08.screen.unit/screen.unit";
importGlopUnitfrom"./09.glop.unit/glop.unit";
importMikuUnitfrom"./10.miku.unit/miku.unit";
importCollectUnitfrom"./97.collect.unit/collect.unit";
importBusUnitfrom"./99.bus.unit/bus.unit";
importSpacefrom"./00.space.unit/fce/space.interface";
import{SpaceModel}from"./00.space.unit/space.model";
importBabylonfrom"./01.babylon.unit/fce/babylon.interface";
import{BabylonModel}from"./01.babylon.unit/babylon.model";
importFocusfrom"./01.focus.unit/fce/focus.interface";
import{FocusModel}from"./01.focus.unit/focus.model";
importCamerafrom"./02.camera.unit/fce/camera.interface";
import{CameraModel}from"./02.camera.unit/camera.model";
importGeojsonfrom"./02.geojson.unit/fce/geojson.interface";
import{GeojsonModel}from"./02.geojson.unit/geojson.model";
importHexmapfrom"./03.hexmap.unit/fce/hexmap.interface";
import{HexmapModel}from"./03.hexmap.unit/hexmap.model";
importLightfrom"./03.light.unit/fce/light.interface";
import{LightModel}from"./03.light.unit/light.model";
importPrimativefrom"./04.primative.unit/fce/primative.interface";
import{PrimativeModel}from"./04.primative.unit/primative.model";
importScreenfrom"./08.screen.unit/fce/screen.interface";
import{ScreenModel}from"./08.screen.unit/screen.model";
importGlopfrom"./09.glop.unit/fce/glop.interface";
import{GlopModel}from"./09.glop.unit/glop.model";
importMikufrom"./10.miku.unit/fce/miku.interface";
import{MikuModel}from"./10.miku.unit/miku.model";
importCollectfrom"./97.collect.unit/fce/collect.interface";
import{CollectModel}from"./97.collect.unit/collect.model";
importBusfrom"./99.bus.unit/fce/bus.interface";
import{BusModel}from"./99.bus.unit/bus.model";
exportconstlist:Array<any>=[SpaceUnit,BabylonUnit,FocusUnit,CameraUnit,GeojsonUnit,HexmapUnit,LightUnit,PrimativeUnit,ScreenUnit,GlopUnit,MikuUnit,CollectUnit,BusUnit];
import*asreduceFromSpacefrom"./00.space.unit/space.reduce";
import*asreduceFromBabylonfrom"./01.babylon.unit/babylon.reduce";
import*asreduceFromFocusfrom"./01.focus.unit/focus.reduce";
import*asreduceFromCamerafrom"./02.camera.unit/camera.reduce";
import*asreduceFromGeojsonfrom"./02.geojson.unit/geojson.reduce";
import*asreduceFromHexmapfrom"./03.hexmap.unit/hexmap.reduce";
import*asreduceFromLightfrom"./03.light.unit/light.reduce";
import*asreduceFromPrimativefrom"./04.primative.unit/primative.reduce";
import*asreduceFromScreenfrom"./08.screen.unit/screen.reduce";
import*asreduceFromGlopfrom"./09.glop.unit/glop.reduce";
import*asreduceFromMikufrom"./10.miku.unit/miku.reduce";
import*asreduceFromCollectfrom"./97.collect.unit/collect.reduce";
import*asreduceFromBusfrom"./99.bus.unit/bus.reduce";
exportconstreducer:any={
space:reduceFromSpace.reducer,
babylon:reduceFromBabylon.reducer,
focus:reduceFromFocus.reducer,
camera:reduceFromCamera.reducer,
geojson:reduceFromGeojson.reducer,
hexmap:reduceFromHexmap.reducer,
light:reduceFromLight.reducer,
primative:reduceFromPrimative.reducer,
screen:reduceFromScreen.reducer,
glop:reduceFromGlop.reducer,
miku:reduceFromMiku.reducer,
collect:reduceFromCollect.reducer,
bus:reduceFromBus.reducer,
exportdefaultclassUnitDataimplementsModel{
space:Space=newSpaceModel();
babylon:Babylon=newBabylonModel();
focus:Focus=newFocusModel();
camera:Camera=newCameraModel();
geojson:Geojson=newGeojsonModel();
hexmap:Hexmap=newHexmapModel();
light:Light=newLightModel();
primative:Primative=newPrimativeModel();
screen:Screen=newScreenModel();
glop:Glop=newGlopModel();
miku:Miku=newMikuModel();
collect:Collect=newCollectModel();
bus:Bus=newBusModel();
varsim={
hunt:null,
state:null
sim.hunt=(typ,obj)=>{returnhost(obj,typ)}
varhost=(obj,typ)=>{
init();
varslv;
constpromo=newPromise((rslv,rjct)=>(slv=rslv));
if(obj==null)obj={};
if(obj.slv==null)obj.slv=(val0)=>slv(val0);
sim.state.dispatch({type:typ,bale:obj});
returnpromo;
varinit=()=>{
if(sim.state!=null)return;
sim.state=newState();
sim.state.pivot=sim;
sim.state.hunt=sim.hunt
for(varkinImport.list)newImport.list[k](sim.state);
import*asImportfrom"./BEE";
importStatefrom"./99.core/state";
module.exports=sim;
exportconstVERTICAL="vertical";
exportconstHORIZONTAL="horizontal";
exportconstBLACK:string="black";
exportconstRED:string="red";
exportconstGREEN:string="green";
exportconstYELLOW:string="yellow";
exportconstMAGENTA:string="magenta";
exportconstCYAN:string="cyan";
exportconstWHITE:string="white";
exportconstBLUE:string="blue";
"usestrict";
exports.__esModule=true;
exports.CYAN=exports.MAGENTA=exports.YELLOW=exports.GREEN=exports.RED=void0;
exports.RED="\x1b[31m%s\x1b[0m";
exports.GREEN="\x1b[32m%s\x1b[0m";
exports.YELLOW="\x1b[33m%s\x1b[0m";
exports.MAGENTA="\x1b[34m%s\x1b[0m";
exports.CYAN="\x1b[36m%s\x1b[0m";
exportconstRED:string="\x1b[31m%s\x1b[0m";
exportconstGREEN:string="\x1b[32m%s\x1b[0m";
exportconstYELLOW:string="\x1b[33m%s\x1b[0m";
exportconstMAGENTA:string="\x1b[34m%s\x1b[0m";
exportconstCYAN:string="\x1b[36m%s\x1b[0m";
"usestrict";
exports.__esModule=true;
exports.WISE_NORTH_EAST=exports.WISE_NORTH=exports.WISE_NORTH_WEST=exports.WISE_WEST=exports.WISE_SOUTH_WEST=exports.WISE_SOUTH=exports.WISE_SOUTH_EAST=exports.WISE_EAST=exports.NORTH_EAST=exports.NORTH=exports.NORTH_WEST=exports.WEST=exports.SOUTH_WEST=exports.SOUTH=exports.SOUTH_EAST=exports.EAST=void0;
exports.EAST="E";
exports.SOUTH_EAST="SE";
exports.SOUTH="S";
exports.SOUTH_WEST="SW";
exports.WEST="W";
exports.NORTH_WEST="NW";
exports.NORTH="N";
exports.NORTH_EAST="NE";
exports.WISE_EAST="WiseE";
exports.WISE_SOUTH_EAST="WiseSE";
exports.WISE_SOUTH="WiseS";
exports.WISE_SOUTH_WEST="WiseSW";
exports.WISE_WEST="WiseW";
exports.WISE_NORTH_WEST="WiseNW";
exports.WISE_NORTH="WiseN";
exports.WISE_NORTH_EAST="WiseNE";
exportconstEAST="E";
exportconstSOUTH_EAST="SE";
exportconstSOUTH="S";
exportconstSOUTH_WEST="SW";
exportconstWEST="W";
exportconstNORTH_WEST="NW";
exportconstNORTH="N";
exportconstNORTH_EAST="NE";
exportconstWISE_EAST="WiseE";
exportconstWISE_SOUTH_EAST="WiseSE";
exportconstWISE_SOUTH="WiseS";
exportconstWISE_SOUTH_WEST="WiseSW";
exportconstWISE_WEST="WiseW";
exportconstWISE_NORTH_WEST="WiseNW";
exportconstWISE_NORTH="WiseN";
exportconstWISE_NORTH_EAST="WiseNE";
exportconstPLAT:string="plat";
exportconstAMBT:string="ambt";
exportconstAVAS:string="avas";
"usestrict";
exports.__esModule=true;
exports.CIRCLE=exports.ROUNDED_RECTANGLE=exports.RECTANGLE=void0;
exports.RECTANGLE="rectangle";
exports.ROUNDED_RECTANGLE="rounded-rectangle";
exports.CIRCLE="circle";
exportconstRECTANGLE:string="rectangle";
exportconstROUNDED_RECTANGLE:string="rounded-rectangle";
exportconstCIRCLE:string="circle";
exporttypePosition<Type>={
x:number;
y:number;
}&Type
exporttypeGridFill=Position<{
xSpan:number;
ySpan:number;
exportconstTOP_FULL_IDX='top-fill';
exportconstMID_FULL_IDX='mid-fill';
exportconstBOT_FULL_IDX='bot-fill';
exportconstTOP_FULL_BIT:GridFill={x:0,y:0,xSpan:12,ySpan:4};
exportconstMID_FULL_BIT:GridFill={x:0,y:4,xSpan:12,ySpan:5};
exportconstBOT_FULL_BIT:GridFill={x:0,y:8,xSpan:12,ySpan:4};
"usestrict";
exports.__esModule=true;
exports.HEXMAP=exports.FOCUS=void0;
exports.FOCUS="focus";
exports.HEXMAP="hexmap";
exportconstFOCUS:string="focus";
exportconstHEXMAP:string="hexmap";
"usestrict";
exports.__esModule=true;
exports.PASTURE=exports.FANG_SWAMP=exports.GEORGIA=exports.GALLBLADDER=void0;
exports.GALLBLADDER="00000.gallbladder";
exports.GEORGIA="00001.georgia";
exports.FANG_SWAMP="00002.fang-swamp";
exports.PASTURE="00003.pasture";
exportconstPLAT:string="plat";
exportconstAMBT:string="ambt";
exportconstAVAS:string="avas";
exportconstWELCOME_WINDOW:string="welcomeWindow";
exportconstPLAY_DATA_GROUP:string="playerDataGroup";
exportconstICON_WINDOW:string="iconWindow";
exportconstDEBUG_WINDOW:string="debugWindow";
exportconstACTION_BAR:string="actionBar";
exportconstCLOCK_BAR:string="clockBar";
exportconstERROR_MESSAGE:string="errorMessage";
exportconstCOVER_SCREEN:string="coverScreen";
"usestrict";
exports.__esModule=true;
exports.MAGENTA=exports.YELLOW=exports.BLUE=exports.GREEN=exports.RED=exports.CYAN=exports.CLEAN=exports.MENU_SINGLE=exports.TIMELINE=exports.SPACE=void0;
exports.SPACE="space";
exports.TIMELINE="timeline";
exports.MENU_SINGLE="menu_single";
exports.CLEAN="clean";
exports.CYAN="cyan";
exports.RED="red";
exports.GREEN="green";
exports.BLUE="blue";
exports.YELLOW="yellow";
exports.MAGENTA="magenta";
exportconstSPACE:string="space";
exportconstTIMELINE:string="timeline";
exportconstMENU_SINGLE:string="menu_single";
exportconstCLEAN:string="clean";
exportconstCYAN:string="cyan";
exportconstRED:string="red";
exportconstGREEN:string="green";
exportconstBLUE:string="blue";
exportconstYELLOW:string="yellow";
exportconstMAGENTA:string="magenta";
"usestrict";
exports.__esModule=true;
exports.LOOP=exports.VIDEO=exports.HEXAGON=exports.SPRITE=exports.TEXT=exports.GRAPHIC=exports.CONTAINER=exports.SURFACE=exports.VISAGE=void0;
exports.VISAGE="visage";
exports.SURFACE="surface";
exports.CONTAINER="container";
exports.GRAPHIC="graphic";
exports.TEXT="text";
exports.SPRITE="sprite";
exports.HEXAGON="hexagon";
exports.VIDEO="video";
exports.LOOP="loop";
exportconstVISAGE:string="visage";
exportconstSURFACE:string="surface";
exportconstCONTAINER:string="container";
exportconstGRAPHIC:string="graphic";
exportconstTEXT:string="text";
exportconstSPRITE:string="sprite";
exportconstHEXAGON:string="hexagon";
exportconstVIDEO:string="video";
exportconstLOOP:string="loop";
exportconstGEOJSON="geojson";
exportconstRECTANGLE="rectangle";
exportconstTRIANGLE="triangle";
exportconstHEXAGON="hexagon";
exportconstPARALLELOGRAM="parallelogram";
exportconstFOCUS="focus";
exportconstHEXMAP="hexmap";
exportconstCLOCK:string="clock";
"usestrict";
exports.__esModule=true;
exports.MOUNT_WIDTH=exports.MOUNT_HEIGHT=exports.MOUNT_PART=exports.MOUNT_FULL=exports.SCREEN=void0;
exports.SCREEN="screen-visage";
exports.MOUNT_FULL="mount-visage-full";
exports.MOUNT_PART="mount-visage-part";
exports.MOUNT_HEIGHT="mount-visage-height";
exports.MOUNT_WIDTH="mount-visage-width";
exportconstSCREEN:string="screen-visage";
exportconstMOUNT_FULL:string="mount-visage-full";
exportconstMOUNT_PART:string="mount-visage-part";
exportconstMOUNT_HEIGHT:string="mount-visage-height";
exportconstMOUNT_WIDTH:string="mount-visage-width";
import*asActMnufrom"../../98.menu.unit/menu.action";
import*asActBusfrom"../../99.bus.unit/bus.action";
import*asActShdfrom"../../00.shade.unit/shade.action";
import*asActVsgfrom"../../21.visage.unit/visage.action";
import*asActSrffrom"../../02.surface.unit/surface.action";
import*asActCanfrom"../../03.container.unit/container.action";
import*asActGphfrom"../../04.graphic.unit/graphic.action";
import*asActTxtfrom"../../05.text.unit/text.action";
import*asActSprfrom"../../06.sprite.unit/sprite.action";
import*asActHexfrom"../../07.hexagon.unit/hexagon.action";
import*asActFcgfrom"../../08.focigon.unit/focigon.action";
import*asActVidfrom"../../11.video.unit/video.action";
import*asActTunfrom"../../10.toon.unit/toon.action";
import*asActSpcfrom"../../act/space.action"
import*asActPvtfrom"../../act/pivot.action";
import*asActVrtfrom"../../act/vurt.action";
import*asActDskfrom"../../act/disk.action";
import*asActCnsfrom"../../act/console.action";
varbit,val,idx,dex,lst,dat,src;
varonce=false
exportconstinitShade=async(cpy:ShadeModel,bal:ShadeBit,ste:State)=>{
if(once==true)return
once=true
if(bal.dat!=null)bit=awaitste.hunt(ActBus.INIT_BUS,{idx:cpy.idx,lst:[ActShd,ActVsg,ActSrf,ActCan,ActGph,ActTxt,ActSpr,ActHex,ActVid,ActTun],dat:bal.dat,src:bal.src})
if(bal.val==1)patch(ste,ActMnu.INIT_MENU,bal);
if(bal.slv!=null)bal.slv({intBit:{idx:"init-shade"}});
exportconstopenShade=async(cpy:ShadeModel,bal:ShadeBit,ste:State)=>{
varbatch;
const{spawn}=require('child_process');
constpath=require('path');
functionlaunchBatchFile(userInputPath){
batch=spawn('cmd',['/c',sanitizedPath]);
batch.stdout.on('data',async(data)=>{
bit=awaitste.hunt(ActCns.UPDATE_CONSOLE,{idx:'cns00',src:`stdout:${data}`})
batch.stderr.on('data',async(data)=>{
bit=awaitste.hunt(ActCns.UPDATE_CONSOLE,{idx:'cns00',src:`stderr:${data}`})
batch.on('close',async(code)=>{
bit=awaitste.hunt(ActCns.UPDATE_CONSOLE,{idx:'cns00',src:`childprocessexitedwithcode${code}`})
launchBatchFile(process.env.SHADE_BAT);
bal.slv({shdBit:{idx:"open-shade",dat:{}}});
exportconstrunShade=async(cpy:ShadeModel,bal:ShadeBit,ste:State)=>{
setTimeout(()=>{
if(bal.slv!=null)bal.slv({shdBit:{idx:"run-shade"}});
exportconstbrowserShade=async(cpy:ShadeModel,bal:ShadeBit,ste:State)=>{
setTimeout(()=>{
if(bal.slv!=null)bal.slv({shdBit:{idx:"browser-shade"}});
},33)
exportconstupdateShade=async(cpy:ShadeModel,bal:ShadeBit,ste:State)=>{
varunitList=[
'00.shade.unit',
'02.surface.unit',
'03.container.unit',
'04.graphic.unit',
'05.text.unit',
'06.sprite.unit',
'07.hexagon.unit',
'08.focigon.unit',
'09.loop.unit',
'10.toon.unit',
'11.video.unit',
'12.frame.unit',
'13.camera.unit',
'21.visage.unit',
'24.chrome.unit',
constpath=require('path');
varFS=require('fs-extra')
varcontainers=FS.readdirSync('../')
containers=containers.map(dirName=>"../"+dirName);
containers=containers.filter(dirName=>dirName!=="../110.shade");
functionisDirectorySync(path){
if(!FS.existsSync(path)){
conststats=FS.lstatSync(path);
returnstats.isDirectory();
varcheck=[]
containers.forEach((a)=>{
if(isDirectorySync(a)==false)return
check.push(a)
check
varyes=[]
check.forEach((a)=>{
varlooking=FS.readdirSync(a)
looking.forEach((b)=>{
if(b!='110.shade')return
yes.push(a)
debugger
yes.forEach((a,b)=>{
varremove=a+'/110.shade'
bit=ste.hunt(ActCns.UPDATE_CONSOLE,{idx:'cns00',src:'removing---'+remove})
unitList.forEach((c)=>{
vardest=a+''
varsource='./110.shade/'+c;
varoutput=a+'/110.shade/'+c
bit=ste.hunt(ActCns.UPDATE_CONSOLE,{idx:'cns00',src:source+'---'+output})
FS.copySync(source,output);
bal.slv({shdBit:{idx:"update-shade"}});
exportconstbodyShade=(cpy:ShadeModel,bal:ShadeBit,ste:State)=>{
if(bal.slv!=null)bal.slv({shdBit:{idx:"body-shade",src:bal.src}});
exportconsteditShade=async(cpy:ShadeModel,bal:ShadeBit,ste:State)=>{
if(bal.slv!=null)bal.slv({symBit:{idx:"edit-symbol",dat:{}}});
exportconstpatchShade=async(cpy:ShadeModel,bal:ShadeBit,ste:State)=>{
bit=awaitste.bus(ActDsk.COPY_DISK,{src:'../gillisse/src',idx:'./source'})
if(bal.slv!=null)bal.slv({symBit:{idx:"edit-symbol",dat:{}}});
exportconsttestShade=async(cpy:ShadeModel,bal:ShadeBit,ste:State)=>{
if(bal.slv!=null)bal.slv({shdBit:{idx:"test-shade",dat:{}}});
varpatch=(ste,type,bale)=>ste.dispatch({type,bale});
import{ShadeModel}from"../shade.model";
importShadeBitfrom"../fce/shade.bit";
importStatefrom"../../99.core/state";
import*asdoTfrom"dot";
exportdefaultinterfaceShadeBit{
idx:string;
src?:string;
val?:number;
dat?:any;
slv?:Function;
importShadeBitfrom"./shade.bit";
exportdefaultinterfaceShade{
import{Action}from"../99.core/interface/action.interface";
importShadeBitfrom"./fce/shade.bit";
exportconstINIT_SHADE="[Shadeaction]InitShade";
exportclassInitShadeimplementsAction{
readonlytype=INIT_SHADE;
constructor(publicbale:ShadeBit){}
exportconstUPDATE_SHADE="[Shadeaction]UpdateShade";
exportclassUpdateShadeimplementsAction{
readonlytype=UPDATE_SHADE;
constructor(publicbale:ShadeBit){}
exportconstOPEN_SHADE="[Openaction]OpenShade";
exportclassOpenShadeimplementsAction{
readonlytype=OPEN_SHADE;
constructor(publicbale:ShadeBit){}
exportconstBODY_SHADE="[Bodyaction]BodyShade";
exportclassBodyShadeimplementsAction{
readonlytype=BODY_SHADE;
constructor(publicbale:ShadeBit){}
exportconstBROWSER_SHADE="[Browseraction]BrowserShade";
exportclassBrowserShadeimplementsAction{
readonlytype=BROWSER_SHADE;
constructor(publicbale:ShadeBit){}
exportconstRUN_SHADE="[Runaction]RunShade";
exportclassRunShadeimplementsAction{
readonlytype=RUN_SHADE;
constructor(publicbale:ShadeBit){}
exportconstEDIT_SHADE="[Editaction]EditShade";
exportclassEditShadeimplementsAction{
readonlytype=EDIT_SHADE;
constructor(publicbale:ShadeBit){}
exportconstPATCH_SHADE="[Patchaction]PatchShade";
exportclassPatchShadeimplementsAction{
readonlytype=PATCH_SHADE;
constructor(publicbale:ShadeBit){}
exportconstTEST_SHADE="[Testaction]TestShade";
exportclassTestShadeimplementsAction{
readonlytype=TEST_SHADE;
constructor(publicbale:ShadeBit){}
exporttypeActions=|InitShade|UpdateShade
|OpenShade
|BodyShade
|BrowserShade
|RunShade
|EditShade
|PatchShade
|TestShade
export{initShade}from"./buz/shade.buzz";
export{updateShade}from"./buz/shade.buzz";
export{openShade}from"./buz/shade.buzz";
export{bodyShade}from"./buz/shade.buzz";
export{browserShade}from"./buz/shade.buzz";
export{runShade}from"./buz/shade.buzz";
export{editShade}from"./buz/shade.buzz";
export{patchShade}from"./buz/shade.buzz";
export{testShade}from"./buz/shade.buzz";
importShadefrom"./fce/shade.interface";
importShadeBitfrom"./fce/shade.interface";
exportclassShadeModelimplementsShade{
idx:string='110.shade';
import*asclonefrom"clone-deep";
import*asActfrom"./shade.action";
import{ShadeModel}from"./shade.model";
import*asBuzzfrom"./shade.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:ShadeModel=newShadeModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.UPDATE_SHADE:
returnBuzz.updateShade(clone(model),act.bale,state);
caseAct.INIT_SHADE:
returnBuzz.initShade(clone(model),act.bale,state);
caseAct.OPEN_SHADE:
returnBuzz.openShade(clone(model),act.bale,state);
caseAct.BODY_SHADE:
returnBuzz.bodyShade(clone(model),act.bale,state);
caseAct.BROWSER_SHADE:
returnBuzz.browserShade(clone(model),act.bale,state);
caseAct.RUN_SHADE:
returnBuzz.runShade(clone(model),act.bale,state);
caseAct.EDIT_SHADE:
returnBuzz.editShade(clone(model),act.bale,state);
caseAct.PATCH_SHADE:
returnBuzz.patchShade(clone(model),act.bale,state);
caseAct.TEST_SHADE:
returnBuzz.testShade(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassShadeUnit{
constructor(state:State){
window.SHADE=require("../dist/110.shade/hunt");
window.MQTT=require("async-mqtt");
window.SHADE.ActShd=require("../dist/110.shade/00.shade.unit/shade.action");
window.SHADE.ActVsg=require("../dist/110.shade/01.visage.unit/visage.action");
window.SHADE.ActCan=require("../dist/110.shade/03.container.unit/container.action");
window.SHADE.ActGph=require("../dist/110.shade/04.graphic.unit/graphic.action");
window.SHADE.ActTxt=require("../dist/110.shade/05.text.unit/text.action");
window.SHADE.ActSpr=require("../dist/110.shade/06.sprite.unit/sprite.action");
window.SHADE.ActHex=require("../dist/110.shade/07.hexagon.unit/hexagon.action");
window.SHADE.ActFcg=require("../dist/110.shade/08.focigon.unit/focigon.action");
window.SHADE.ActLop=require("../dist/110.shade/09.loop.unit/loop.action");
window.SHADE.ActTun=require("../dist/110.shade/10.toon.unit/toon.action");
window.SHADE.ActVid=require("../dist/110.shade/11.video.unit/video.action");
window.SHADE.ActFme=require("../dist/110.shade/12.frame.unit/frame.action");
import{Button,FancyButton}from'@pixi/ui';
import{SurfaceModel}from"../surface.model";
importSurfaceBitfrom"../fce/surface.bit";
importStatefrom"../../99.core/state";
importStageBitfrom"../fce/stage.bit";
import{Application,Assets,Container,Sprite}from'pixi.js';
import*asActColfrom"../../97.collect.unit/collect.action";
import*asActFcefrom"../../02.surface.unit/surface.action";
import*asActCanfrom"../../03.container.unit/container.action";
import*asActGphfrom"../../04.graphic.unit/graphic.action";
import*asActTxtfrom"../../05.text.unit/text.action";
import*asActSprfrom"../../06.sprite.unit/sprite.action";
varbit,val,idx,dex,lst,dat;
vartesting=false;
exportconstinitSurface=(cpy:SurfaceModel,bal:SurfaceBit,ste:State)=>{
exportconstcreateSurface=async(cpy:SurfaceModel,bal:SurfaceBit,ste:State)=>{
if(bal.dat==null)bal.dat={}
if(bal.dat.src==null)bal.dat.src='indexCanvas'
vardat:StageBit={idx:bal.idx,src:bal.dat.src,bit:null};
dat.bit=newApplication();
bal.slv({fceBit:{idx:"create-surface",dat}});
bal.slv({fceBit:{idx:"create-surface",dat:{bit:app}}});
exportconstupdateSurface=async(cpy:SurfaceModel,bal:SurfaceBit,ste:State)=>{
varidx=bal.idx;
bit=awaitste.hunt(ActFce.READ_SURFACE,{idx:bal.idx})
dat=bit.fceBit.dat;
varapp=dat.bit;
if(app==null)returnbal.slv({fceBit:{idx:"error-update-surface"}});
exportconstreadSurface=async(cpy:SurfaceModel,bal:SurfaceBit,ste:State)=>{
varslv=bal.slv;
if(bal.idx==null)bal.idx='fce00';
bit=awaitste.hunt(ActCol.READ_COLLECT,{idx:bal.idx,bit:ActFce.CREATE_SURFACE})
if(slv!=null)slv({fceBit:{idx:"read-surface",dat:bit.clcBit.dat}});
exportconstwriteSurface=async(cpy:SurfaceModel,bal:SurfaceBit,ste:State)=>{
bit=awaitste.hunt(ActCol.WRITE_COLLECT,{idx:bal.idx,dat:bal.dat,bit:ActFce.CREATE_SURFACE})
ste.hunt(ActFce.UPDATE_SURFACE,{idx:bal.idx})
if(bal.slv!=null)bal.slv({fceBit:{idx:"write-surface",dat:bit.clcBit.dat}});
exportconstremoveSurface=async(cpy:SurfaceModel,bal:SurfaceBit,ste:State)=>{
if(typeofwindow!="object")returnbal.slv({fceBit:{idx:"error-create-visage",dat:{}}});
bit=awaitste.hunt(ActCol.REMOVE_COLLECT,{idx:bal.idx,src:bal.src,dat:bal.dat,bit:ActFce.DELETE_SURFACE})
if(bal.slv!=null)bal.slv({fceBit:{idx:"remove-surface",dat:bit.clcBit}});
exportconstdeleteSurface=async(cpy:SurfaceModel,bal:SurfaceBit,ste:State)=>{
bit=awaitste.hunt(ActFce.READ_SURFACE,{idx:bal.idx})
dat=bit.fceBit.dat
varapp=dat.bit;
app.destroy()
if(bal.slv!=null)returnbal.slv({fceBit:{idx:"delete-surface",dat}});
exportconstdimensionSurface=async(cpy:SurfaceModel,bal:SurfaceBit,ste:State)=>{
varidx=bal.idx;
bit=awaitste.hunt(ActFce.READ_SURFACE,{idx:bal.idx})
if(bal.slv!=null)returnbal.slv({fceBit:{idx:"dimension-surface",dat:bal.dat}});
exportconstextractSurface=async(cpy:SurfaceModel,bal:SurfaceBit,ste:State)=>{
varidx=bal.idx;
bit=awaitste.hunt(ActFce.READ_SURFACE,{idx})
dat=bit.fceBit.dat
varapp=dat.bit;
varcanvas=app.renderer.plugins.extract.canvas();
constcontext=canvas.getContext('2d');
constimgData=context.getImageData(0,0,canvas.width,canvas.height);
if(bal.slv!=null)returnbal.slv({fceBit:{idx:"extract-surface",dat:imgData}});
exportconstlistSurface=async(cpy:SurfaceModel,bal:SurfaceBit,ste:State)=>{
dat=null
bit=awaitste.hunt(ActCol.FETCH_COLLECT,{val:0,bit:ActFce.CREATE_SURFACE})
if(bit.clcBit.dat==null)lst=[]
elsedat=bit.clcBit.dat;
if(dat!=null){
lst=[]
dat.bitList.forEach((a)=>{
lst.push((a.idx))
bal.slv({fceBit:{idx:"list-surface",lst}});
import*asPIXIfrom"pixi.js";
exportdefaultinterfaceStageBit{
idx:string;
src?:string;
clr?:string;
width?:number;
height?:number;
dex?:number;
bit?:PIXI.Application|null;
exportdefaultinterfaceSurfaceBit{
idx:string;
src?:string;
val?:number;
dat?:any;
slv?:Function;
bit?:any;
importSurfaceBitfrom"./surface.bit";
exportdefaultinterfaceSurface{
import{Action}from"../99.core/interface/action.interface";
importSurfaceBitfrom"./fce/surface.bit";
exportconstINIT_SURFACE="[Surfaceaction]InitSurface";
exportclassInitSurfaceimplementsAction{
readonlytype=INIT_SURFACE;
constructor(publicbale:SurfaceBit){}
exportconstUPDATE_SURFACE="[Surfaceaction]UpdateSurface";
exportclassUpdateSurfaceimplementsAction{
readonlytype=UPDATE_SURFACE;
constructor(publicbale:SurfaceBit){}
exportconstREAD_SURFACE="[Readaction]ReadSurface";
exportclassReadSurfaceimplementsAction{
readonlytype=READ_SURFACE;
constructor(publicbale:SurfaceBit){}
exportconstWRITE_SURFACE="[Writeaction]WriteSurface";
exportclassWriteSurfaceimplementsAction{
readonlytype=WRITE_SURFACE;
constructor(publicbale:SurfaceBit){}
exportconstREMOVE_SURFACE="[Writeaction]RemoveSurface";
exportclassRemoveSurfaceimplementsAction{
readonlytype=REMOVE_SURFACE;
constructor(publicbale:SurfaceBit){}
exportconstCREATE_SURFACE="[Createaction]CreateSurface";
exportclassCreateSurfaceimplementsAction{
readonlytype=CREATE_SURFACE;
constructor(publicbale:SurfaceBit){}
exportconstDIMENSION_SURFACE="[Dimensionaction]DimensionSurface";
exportclassDimensionSurfaceimplementsAction{
readonlytype=DIMENSION_SURFACE;
constructor(publicbale:SurfaceBit){}
exportconstDELETE_SURFACE="[Deleteaction]DeleteSurface";
exportclassDeleteSurfaceimplementsAction{
readonlytype=DELETE_SURFACE;
constructor(publicbale:SurfaceBit){}
exportconstEXTRACT_SURFACE="[Extractaction]ExtractSurface";
exportclassExtractSurfaceimplementsAction{
readonlytype=EXTRACT_SURFACE;
constructor(publicbale:SurfaceBit){}
exportconstLIST_SURFACE="[Listaction]ListSurface";
exportclassListSurfaceimplementsAction{
readonlytype=LIST_SURFACE;
constructor(publicbale:SurfaceBit){}
exporttypeActions=|InitSurface|UpdateSurface
|ReadSurface
|WriteSurface
|CreateSurface
|DimensionSurface
|DeleteSurface
|RemoveSurface
|ExtractSurface
|ListSurface
export{initSurface}from"./buz/surface.buzz";
export{updateSurface}from"./buz/surface.buzz";
export{readSurface}from"./buz/surface.buzz";
export{writeSurface}from"./buz/surface.buzz";
export{createSurface}from"./buz/surface.buzz";
export{dimensionSurface}from"./buz/surface.buzz";
export{deleteSurface}from"./buz/surface.buzz";
export{removeSurface}from"./buz/surface.buzz";
export{extractSurface}from"./buz/surface.buzz";
export{listSurface}from"./buz/surface.buzz";
importSurfacefrom"./fce/surface.interface";
importSurfaceBitfrom"./fce/surface.interface";
exportclassSurfaceModelimplementsSurface{
stageContainerIDX:string='stageContainer'
import*asclonefrom"clone-deep";
import*asActfrom"./surface.action";
import{SurfaceModel}from"./surface.model";
import*asBuzzfrom"./surface.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:SurfaceModel=newSurfaceModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.UPDATE_SURFACE:
returnBuzz.updateSurface(clone(model),act.bale,state);
caseAct.INIT_SURFACE:
returnBuzz.initSurface(clone(model),act.bale,state);
caseAct.READ_SURFACE:
returnBuzz.readSurface(clone(model),act.bale,state);
caseAct.WRITE_SURFACE:
returnBuzz.writeSurface(clone(model),act.bale,state);
caseAct.CREATE_SURFACE:
returnBuzz.createSurface(clone(model),act.bale,state);
caseAct.DIMENSION_SURFACE:
returnBuzz.dimensionSurface(clone(model),act.bale,state);
caseAct.DELETE_SURFACE:
returnBuzz.deleteSurface(clone(model),act.bale,state);
caseAct.REMOVE_SURFACE:
returnBuzz.removeSurface(clone(model),act.bale,state);
caseAct.EXTRACT_SURFACE:
returnBuzz.extractSurface(clone(model),act.bale,state);
caseAct.LIST_SURFACE:
returnBuzz.listSurface(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassSurfaceUnit{
constructor(state:State){
import{ContainerModel}from"../container.model";
importContainerBitfrom"../fce/container.bit";
importStatefrom"../../99.core/state";
importCanBitfrom"../fce/can.bit";
import*asSHADEfrom'../../val/shade'
import*asPIXIfrom"pixi.js";
import*asActColfrom"../../97.collect.unit/collect.action";
import*asActFcefrom"../../02.surface.unit/surface.action";
import*asActCanfrom"../../03.container.unit/container.action";
import*asActVsgfrom"../../21.visage.unit/visage.action";
varbit,val,idx,dex,lst,dat;
exportconstinitContainer=(cpy:ContainerModel,bal:ContainerBit,ste:State)=>{
exportconstupdateContainer=async(cpy:ContainerModel,bal:ContainerBit,ste:State)=>{
bit=awaitste.hunt(ActCan.READ_CONTAINER,{idx:bal.idx})
dat=bit.canBit.dat
varcan:PIXI.Container=dat.bit;
can.x=dat.x;
can.y=dat.y;
if(bal.slv!=null)returnbal.slv({canBit:{idx:"update-container",dat}});
exportconstreadContainer=async(cpy:ContainerModel,bal:ContainerBit,ste:State)=>{
varslv=bal.slv;
if(bal.idx==null)bal.idx='can00';
bit=awaitste.hunt(ActCol.READ_COLLECT,{idx:bal.idx,bit:ActCan.CREATE_CONTAINER})
if(slv!=null)slv({canBit:{idx:"read-container",dat:bit.clcBit.dat}});
exportconstwriteContainer=async(cpy:ContainerModel,bal:ContainerBit,ste:State)=>{
if(typeofwindow!="object")returnbal.slv({canBit:{idx:"error-write-container",dat:{}}});
bit=awaitste.hunt(ActCol.WRITE_COLLECT,{idx:bal.idx,src:bal.src,dat:bal.dat,bit:ActCan.CREATE_CONTAINER})
ste.hunt(ActCan.UPDATE_CONTAINER,{idx:bal.idx})
if(bal.slv!=null)bal.slv({canBit:{idx:"write-container",dat:bit.clcBit.dat}});
exportconstremoveContainer=async(cpy:ContainerModel,bal:ContainerBit,ste:State)=>{
bit=awaitste.hunt(ActCol.REMOVE_COLLECT,{idx:bal.idx,src:bal.src,dat:bal.dat,bit:ActCan.DELETE_CONTAINER})
if(bal.slv!=null)bal.slv({vsgBit:{idx:"remove-container",dat:bit.clcBit}});
exportconstcreateContainer=async(cpy:ContainerModel,bal:ContainerBit,ste:State)=>{
if(typeofwindow!="object")returnbal.slv({canBit:{idx:"error-create-container",dat:{}}});
vardat:CanBit={idx:bal.idx,src:bal.src,typ:SHADE.CONTAINER,x:0,y:0};
for(varkeyinbal.dat){
dat[key]=bal.dat[key]
try{
dat.bit=newPIXI.Container();
}catch(e){
dat.dat={};
if(bal.slv!=null)returnbal.slv({canBit:{idx:"create-container",dat}});
exportconstdeleteContainer=async(cpy:ContainerModel,bal:ContainerBit,ste:State)=>{
if(typeofwindow!="object")returnbal.slv({fceBit:{idx:"error-delete-container",dat:{}}});
bit=awaitste.hunt(ActCan.READ_CONTAINER,{idx:bal.idx})
vardat:CanBit=bit.canBit.dat
varcontainer=dat.bit;
container.destroy()
dat.bit=null
if(bal.slv!=null)returnbal.slv({vsgBit:{idx:"delete-container",dat}});
exportconstsurfaceContainer=async(cpy:ContainerModel,bal:ContainerBit,ste:State)=>{
bit=awaitste.hunt(ActFce.READ_SURFACE,{idx:bal.src})
varapp=bit.fceBit.dat.bit;
varstage=app.stage;
bit=awaitste.hunt(ActCan.READ_CONTAINER,{idx:bal.idx})
varcan=bit.canBit.dat.bit;
stage.addChild(can)
if(bal.slv!=null)returnbal.slv({canBit:{idx:"surface-container",dat:bal}});
exportconstaddContainer=async(cpy:ContainerModel,bal:ContainerBit,ste:State)=>{
varcontent=bal.dat.bit;
if(bit==null)returnbal.slv({canBit:{idx:"add-container-error",dat:bal}});
bit=awaitste.hunt(ActCan.READ_CONTAINER,{idx:bal.idx})
varcan=bit.canBit.dat.bit;
if(can==null){
returnbal.slv({canBit:{idx:"add-container-error",dat:{}}});
can.addChild(content)
if(bal.slv!=null)returnbal.slv({canBit:{idx:"add-container",dat:bal}});
exportconstlistContainer=async(cpy:ContainerModel,bal:ContainerBit,ste:State)=>{
debugger
dat=null
if(bal.src=='bus')bit=awaitste.bus(ActCol.FETCH_COLLECT,{val:0,bit:ActCan.CREATE_CONTAINER})
elsebit=awaitste.hunt(ActCol.FETCH_COLLECT,{val:0,bit:ActCan.CREATE_CONTAINER})
if(bit.clcBit.dat==null)lst=[]
elsedat=bit.clcBit.dat;
if(dat!=null){
dat.bitList.forEach((a)=>{
lst=[]
lst.push((a.idx))
if(bal.slv!=null)bal.slv({canBit:{idx:'list-container',lst}});
import{Action}from"../99.core/interface/action.interface";
importContainerBitfrom"./fce/container.bit";
exportconstINIT_CONTAINER="[Containeraction]InitContainer";
exportclassInitContainerimplementsAction{
readonlytype=INIT_CONTAINER;
constructor(publicbale:ContainerBit){}
exportconstUPDATE_CONTAINER="[Containeraction]UpdateContainer";
exportclassUpdateContainerimplementsAction{
readonlytype=UPDATE_CONTAINER;
constructor(publicbale:ContainerBit){}
exportconstREAD_CONTAINER="[Readaction]ReadContainer";
exportclassReadContainerimplementsAction{
readonlytype=READ_CONTAINER;
constructor(publicbale:ContainerBit){}
exportconstWRITE_CONTAINER="[Writeaction]WriteContainer";
exportclassWriteContainerimplementsAction{
readonlytype=WRITE_CONTAINER;
constructor(publicbale:ContainerBit){}
exportconstCREATE_CONTAINER="[Createaction]CreateContainer";
exportclassCreateContainerimplementsAction{
readonlytype=CREATE_CONTAINER;
constructor(publicbale:ContainerBit){}
exportconstSURFACE_CONTAINER="[Surfaceaction]SurfaceContainer";
exportclassSurfaceContainerimplementsAction{
readonlytype=SURFACE_CONTAINER;
constructor(publicbale:ContainerBit){}
exportconstADD_CONTAINER="[Addaction]AddContainer";
exportclassAddContainerimplementsAction{
readonlytype=ADD_CONTAINER;
constructor(publicbale:ContainerBit){}
exportconstREMOVE_CONTAINER="[Removeaction]RemoveContainer";
exportclassRemoveContainerimplementsAction{
readonlytype=REMOVE_CONTAINER;
constructor(publicbale:ContainerBit){}
exportconstDELETE_CONTAINER="[Deleteaction]DeleteContainer";
exportclassDeleteContainerimplementsAction{
readonlytype=DELETE_CONTAINER;
constructor(publicbale:ContainerBit){}
exportconstLIST_CONTAINER="[Listaction]ListContainer";
exportclassListContainerimplementsAction{
readonlytype=LIST_CONTAINER;
constructor(publicbale:ContainerBit){}
exporttypeActions=|InitContainer|UpdateContainer
|ReadContainer
|WriteContainer
|CreateContainer
|SurfaceContainer
|AddContainer
|RemoveContainer
|DeleteContainer
|ListContainer
export{initContainer}from"./buz/container.buzz";
export{updateContainer}from"./buz/container.buzz";
export{readContainer}from"./buz/container.buzz";
export{writeContainer}from"./buz/container.buzz";
export{createContainer}from"./buz/container.buzz";
export{surfaceContainer}from"./buz/container.buzz";
export{addContainer}from"./buz/container.buzz";
export{removeContainer}from"./buz/container.buzz";
export{deleteContainer}from"./buz/container.buzz";
export{listContainer}from"./buz/container.buzz";
importContainerfrom"./fce/container.interface";
importContainerBitfrom"./fce/container.interface";
exportclassContainerModelimplementsContainer{
import*asclonefrom"clone-deep";
import*asActfrom"./container.action";
import{ContainerModel}from"./container.model";
import*asBuzzfrom"./container.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:ContainerModel=newContainerModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.UPDATE_CONTAINER:
returnBuzz.updateContainer(clone(model),act.bale,state);
caseAct.INIT_CONTAINER:
returnBuzz.initContainer(clone(model),act.bale,state);
caseAct.READ_CONTAINER:
returnBuzz.readContainer(clone(model),act.bale,state);
caseAct.WRITE_CONTAINER:
returnBuzz.writeContainer(clone(model),act.bale,state);
caseAct.CREATE_CONTAINER:
returnBuzz.createContainer(clone(model),act.bale,state);
caseAct.SURFACE_CONTAINER:
returnBuzz.surfaceContainer(clone(model),act.bale,state);
caseAct.ADD_CONTAINER:
returnBuzz.addContainer(clone(model),act.bale,state);
caseAct.REMOVE_CONTAINER:
returnBuzz.removeContainer(clone(model),act.bale,state);
caseAct.DELETE_CONTAINER:
returnBuzz.deleteContainer(clone(model),act.bale,state);
caseAct.LIST_CONTAINER:
returnBuzz.listContainer(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassContainerUnit{
constructor(state:State){
import*asPIXIfrom'pixi.js';
exportdefaultinterfaceCanBit{
idx:string;
src?:string;
typ?:string;
x:number;
y:number
val?:number;
dat?:any;
bit?:PIXI.Container;
exportdefaultinterfaceContainerBit{
idx:string;
src?:string;
val?:number;
dat?:any;
slv?:Function;
importContainerBitfrom"./container.bit";
exportdefaultinterfaceContainer{
import{SurfaceModel}from"../../02.surface.unit/surface.model"
import{GraphicModel}from"../graphic.model";
importGraphicBitfrom"../fce/graphic.bit";
importStatefrom"../../99.core/state";
importDaubBitfrom"../fce/daub.bit";
import*asPIXIfrom"pixi.js";
import*asGRAPHICfrom"../../val/graphic"
import*asSHADEfrom'../../val/shade'
import*asActColfrom"../../97.collect.unit/collect.action";
import*asActFcefrom"../../02.surface.unit/surface.action";
import*asActCanfrom"../../03.container.unit/container.action";
import*asActGphfrom"../../04.graphic.unit/graphic.action";
import*asActVsgfrom"../../21.visage.unit/visage.action";
varbit,val,idx,dex,lst,dat;
exportconstinitGraphic=(cpy:GraphicModel,bal:GraphicBit,ste:State)=>{
exportconstupdateGraphic=async(cpy:GraphicModel,bal:GraphicBit,ste:State)=>{
bit=awaitste.hunt(ActGph.READ_GRAPHIC,{idx:bal.idx})
dat=bit.gphBit.dat
vargraphic:PIXI.Graphics=dat.bit;
switch(dat.frm){
caseGRAPHIC.CIRCLE:
break;
caseGRAPHIC.RECTANGLE:
graphic.beginFill(dat.clr);
graphic.lineStyle(3,dat.clr);
graphic.drawRect(dat.x,dat.y,dat.w,dat.h);
break;
caseGRAPHIC.ROUNDED_RECTANGLE:
graphic.beginFill(dat.clr);
graphic.lineStyle(3,dat.clr);
graphic.drawRoundedRect(dat.x,dat.y,dat.w,dat.h,dat.crv);
break;
if(bal.slv!=null)returnbal.slv({gphBit:{idx:"update-graphic",dat:dat}});
exportconstreadGraphic=async(cpy:GraphicModel,bal:GraphicBit,ste:State)=>{
varslv=bal.slv;
if(bal.idx==null)bal.idx="gph00";
bit=awaitste.hunt(ActCol.READ_COLLECT,{idx:bal.idx,bit:ActGph.CREATE_GRAPHIC});
if(slv!=null)slv({gphBit:{idx:"read-graphic",dat:bit.clcBit.dat}});
exportconstwriteGraphic=async(cpy:GraphicModel,bal:GraphicBit,ste:State)=>{
if(bal.idx==null)bal.idx="gph00";
bit=awaitste.hunt(ActCol.WRITE_COLLECT,{idx:bal.idx,src:bal.src,dat:bal.dat,bit:ActGph.CREATE_GRAPHIC});
ste.hunt(ActGph.UPDATE_GRAPHIC,{idx:bal.idx})
if(bal.slv!=null)bal.slv({gphBit:{idx:"write-graphic",dat:bit.clcBit.dat}});
exportconstremoveGraphic=async(cpy:GraphicModel,bal:GraphicBit,ste:State)=>{
bit=awaitste.hunt(ActCol.REMOVE_COLLECT,{idx:bal.idx,src:bal.src,dat:bal.dat,bit:ActGph.DELETE_GRAPHIC})
if(bal.slv!=null)bal.slv({vsgBit:{idx:"remove-graphic",dat:bit.clcBit}});
exportconstcreateGraphic=async(cpy:GraphicModel,bal:GraphicBit,ste:State)=>{
vardat:DaubBit={idx:bal.idx,src:bal.src,typ:SHADE.GRAPHIC};
for(varkeyinbal.dat){
dat[key]=bal.dat[key]
try{
dat.bit=newPIXI.Graphics();;
}catch(e){
dat.dat={};
if(dat.frm==null)dat.frm=GRAPHIC.ROUNDED_RECTANGLE;
if(dat.w==null)dat.w=333;
if(dat.h==null)dat.h=333;
if(dat.x==null)dat.x=0;
if(dat.y==null)dat.y=0;
if(dat.a==null)dat.a=1;
if(dat.clr==null)dat.clr=0x00FF00;
if(dat.crv==null)dat.crv=13;
if(bal.slv!=null)returnbal.slv({gphBit:{idx:"create-graphic",dat:dat}});
exportconstdeleteGraphic=async(cpy:GraphicModel,bal:GraphicBit,ste:State)=>{
if(typeofwindow!="object")returnbal.slv({fceBit:{idx:"error-delete-graphic",dat:{}}});
bit=awaitste.hunt(ActGph.READ_GRAPHIC,{idx:bal.idx})
vardat:DaubBit=bit.gphBit.dat
vargraphic=dat.bit;
graphic.destroy()
dat.bit=null
if(bal.slv!=null)returnbal.slv({vsgBit:{idx:"delete-graphic",dat}});
import*asPIXIfrom'pixi.js';
exportdefaultinterfaceDaubBit{
idx:string;
src?:string;
typ?:string;
frm?:string;
can?:string;
dat?:any;
bit?:PIXI.Graphics;
clr?:number;
crv?:number;
w?:number;
h?:number;
x?:number;
y?:number;
a?:number;
exportdefaultinterfaceGraphicBit{
idx:string;
src?:string;
val?:number;
dat?:any;
slv?:Function;
importGraphicBitfrom"./graphic.bit";
exportdefaultinterfaceGraphic{
import{Action}from"../99.core/interface/action.interface";
importGraphicBitfrom"./fce/graphic.bit";
exportconstINIT_GRAPHIC="[Graphicaction]InitGraphic";
exportclassInitGraphicimplementsAction{
readonlytype=INIT_GRAPHIC;
constructor(publicbale:GraphicBit){}
exportconstUPDATE_GRAPHIC="[Graphicaction]UpdateGraphic";
exportclassUpdateGraphicimplementsAction{
readonlytype=UPDATE_GRAPHIC;
constructor(publicbale:GraphicBit){}
exportconstREAD_GRAPHIC="[Readaction]ReadGraphic";
exportclassReadGraphicimplementsAction{
readonlytype=READ_GRAPHIC;
constructor(publicbale:GraphicBit){}
exportconstWRITE_GRAPHIC="[Writeaction]WriteGraphic";
exportclassWriteGraphicimplementsAction{
readonlytype=WRITE_GRAPHIC;
constructor(publicbale:GraphicBit){}
exportconstCREATE_GRAPHIC="[Createaction]CreateGraphic";
exportclassCreateGraphicimplementsAction{
readonlytype=CREATE_GRAPHIC;
constructor(publicbale:GraphicBit){}
exportconstREMOVE_GRAPHIC="[Removeaction]RemoveGraphic";
exportclassRemoveGraphicimplementsAction{
readonlytype=REMOVE_GRAPHIC;
constructor(publicbale:GraphicBit){}
exportconstDELETE_GRAPHIC="[Deleteaction]DeleteGraphic";
exportclassDeleteGraphicimplementsAction{
readonlytype=DELETE_GRAPHIC;
constructor(publicbale:GraphicBit){}
exporttypeActions=|InitGraphic|UpdateGraphic
|ReadGraphic
|WriteGraphic
|CreateGraphic
|RemoveGraphic
|DeleteGraphic
export{initGraphic}from"./buz/graphic.buzz";
export{updateGraphic}from"./buz/graphic.buzz";
export{readGraphic}from"./buz/graphic.buzz";
export{writeGraphic}from"./buz/graphic.buzz";
export{createGraphic}from"./buz/graphic.buzz";
export{removeGraphic}from"./buz/graphic.buzz";
export{deleteGraphic}from"./buz/graphic.buzz";
importGraphicfrom"./fce/graphic.interface";
importGraphicBitfrom"./fce/graphic.interface";
exportclassGraphicModelimplementsGraphic{
import*asclonefrom"clone-deep";
import*asActfrom"./graphic.action";
import{GraphicModel}from"./graphic.model";
import*asBuzzfrom"./graphic.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:GraphicModel=newGraphicModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.UPDATE_GRAPHIC:
returnBuzz.updateGraphic(clone(model),act.bale,state);
caseAct.INIT_GRAPHIC:
returnBuzz.initGraphic(clone(model),act.bale,state);
caseAct.READ_GRAPHIC:
returnBuzz.readGraphic(clone(model),act.bale,state);
caseAct.WRITE_GRAPHIC:
returnBuzz.writeGraphic(clone(model),act.bale,state);
caseAct.CREATE_GRAPHIC:
returnBuzz.createGraphic(clone(model),act.bale,state);
caseAct.REMOVE_GRAPHIC:
returnBuzz.removeGraphic(clone(model),act.bale,state);
caseAct.DELETE_GRAPHIC:
returnBuzz.deleteGraphic(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassGraphicUnit{
constructor(state:State){
import{SurfaceModel}from"../../02.surface.unit/surface.model";
import{TextModel}from"../text.model";
importTextBitfrom"../fce/text.bit";
importStatefrom"../../99.core/state";
import*asPIXIfrom"pixi.js";
importLineBitfrom"../fce/line.bit";
import*asSHADEfrom"../../val/shade"
import{TextStyleAlign}from"pixi.js";
import*asActColfrom"../../97.collect.unit/collect.action";
import*asActFcefrom"../../02.surface.unit/surface.action";
import*asActCanfrom"../../03.container.unit/container.action";
import*asActGphfrom"../../04.graphic.unit/graphic.action";
import*asActTxtfrom"../../05.text.unit/text.action";
import*asActVsgfrom"../../21.visage.unit/visage.action";
varbit,val,idx,dex,lst,dat;
exportconstinitText=(cpy:TextModel,bal:TextBit,ste:State)=>{
exportconstupdateText=async(cpy:TextModel,bal:TextBit,ste:State)=>{
bit=awaitste.hunt(ActTxt.READ_TEXT,{idx:bal.idx})
dat=bit.txtBit.dat
vartext:PIXI.Text=dat.bit;
text.text=dat.txt;
text.x=dat.x;
text.y=dat.y;
if(bal.slv!=null)returnbal.slv({txtBit:{idx:"update-text",dat:dat}});
exportconstreadText=async(cpy:TextModel,bal:TextBit,ste:State)=>{
varslv=bal.slv;
if(bal.idx==null)bal.idx='txt00';
bit=awaitste.hunt(ActCol.READ_COLLECT,{idx:bal.idx,bit:ActTxt.CREATE_TEXT})
if(slv!=null)slv({txtBit:{idx:"read-text",dat:bit.clcBit.dat}});
exportconstwriteText=async(cpy:TextModel,bal:TextBit,ste:State)=>{
if(bal.idx==null)bal.idx="txt00";
bit=awaitste.hunt(ActCol.WRITE_COLLECT,{idx:bal.idx,src:bal.src,dat:bal.dat,bit:ActTxt.CREATE_TEXT})
ste.hunt(ActTxt.UPDATE_TEXT,{idx:bal.idx})
varoutput=bit.clcBit.dat
if(bal.slv!=null)bal.slv({txtBit:{idx:"write-text",dat:output}});
exportconstremoveText=async(cpy:TextModel,bal:TextBit,ste:State)=>{
bit=awaitste.hunt(ActCol.REMOVE_COLLECT,{idx:bal.idx,src:bal.src,dat:bal.dat,bit:ActTxt.DELETE_TEXT})
if(bal.slv!=null)bal.slv({vsgBit:{idx:"remove-text",dat:bit.clcBit}});
exportconstcreateText=async(cpy:TextModel,bal:TextBit,ste:State)=>{
vardat:LineBit={idx:bal.idx,src:bal.src,typ:SHADE.TEXT};
for(varkeyinbal.dat){
dat[key]=bal.dat[key]
if(dat.txt==null)dat.txt='createtext';
if(dat.x==null)dat.x=0;
if(dat.y==null)dat.y=0;
if(dat.fnt==null)dat.fnt="Arial";
if(dat.wrp==null)dat.wrp=300;
if(dat.a==null)dat.a=1;
if(dat.clr==null)dat.clr=0x000000;
if(dat.aln==null)dat.aln="right";
try{
dat.bit=newPIXI.Text(dat.txt);
dat.bit.style=newPIXI.TextStyle({
fontFamily:dat.fnt,
fontSize:dat.sze,
wordWrap:true,
wordWrapWidth:dat.wrp,
fill:dat.clr,
align:dat.alnasTextStyleAlign,
}catch(e){
dat.dat={};
if(bal.src!=null)bit=awaitste.hunt(ActVsg.NEST_VISAGE,{src:bal.src,dat})
if(bal.slv!=null)returnbal.slv({txtBit:{idx:"create-text",dat}});
exportconstdeleteText=async(cpy:TextModel,bal:TextBit,ste:State)=>{
if(typeofwindow!="object")returnbal.slv({fceBit:{idx:"error-delete-text",dat:{}}});
bit=awaitste.hunt(ActTxt.READ_TEXT,{idx:bal.idx})
vardat:LineBit=bit.txtBit.dat
vartext=dat.bit;
dat.bit=null
if(bal.slv!=null)returnbal.slv({vsgBit:{idx:"delete-text",dat}});
exportconstlistText=(cpy:TextModel,bal:TextBit,ste:State)=>{
debugger
import*asPIXIfrom'pixi.js';
exportdefaultinterfaceLineBit{
idx:string;
src?:string;
typ?:string;
can?:string;
dat?:any;
bit?:PIXI.Text;
txt?:string;
clr?:number;
fnt?:string;
wrp?:number;
sze?:number;
aln?:any;
w?:number;
h?:number;
x?:number;
y?:number;
a?:number;
exportdefaultinterfaceTextBit{
idx:string;
src?:string;
typ?:string;
val?:number;
dat?:any;
slv?:Function;
importTextBitfrom"./text.bit";
exportdefaultinterfaceText{
import{Action}from"../99.core/interface/action.interface";
importTextBitfrom"./fce/text.bit";
exportconstINIT_TEXT="[Textaction]InitText";
exportclassInitTextimplementsAction{
readonlytype=INIT_TEXT;
constructor(publicbale:TextBit){}
exportconstUPDATE_TEXT="[Textaction]UpdateText";
exportclassUpdateTextimplementsAction{
readonlytype=UPDATE_TEXT;
constructor(publicbale:TextBit){}
exportconstREAD_TEXT="[Readaction]ReadText";
exportclassReadTextimplementsAction{
readonlytype=READ_TEXT;
constructor(publicbale:TextBit){}
exportconstWRITE_TEXT="[Writeaction]WriteText";
exportclassWriteTextimplementsAction{
readonlytype=WRITE_TEXT;
constructor(publicbale:TextBit){}
exportconstCREATE_TEXT="[Createaction]CreateText";
exportclassCreateTextimplementsAction{
readonlytype=CREATE_TEXT;
constructor(publicbale:TextBit){}
exportconstREMOVE_TEXT="[Removeaction]RemoveText";
exportclassRemoveTextimplementsAction{
readonlytype=REMOVE_TEXT;
constructor(publicbale:TextBit){}
exportconstDELETE_TEXT="[Deleteaction]DeleteText";
exportclassDeleteTextimplementsAction{
readonlytype=DELETE_TEXT;
constructor(publicbale:TextBit){}
exportconstLIST_TEXT="[Listaction]ListText";
exportclassListTextimplementsAction{
readonlytype=LIST_TEXT;
constructor(publicbale:TextBit){}
exporttypeActions=|InitText|UpdateText
|ReadText
|WriteText
|CreateText
|RemoveText
|DeleteText
|ListText
export{initText}from"./buz/text.buzz";
export{updateText}from"./buz/text.buzz";
export{readText}from"./buz/text.buzz";
export{writeText}from"./buz/text.buzz";
export{createText}from"./buz/text.buzz";
export{removeText}from"./buz/text.buzz";
export{deleteText}from"./buz/text.buzz";
export{listText}from"./buz/text.buzz";
importTextfrom"./fce/text.interface";
importTextBitfrom"./fce/text.interface";
exportclassTextModelimplementsText{
import*asclonefrom"clone-deep";
import*asActfrom"./text.action";
import{TextModel}from"./text.model";
import*asBuzzfrom"./text.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:TextModel=newTextModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.UPDATE_TEXT:
returnBuzz.updateText(clone(model),act.bale,state);
caseAct.INIT_TEXT:
returnBuzz.initText(clone(model),act.bale,state);
caseAct.READ_TEXT:
returnBuzz.readText(clone(model),act.bale,state);
caseAct.WRITE_TEXT:
returnBuzz.writeText(clone(model),act.bale,state);
caseAct.CREATE_TEXT:
returnBuzz.createText(clone(model),act.bale,state);
caseAct.REMOVE_TEXT:
returnBuzz.removeText(clone(model),act.bale,state);
caseAct.DELETE_TEXT:
returnBuzz.deleteText(clone(model),act.bale,state);
caseAct.LIST_TEXT:
returnBuzz.listText(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassTextUnit{
constructor(state:State){
import{SurfaceModel}from"../../02.surface.unit/surface.model"
import{SpriteModel}from"../sprite.model";
importSpriteBitfrom"../fce/sprite.bit";
importStatefrom"../../99.core/state";
importIconBitfrom"../fce/icon.bit";
import*asPIXIfrom"pixi.js";
import{Application,Assets,Container,Sprite}from'pixi.js';
import*asSHADEfrom"../../val/shade"
import*asActColfrom"../../97.collect.unit/collect.action";
import*asActFcefrom"../../02.surface.unit/surface.action";
import*asActCanfrom"../../03.container.unit/container.action";
import*asActGphfrom"../../04.graphic.unit/graphic.action";
import*asActTxtfrom"../../05.text.unit/text.action";
import*asActSprfrom"../../06.sprite.unit/sprite.action";
import*asActVsgfrom"../../21.visage.unit/visage.action";
varbit,val,idx,dex,lst,dat;
exportconstinitSprite=(cpy:SpriteModel,bal:SpriteBit,ste:State)=>{
exportconstupdateSprite=async(cpy:SpriteModel,bal:SpriteBit,ste:State)=>{
bit=awaitste.hunt(ActSpr.READ_SPRITE,{idx:bal.idx})
dat=bit.sprBit.dat;
varsprite:PIXI.Sprite=dat.bit;
sprite.x=dat.x
sprite.y=dat.y
if(bal.slv!=null)returnbal.slv({sprBit:{idx:"update-sprite",dat:dat}});
exportconstreadSprite=async(cpy:SpriteModel,bal:SpriteBit,ste:State)=>{
varslv=bal.slv;
if(bal.idx==null)bal.idx="spr00";
bit=awaitste.hunt(ActCol.READ_COLLECT,{idx:bal.idx,bit:ActSpr.CREATE_SPRITE});
if(slv!=null)slv({sprBit:{idx:"read-sprite",dat:bit.clcBit.dat}});
exportconstwriteSprite=async(cpy:SpriteModel,bal:SpriteBit,ste:State)=>{
bit=awaitste.hunt(ActCol.WRITE_COLLECT,{idx:bal.idx,src:bal.src,dat:bal.dat,bit:ActSpr.CREATE_SPRITE});
if(bal.src==null)ste.hunt(ActSpr.UPDATE_SPRITE,{idx:bal.idx})
if(bal.slv!=null)bal.slv({sprBit:{idx:"write-sprite",dat:bit.clcBit.dat}});
exportconstremoveSprite=async(cpy:SpriteModel,bal:SpriteBit,ste:State)=>{
bit=awaitste.hunt(ActCol.REMOVE_COLLECT,{idx:bal.idx,src:bal.src,dat:bal.dat,bit:ActSpr.DELETE_SPRITE})
if(bal.slv!=null)bal.slv({vsgBit:{idx:"remove-text",dat:bit.clcBit}});
varcount=0;
exportconstcreateSprite=async(cpy:SpriteModel,bal:SpriteBit,ste:State)=>{
vardat:IconBit={idx:bal.idx,src:bal.src,typ:SHADE.SPRITE};
for(varkeyinbal.dat){
dat[key]=bal.dat[key]
if(dat.x==null)dat.x=0;
if(dat.y==null)dat.y=0;
if(dat.r==null)dat.r=0;
if(dat.s==null)dat.s=1;
if(dat.a==null)dat.a=1;
if(dat.src==null)dat.src='./img/000.png'
try{
consttexture=awaitAssets.load(dat.src);
dat.bit=newSprite(texture);
}catch(e){
dat.dat={};
if(dat.x!=null)dat.bit.x=dat.x
if(dat.y!=null)dat.bit.y=dat.y
if(dat.r!=null)dat.bit.rotation=dat.r
if(dat.s!=null)dat.bit.scale=dat.s
if(dat.a!=null)dat.bit.alpha=dat.a
if(bal.slv!=null)returnbal.slv({sprBit:{idx:"create-sprite",dat}});
exportconstdeleteSprite=async(cpy:SpriteModel,bal:SpriteBit,ste:State)=>{
if(typeofwindow!="object")returnbal.slv({fceBit:{idx:"error-delete-graphic",dat:{}}});
bit=awaitste.hunt(ActSpr.READ_SPRITE,{idx:bal.idx})
vardat:IconBit=bit.sprBit.dat
varsprite=dat.bit;
sprite.destroy()
dat.bit=null
if(bal.slv!=null)returnbal.slv({vsgBit:{idx:"delete-sprite",dat}});
import*asPIXIfrom'pixi.js';
exportdefaultinterfaceIconBit{
idx:string;
src?:string;
typ?:string;
can?:string;
dat?:any;
bit?:PIXI.Sprite;
clr?:number;
w?:number;
h?:number;
x?:number;
y?:number;
r?:number;
s?:number;
a?:number;
exportdefaultinterfaceSpriteBit{
idx:string;
src?:string;
val?:number;
dat?:any;
slv?:Function;
importSpriteBitfrom"./sprite.bit";
exportdefaultinterfaceSprite{
import{Action}from"../99.core/interface/action.interface";
importSpriteBitfrom"./fce/sprite.bit";
exportconstINIT_SPRITE="[Spriteaction]InitSprite";
exportclassInitSpriteimplementsAction{
readonlytype=INIT_SPRITE;
constructor(publicbale:SpriteBit){}
exportconstUPDATE_SPRITE="[Spriteaction]UpdateSprite";
exportclassUpdateSpriteimplementsAction{
readonlytype=UPDATE_SPRITE;
constructor(publicbale:SpriteBit){}
exportconstREAD_SPRITE="[Readaction]ReadSprite";
exportclassReadSpriteimplementsAction{
readonlytype=READ_SPRITE;
constructor(publicbale:SpriteBit){}
exportconstWRITE_SPRITE="[Writeaction]WriteSprite";
exportclassWriteSpriteimplementsAction{
readonlytype=WRITE_SPRITE;
constructor(publicbale:SpriteBit){}
exportconstCREATE_SPRITE="[Creattaction]CreattSprite";
exportclassCreateSpriteimplementsAction{
readonlytype=CREATE_SPRITE;
constructor(publicbale:SpriteBit){}
exportconstREMOVE_SPRITE="[Removeaction]RemoveSprite";
exportclassRemoveSpriteimplementsAction{
readonlytype=REMOVE_SPRITE;
constructor(publicbale:SpriteBit){}
exportconstDELETE_SPRITE="[Deleteaction]DeleteSprite";
exportclassDeleteSpriteimplementsAction{
readonlytype=DELETE_SPRITE;
constructor(publicbale:SpriteBit){}
exporttypeActions=|InitSprite|UpdateSprite
|ReadSprite
|WriteSprite
|CreateSprite
|RemoveSprite
|DeleteSprite
export{initSprite}from"./buz/sprite.buzz";
export{updateSprite}from"./buz/sprite.buzz";
export{readSprite}from"./buz/sprite.buzz";
export{writeSprite}from"./buz/sprite.buzz";
export{createSprite}from"./buz/sprite.buzz";
export{removeSprite}from"./buz/sprite.buzz";
export{deleteSprite}from"./buz/sprite.buzz";
importSpritefrom"./fce/sprite.interface";
importSpriteBitfrom"./fce/sprite.interface";
exportclassSpriteModelimplementsSprite{
import*asclonefrom"clone-deep";
import*asActfrom"./sprite.action";
import{SpriteModel}from"./sprite.model";
import*asBuzzfrom"./sprite.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:SpriteModel=newSpriteModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.UPDATE_SPRITE:
returnBuzz.updateSprite(clone(model),act.bale,state);
caseAct.INIT_SPRITE:
returnBuzz.initSprite(clone(model),act.bale,state);
caseAct.READ_SPRITE:
returnBuzz.readSprite(clone(model),act.bale,state);
caseAct.WRITE_SPRITE:
returnBuzz.writeSprite(clone(model),act.bale,state);
caseAct.CREATE_SPRITE:
returnBuzz.createSprite(clone(model),act.bale,state);
caseAct.REMOVE_SPRITE:
returnBuzz.removeSprite(clone(model),act.bale,state);
caseAct.DELETE_SPRITE:
returnBuzz.deleteSprite(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassSpriteUnit{
constructor(state:State){
import{HexagonModel}from"../hexagon.model";
importHexagonBitfrom"../fce/hexagon.bit";
importHexBitfrom"../fce/hex.bit";
importStatefrom"../../99.core/state";
import*asHoneycombfrom"honeycomb-grid";
import*asPIXIfrom"pixi.js";
import*asHEXAGONfrom"../../val/hexagon"
import*asDIRECTIONfrom"../../val/direction"
import*asActColfrom"../../97.collect.unit/collect.action";
import*asActFcefrom"../../02.surface.unit/surface.action";
import*asActCanfrom"../../03.container.unit/container.action";
import*asActGphfrom"../../04.graphic.unit/graphic.action";
import*asActTxtfrom"../../05.text.unit/text.action";
import*asActSprfrom"../../06.sprite.unit/sprite.action";
import*asActHexfrom"../../07.hexagon.unit/hexagon.action";
import*asActVsgfrom"../../21.visage.unit/visage.action";
varbit,val,idx,dex,lst,dat;
exportconstinitHexagon=(cpy:HexagonModel,bal:HexagonBit,ste:State)=>{
exportconstupdateHexagon=async(cpy:HexagonModel,bal:HexagonBit,ste:State)=>{
bit=awaitste.hunt(ActHex.READ_HEXAGON,{idx:bal.idx})
vardat:HexBit=bit.hexBit.dat
varmap=dat.map
if(map!=null)
dat.frm
switch(dat.frm){
caseHEXAGON.FOCUS:
ste.hunt(ActHex.FOCUS_HEXAGON,{dat,bit:bal.dat})
break
caseHEXAGON.HEXMAP:
ste.hunt(ActHex.HEXMAP_HEXAGON,{dat,bit:bal.dat})
break
bal.slv({hexBit:{idx:"update-hexagon",dat:dat}});
exportconstfocusHexagon=async(cpy:HexagonModel,bal:HexagonBit,ste:State)=>{
exportconsthexmapHexagon=async(cpy:HexagonModel,bal:HexagonBit,ste:State)=>{
varhexmap=bal.bit
bit=awaitste.hunt(ActGph.READ_GRAPHIC,{idx:bal.dat.src})
vargraphic:PIXI.Graphics=bit.gphBit.dat.bit
graphic.clear()
constHex:Honeycomb.HexFactory=Honeycomb.extendHex({
constGrid:Honeycomb.GridFactory<any>=Honeycomb.defineGrid(Hex);
constgrid:Honeycomb.Grid=Grid(hexmap);
varpct=.25;
varscl=640
grid
grid.forEach((hex)=>{
constpoint=hex.toPoint();
constcorners=hex.corners().map((corner)=>corner.add(point));
const[firstCorner,...otherCorners]=corners;
graphic.moveTo(firstCorner.x*scl,firstCorner.y*scl*pct);
otherCorners.forEach(({x,y})=>graphic.lineTo(x*scl,y*scl*pct));
graphic.lineTo(firstCorner.x*scl,firstCorner.y*scl*pct);
graphic.stroke({color:0xff0000,pixelLine:true});
bal.slv({hexBit:{idx:"hexmap-hexagon",dat:hexmap}});
exportconstreadHexagon=async(cpy:HexagonModel,bal:HexagonBit,ste:State)=>{
varslv=bal.slv;
if(bal.idx==null)bal.idx="hex00";
bit=awaitste.hunt(ActCol.READ_COLLECT,{idx:bal.idx,src:bal.src,bit:ActHex.CREATE_HEXAGON});
if(slv!=null)slv({hexBit:{idx:"read-hexagon",dat:bit.clcBit.dat}});
exportconstwriteHexagon=async(cpy:HexagonModel,bal:HexagonBit,ste:State)=>{
bit=awaitste.hunt(ActCol.WRITE_COLLECT,{idx:bal.idx,src:bal.src,dat:bal.dat,bit:ActHex.CREATE_HEXAGON});
ste.hunt(ActHex.UPDATE_HEXAGON,{idx:bal.idx,dat:bal.dat.dat});
if(bal.slv!=null)bal.slv({hexBit:{idx:"write-hexagon",dat:bit.clcBit.dat}});
exportconstremoveHexagon=async(cpy:HexagonModel,bal:HexagonBit,ste:State)=>{
bit=awaitste.hunt(ActCol.REMOVE_COLLECT,{idx:bal.idx,src:bal.src,dat:bal.dat,bit:ActHex.DELETE_HEXAGON})
if(bal.slv!=null)bal.slv({hexBit:{idx:"replace-hexagon",dat:bit.clcBit}});
exportconstcreateHexagon=async(cpy:HexagonModel,bal:HexagonBit,ste:State)=>{
vardat:HexBit={idx:bal.idx,src:bal.src};
for(varkeyinbal.dat){
if(key=='dat')continue
dat[key]=bal.dat[key]
varhexagon=bal.dat.dat;
if(hexagon!=null){
dat.frm=hexagon.typ;
dat.gph=hexagon.gph;
if(dat.clr==null)dat.clr=0x0000000;
if(dat.lne==null)dat.lne=2;
if(dat.wpe==null)dat.wpe=true;
if(dat.a==null)dat.a=1;
if(dat.pct==null)dat.pct=1;
if(dat.sze==null)dat.sze=3;
if(dat.frm==null)dat.frm=HEXAGON.HEXMAP;
bal.slv({usrBit:{idx:"create-hexagon",dat:dat}});
exportconstdeleteHexagon=(cpy:HexagonModel,bal:HexagonBit,ste:State)=>{
debugger
import*asPIXIfrom'pixi.js';
exportdefaultinterfaceHexBit{
idx:string;
src?:string;
typ?:string;
frm?:string;
gph?:string;
ico?:string;
can?:string;
sze?:number;
dat?:any;
map?:any;
bit?:PIXI.Sprite;
clr?:number;
w?:number;
h?:number;
x?:number;
y?:number;
r?:number;
s?:number;
a?:number;
crn0?:any;
crn1?:any;
exportdefaultinterfaceHexagonBit{
idx:string;
src?:string;
val?:number;
dat?:any;
bit?:any;
slv?:Function;
importHexagonBitfrom"./hexagon.bit";
exportdefaultinterfaceHexagon{
import{Action}from"../99.core/interface/action.interface";
importHexagonBitfrom"./fce/hexagon.bit";
exportconstINIT_HEXAGON="[Hexagonaction]InitHexagon";
exportclassInitHexagonimplementsAction{
readonlytype=INIT_HEXAGON;
constructor(publicbale:HexagonBit){}
exportconstUPDATE_HEXAGON="[Hexagonaction]UpdateHexagon";
exportclassUpdateHexagonimplementsAction{
readonlytype=UPDATE_HEXAGON;
constructor(publicbale:HexagonBit){}
exportconstREAD_HEXAGON="[Readaction]ReadHexagon";
exportclassReadHexagonimplementsAction{
readonlytype=READ_HEXAGON;
constructor(publicbale:HexagonBit){}
exportconstWRITE_HEXAGON="[Writeaction]WriteHexagon";
exportclassWriteHexagonimplementsAction{
readonlytype=WRITE_HEXAGON;
constructor(publicbale:HexagonBit){}
exportconstCREATE_HEXAGON="[Createaction]CreateHexagon";
exportclassCreateHexagonimplementsAction{
readonlytype=CREATE_HEXAGON;
constructor(publicbale:HexagonBit){}
exportconstREMOVE_HEXAGON="[Replaceaction]RemoveHexagon";
exportclassRemoveHexagonimplementsAction{
readonlytype=REMOVE_HEXAGON;
constructor(publicbale:HexagonBit){}
exportconstDELETE_HEXAGON="[Deleteaction]DeleteHexagon";
exportclassDeleteHexagonimplementsAction{
readonlytype=DELETE_HEXAGON;
constructor(publicbale:HexagonBit){}
exportconstFOCUS_HEXAGON="[Focusaction]FocusHexagon";
exportclassFocusHexagonimplementsAction{
readonlytype=FOCUS_HEXAGON;
constructor(publicbale:HexagonBit){}
exportconstHEXMAP_HEXAGON="[Hexmapaction]HexmapHexagon";
exportclassHexmapHexagonimplementsAction{
readonlytype=HEXMAP_HEXAGON;
constructor(publicbale:HexagonBit){}
exporttypeActions=|InitHexagon|UpdateHexagon
|ReadHexagon
|WriteHexagon
|CreateHexagon
|RemoveHexagon
|DeleteHexagon
|FocusHexagon
|HexmapHexagon
export{initHexagon}from"./buz/hexagon.buzz";
export{updateHexagon}from"./buz/hexagon.buzz";
export{readHexagon}from"./buz/hexagon.buzz";
export{writeHexagon}from"./buz/hexagon.buzz";
export{createHexagon}from"./buz/hexagon.buzz";
export{removeHexagon}from"./buz/hexagon.buzz";
export{deleteHexagon}from"./buz/hexagon.buzz";
export{focusHexagon}from"./buz/hexagon.buzz";
export{hexmapHexagon}from"./buz/hexagon.buzz";
importHexagonfrom"./fce/hexagon.interface";
importHexagonBitfrom"./fce/hexagon.interface";
exportclassHexagonModelimplementsHexagon{
import*asclonefrom"clone-deep";
import*asActfrom"./hexagon.action";
import{HexagonModel}from"./hexagon.model";
import*asBuzzfrom"./hexagon.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:HexagonModel=newHexagonModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.UPDATE_HEXAGON:
returnBuzz.updateHexagon(clone(model),act.bale,state);
caseAct.INIT_HEXAGON:
returnBuzz.initHexagon(clone(model),act.bale,state);
caseAct.READ_HEXAGON:
returnBuzz.readHexagon(clone(model),act.bale,state);
caseAct.WRITE_HEXAGON:
returnBuzz.writeHexagon(clone(model),act.bale,state);
caseAct.CREATE_HEXAGON:
returnBuzz.createHexagon(clone(model),act.bale,state);
caseAct.REMOVE_HEXAGON:
returnBuzz.removeHexagon(clone(model),act.bale,state);
caseAct.DELETE_HEXAGON:
returnBuzz.deleteHexagon(clone(model),act.bale,state);
caseAct.FOCUS_HEXAGON:
returnBuzz.focusHexagon(clone(model),act.bale,state);
caseAct.HEXMAP_HEXAGON:
returnBuzz.hexmapHexagon(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassHexagonUnit{
constructor(state:State){
import{FocigonModel}from"../focigon.model";
importFocigonBitfrom"../fce/focigon.bit";
importStatefrom"../../99.core/state";
importFocBitfrom"../fce/foc.bit";
import*asHEXAGONfrom"../../val/hexagon"
import*asDIRECTIONfrom"../../val/direction"
import*asActColfrom"../../97.collect.unit/collect.action";
import*asActFcefrom"../../02.surface.unit/surface.action";
import*asActCanfrom"../../03.container.unit/container.action";
import*asActGphfrom"../../04.graphic.unit/graphic.action";
import*asActTxtfrom"../../05.text.unit/text.action";
import*asActSprfrom"../../06.sprite.unit/sprite.action";
import*asActHexfrom"../../07.hexagon.unit/hexagon.action";
import*asActVsgfrom"../../21.visage.unit/visage.action";
import*asActFcgfrom"../../08.focigon.unit/focigon.action";
varbit,val,idx,dex,lst,dat;
exportconstinitFocigon=(cpy:FocigonModel,bal:FocigonBit,ste:State)=>{
debugger
exportconstupdateFocigon=async(cpy:FocigonModel,bal:FocigonBit,ste:State)=>{
bit=awaitste.hunt(ActFcg.READ_FOCIGON,{idx:bal.idx})
vardat:FocBit=bit.fcgBit.dat
dat.x=bal.dat.bit.x
dat.y=bal.dat.bit.y
dat.crns=bal.dat.bit.corners
if(bal.dat.src!=null)bal.src=bal.dat.src
vargraphic;
if(bal.dat.gph!=null)graphic=bal.dat.gph
graphic
graphic.clear()
varpct=.33;
varscl=1
dat.crns
graphic.circle(dat.crns[5].x*scl,dat.crns[5].y*scl,10).fill('red')
graphic.moveTo(dat.crns[0].x*scl,dat.crns[0].y*scl*pct);
graphic.lineTo(dat.crns[0].x*scl,dat.crns[0].y*scl*pct);
graphic.lineTo(dat.crns[1].x*scl,dat.crns[1].y*scl*pct);
graphic.lineTo(dat.crns[2].x*scl,dat.crns[2].y*scl*pct);
graphic.lineTo(dat.crns[3].x*scl,dat.crns[3].y*scl*pct);
graphic.lineTo(dat.crns[4].x*scl,dat.crns[4].y*scl*pct);
graphic.lineTo(dat.crns[5].x*scl,dat.crns[5].y*scl*pct);
graphic.lineTo(dat.crns[0].x*scl,dat.crns[0].y*scl*pct);
graphic.endFill();
graphic.stroke({color:0xff00ff,pixelLine:true});
dat.fce
if(dat.fce==null)dat.fce=DIRECTION.EAST
if(dat.fce!=null){
varcorners=dat.crns;
switch(dat.fce){
caseDIRECTION.NORTH_EAST:
dat.crn0=corners[5];
dat.crn1=corners[0];
break;
caseDIRECTION.NORTH_WEST:
dat.crn0=corners[4];
dat.crn1=corners[5];
break;
caseDIRECTION.EAST:
dat.crn0=corners[0];
dat.crn1=corners[1];
break;
caseDIRECTION.SOUTH_EAST:
dat.crn0=corners[1];
dat.crn1=corners[2];
break;
caseDIRECTION.SOUTH_WEST:
dat.crn0=corners[2];
dat.crn1=corners[3];
break;
caseDIRECTION.WEST:
dat.crn0=corners[3];
dat.crn1=corners[4];
break;
caseDIRECTION.SOUTH_EAST:
dat.crn0=corners[4];
dat.crn1=corners[5];
break;
varfaceClr=0x0000ff;
graphic.lineStyle(3,faceClr,1);
graphic.moveTo(dat.crn0.x*scl,dat.crn0.y*scl*pct);
graphic.lineTo(dat.crn1.x*scl,dat.crn1.y*scl*pct);
bal.slv({fcgBit:{idx:"update-focigon",dat:focus}});
exportconstreadFocigon=async(cpy:FocigonModel,bal:FocigonBit,ste:State)=>{
varslv=bal.slv;
if(bal.idx==null)bal.idx="hex00";
bit=awaitste.hunt(ActCol.READ_COLLECT,{idx:bal.idx,src:bal.src,bit:ActFcg.CREATE_FOCIGON});
if(slv!=null)slv({fcgBit:{idx:"read-focigon",dat:bit.clcBit.dat}});
exportconstwriteFocigon=async(cpy:FocigonModel,bal:FocigonBit,ste:State)=>{
bit=awaitste.hunt(ActCol.WRITE_COLLECT,{idx:bal.idx,src:bal.src,dat:bal.dat,bit:ActFcg.CREATE_FOCIGON});
ste.hunt(ActFcg.UPDATE_FOCIGON,{idx:bal.idx,dat:bal.dat});
if(bal.slv!=null)bal.slv({fcgBit:{idx:"write-focigon",dat:bit.clcBit.dat}});
exportconstremoveFocigon=async(cpy:FocigonModel,bal:FocigonBit,ste:State)=>{
bit=awaitste.hunt(ActCol.REMOVE_COLLECT,{idx:bal.idx,src:bal.src,dat:bal.dat,bit:ActFcg.DELETE_FOCIGON})
if(bal.slv!=null)bal.slv({fcgBit:{idx:"remove-focigon",dat:bit.clcBit}});
exportconstcreateFocigon=async(cpy:FocigonModel,bal:FocigonBit,ste:State)=>{
vardat:FocBit={idx:bal.idx,src:bal.src};
bal.dat;
for(varkeyinbal.dat){
if(key=='bit')continue
dat[key]=bal.dat[key]
varfocus=bal.dat.bit;
dat.fce=focus.face;
dat.frm=focus.typ;
dat.gph=focus.gph;
dat.crns=focus.corners;
if(dat.clr==null)dat.clr=0x0000000;
if(dat.lne==null)dat.lne=2;
if(dat.wpe==null)dat.wpe=true;
if(dat.a==null)dat.a=1;
if(dat.pct==null)dat.pct=1;
if(dat.frm==null)dat.frm='f';
if(dat.fce==null)dat.fce='E';
if(dat.sze==null)dat.sze=111;
bal.slv({fcgBit:{idx:"create-focigon",dat:dat}});
exportconstdeleteFocigon=(cpy:FocigonModel,bal:FocigonBit,ste:State)=>{
debugger
import*asPIXIfrom'pixi.js';
exportdefaultinterfaceFocBit{
idx:string;
src?:string;
typ?:string;
frm?:string;
fce?:string;
gph?:string;
ico?:string;
can?:string;
dat?:any;
bit?:PIXI.Sprite;
clr?:number;
w?:number;
h?:number;
x?:number;
y?:number;
r?:number;
s?:number;
a?:number;
crns?:any;
crn0?:any;
crn1?:any;
sze?:number
exportdefaultinterfaceFocigonBit{
idx:string;
src?:string;
val?:number;
dat?:any;
bit?:any;
slv?:Function;
importFocigonBitfrom"./focigon.bit";
exportdefaultinterfaceFocigon{
import{Action}from"../99.core/interface/action.interface";
importFocigonBitfrom"./fce/focigon.bit";
exportconstINIT_FOCIGON="[Focigonaction]InitFocigon";
exportclassInitFocigonimplementsAction{
readonlytype=INIT_FOCIGON;
constructor(publicbale:FocigonBit){}
exportconstUPDATE_FOCIGON="[Focigonaction]UpdateFocigon";
exportclassUpdateFocigonimplementsAction{
readonlytype=UPDATE_FOCIGON;
constructor(publicbale:FocigonBit){}
exportconstREAD_FOCIGON="[Readaction]ReadFocigon";
exportclassReadFocigonimplementsAction{
readonlytype=READ_FOCIGON;
constructor(publicbale:FocigonBit){}
exportconstWRITE_FOCIGON="[Writeaction]WriteFocigon";
exportclassWriteFocigonimplementsAction{
readonlytype=WRITE_FOCIGON;
constructor(publicbale:FocigonBit){}
exportconstREMOVE_FOCIGON="[Removeaction]RemoveFocigon";
exportclassRemoveFocigonimplementsAction{
readonlytype=REMOVE_FOCIGON;
constructor(publicbale:FocigonBit){}
exportconstCREATE_FOCIGON="[Createaction]CreateFocigon";
exportclassCreateFocigonimplementsAction{
readonlytype=CREATE_FOCIGON;
constructor(publicbale:FocigonBit){}
exportconstDELETE_FOCIGON="[Deleteaction]DeleteFocigon";
exportclassDeleteFocigonimplementsAction{
readonlytype=DELETE_FOCIGON;
constructor(publicbale:FocigonBit){}
exporttypeActions=|InitFocigon|UpdateFocigon
|ReadFocigon
|WriteFocigon
|RemoveFocigon
|CreateFocigon
|DeleteFocigon
export{initFocigon}from"./buz/focigon.buzz";
export{updateFocigon}from"./buz/focigon.buzz";
export{readFocigon}from"./buz/focigon.buzz";
export{writeFocigon}from"./buz/focigon.buzz";
export{removeFocigon}from"./buz/focigon.buzz";
export{createFocigon}from"./buz/focigon.buzz";
export{deleteFocigon}from"./buz/focigon.buzz";
importFocigonfrom"./fce/focigon.interface";
importFocigonBitfrom"./fce/focigon.interface";
exportclassFocigonModelimplementsFocigon{
import*asclonefrom"clone-deep";
import*asActfrom"./focigon.action";
import{FocigonModel}from"./focigon.model";
import*asBuzzfrom"./focigon.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:FocigonModel=newFocigonModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.UPDATE_FOCIGON:
returnBuzz.updateFocigon(clone(model),act.bale,state);
caseAct.INIT_FOCIGON:
returnBuzz.initFocigon(clone(model),act.bale,state);
caseAct.READ_FOCIGON:
returnBuzz.readFocigon(clone(model),act.bale,state);
caseAct.WRITE_FOCIGON:
returnBuzz.writeFocigon(clone(model),act.bale,state);
caseAct.REMOVE_FOCIGON:
returnBuzz.removeFocigon(clone(model),act.bale,state);
caseAct.CREATE_FOCIGON:
returnBuzz.createFocigon(clone(model),act.bale,state);
caseAct.DELETE_FOCIGON:
returnBuzz.deleteFocigon(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassFocigonUnit{
constructor(state:State){
exportconstinitLoop=(cpy:LoopModel,bal:LoopBit,ste:State)=>{
exportconstupdateLoop=(cpy:LoopModel,bal:LoopBit,ste:State)=>{
exportconstremoveLoop=(cpy:LoopModel,bal:LoopBit,ste:State)=>{
debugger
exportconstdeleteLoop=(cpy:LoopModel,bal:LoopBit,ste:State)=>{
debugger
import{LoopModel}from"../loop.model";
importLoopBitfrom"../fce/loop.bit";
importStatefrom"../../99.core/state";
"usestrict";
exports.__esModule=true;
exportdefaultinterfaceLoopBit{
idx:string;
"usestrict";
exports.__esModule=true;
importLoopBitfrom"./loop.bit";
exportdefaultinterfaceLoop{
import{Action}from"../99.core/interface/action.interface";
importLoopBitfrom"./fce/loop.bit";
exportconstINIT_LOOP="[Loopaction]InitLoop";
exportclassInitLoopimplementsAction{
readonlytype=INIT_LOOP;
constructor(publicbale:LoopBit){}
exportconstUPDATE_LOOP="[Loopaction]UpdateLoop";
exportclassUpdateLoopimplementsAction{
readonlytype=UPDATE_LOOP;
constructor(publicbale:LoopBit){}
exportconstREMOVE_LOOP="[Replaceaction]RemoveLoop";
exportclassRemoveLoopimplementsAction{
readonlytype=REMOVE_LOOP;
constructor(publicbale:LoopBit){}
exportconstDELETE_LOOP="[Deleteaction]DeleteLoop";
exportclassDeleteLoopimplementsAction{
readonlytype=DELETE_LOOP;
constructor(publicbale:LoopBit){}
exporttypeActions=|InitLoop|UpdateLoop
|RemoveLoop
|DeleteLoop
export{initLoop}from"./buz/loop.buzz";
export{updateLoop}from"./buz/loop.buzz";
export{removeLoop}from"./buz/loop.buzz";
export{deleteLoop}from"./buz/loop.buzz";
importLoopfrom"./fce/loop.interface";
importLoopBitfrom"./fce/loop.interface";
exportclassLoopModelimplementsLoop{
import*asclonefrom"clone-deep";
import*asActfrom"./loop.action";
import{LoopModel}from"./loop.model";
import*asBuzzfrom"./loop.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:LoopModel=newLoopModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.UPDATE_LOOP:
returnBuzz.updateLoop(clone(model),act.bale,state);
caseAct.INIT_LOOP:
returnBuzz.initLoop(clone(model),act.bale,state);
caseAct.REMOVE_LOOP:
returnBuzz.removeLoop(clone(model),act.bale,state);
caseAct.DELETE_LOOP:
returnBuzz.deleteLoop(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassLoopUnit{
constructor(state:State){
exportconstinitToon=(cpy:ToonModel,bal:ToonBit,ste:State)=>{
exportconstupdateToon=(cpy:ToonModel,bal:ToonBit,ste:State)=>{
import{ToonModel}from"../toon.model";
importToonBitfrom"../fce/toon.bit";
importStatefrom"../../99.core/state";
"usestrict";
exports.__esModule=true;
exportdefaultinterfaceToonBit{
idx:string;
"usestrict";
exports.__esModule=true;
importToonBitfrom"./toon.bit";
exportdefaultinterfaceToon{
import{Action}from"../99.core/interface/action.interface";
importToonBitfrom"./fce/toon.bit";
exportconstINIT_TOON="[Toonaction]InitToon";
exportclassInitToonimplementsAction{
readonlytype=INIT_TOON;
constructor(publicbale:ToonBit){}
exportconstUPDATE_TOON="[Toonaction]UpdateToon";
exportclassUpdateToonimplementsAction{
readonlytype=UPDATE_TOON;
constructor(publicbale:ToonBit){}
exporttypeActions=|InitToon|UpdateToon;
export{initToon}from"./buz/toon.buzz";
export{updateToon}from"./buz/toon.buzz";
importToonfrom"./fce/toon.interface";
importToonBitfrom"./fce/toon.interface";
exportclassToonModelimplementsToon{
import*asclonefrom"clone-deep";
import*asActfrom"./toon.action";
import{ToonModel}from"./toon.model";
import*asBuzzfrom"./toon.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:ToonModel=newToonModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.UPDATE_TOON:
returnBuzz.updateToon(clone(model),act.bale,state);
caseAct.INIT_TOON:
returnBuzz.initToon(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassToonUnit{
constructor(state:State){
exportconstinitVideo=(cpy:VideoModel,bal:VideoBit,ste:State)=>{
exportconstupdateVideo=(cpy:VideoModel,bal:VideoBit,ste:State)=>{
exportconstremoveVideo=(cpy:VideoModel,bal:VideoBit,ste:State)=>{
debugger
exportconstdeleteVideo=(cpy:VideoModel,bal:VideoBit,ste:State)=>{
debugger
import{VideoModel}from"../video.model";
importVideoBitfrom"../fce/video.bit";
importStatefrom"../../99.core/state";
exportdefaultinterfaceVideoBit{
idx:string;
importVideoBitfrom"./video.bit";
exportdefaultinterfaceVideo{
import{Action}from"../99.core/interface/action.interface";
importVideoBitfrom"./fce/video.bit";
exportconstINIT_VIDEO="[Videoaction]InitVideo";
exportclassInitVideoimplementsAction{
readonlytype=INIT_VIDEO;
constructor(publicbale:VideoBit){}
exportconstUPDATE_VIDEO="[Videoaction]UpdateVideo";
exportclassUpdateVideoimplementsAction{
readonlytype=UPDATE_VIDEO;
constructor(publicbale:VideoBit){}
exportconstREMOVE_VIDEO="[Replaceaction]ReplaceVideo";
exportclassRemoveVideoimplementsAction{
readonlytype=REMOVE_VIDEO;
constructor(publicbale:VideoBit){}
exportconstDELETE_VIDEO="[Deleteaction]DeleteVideo";
exportclassDeleteVideoimplementsAction{
readonlytype=DELETE_VIDEO;
constructor(publicbale:VideoBit){}
exporttypeActions=|InitVideo|UpdateVideo
|RemoveVideo
|DeleteVideo
export{initVideo}from"./buz/video.buzz";
export{updateVideo}from"./buz/video.buzz";
export{removeVideo}from"./buz/video.buzz";
export{deleteVideo}from"./buz/video.buzz";
importVideofrom"./fce/video.interface";
importVideoBitfrom"./fce/video.interface";
exportclassVideoModelimplementsVideo{
import*asclonefrom"clone-deep";
import*asActfrom"./video.action";
import{VideoModel}from"./video.model";
import*asBuzzfrom"./video.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:VideoModel=newVideoModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.UPDATE_VIDEO:
returnBuzz.updateVideo(clone(model),act.bale,state);
caseAct.INIT_VIDEO:
returnBuzz.initVideo(clone(model),act.bale,state);
caseAct.REMOVE_VIDEO:
returnBuzz.removeVideo(clone(model),act.bale,state);
caseAct.DELETE_VIDEO:
returnBuzz.deleteVideo(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassVideoUnit{
constructor(state:State){
import*asPIXIfrom"pixi.js";
import*asGRAPHICfrom"../../val/graphic"
import*asSHADEfrom'../../val/shade'
import{FrameModel}from"../frame.model";
importFrameBitfrom"../fce/frame.bit";
importStatefrom"../../99.core/state";
importHoldBitfrom"../fce/hold.bit";
import*asActColfrom"../../97.collect.unit/collect.action";
import*asActGphfrom"../../04.graphic.unit/graphic.action";
import*asActVsgfrom"../../21.visage.unit/visage.action";
import*asActFmefrom"../frame.action";
import*asActVrtfrom"../../act/vurt.action";
import*asActDskfrom"../../act/disk.action";
varbit,val,idx,dex,lst,dat;
exportconstinitFrame=(cpy:FrameModel,bal:FrameBit,ste:State)=>{
debugger
exportconstupdateFrame=async(cpy:FrameModel,bal:FrameBit,ste:State)=>{
bit=awaitste.hunt(ActGph.READ_GRAPHIC,{idx:bal.idx})
dat=bit.gphBit.dat
vargraphic:PIXI.Graphics=dat.bit;
graphic.clear();
graphic.beginFill(0xFF00FF);
graphic.lineStyle(13,0xFF0000);
graphic.drawRoundedRect(0,0,33,100,5);
if(bal.slv!=null)returnbal.slv({gphBit:{idx:"update-graphic",dat:dat}});
exportconstreadFrame=async(cpy:FrameModel,bal:FrameBit,ste:State)=>{
varslv=bal.slv;
if(bal.idx==null)bal.idx="frm00";
bit=awaitste.hunt(ActCol.READ_COLLECT,{idx:bal.idx,bit:ActFme.CREATE_FRAME});
if(slv!=null)slv({fmeBit:{idx:"read-frame",dat:bit.clcBit.dat}});
exportconstwriteFrame=async(cpy:FrameModel,bal:FrameBit,ste:State)=>{
if(bal.idx==null)bal.idx="frm00";
bit=awaitste.hunt(ActCol.WRITE_COLLECT,{idx:bal.idx,src:bal.src,dat:bal.dat,bit:ActFme.CREATE_FRAME});
ste.hunt(ActFme.UPDATE_FRAME,{idx:bal.idx})
if(bal.slv!=null)bal.slv({fmeBit:{idx:"write-frame",dat:bit.clcBit.dat}});
exportconstremoveFrame=async(cpy:FrameModel,bal:FrameBit,ste:State)=>{
bit=awaitste.hunt(ActCol.REMOVE_COLLECT,{idx:bal.idx,src:bal.src,dat:bal.dat,bit:ActFme.DELETE_FRAME})
if(bal.slv!=null)bal.slv({fmeBit:{idx:"remove-frame",dat:bit.clcBit}});
exportconstcreateFrame=async(cpy:FrameModel,bal:FrameBit,ste:State)=>{
vardat:HoldBit={idx:bal.idx,src:bal.src,typ:'frame'};
for(varkeyinbal.dat){
dat[key]=bal.dat[key]
try{
dat.bit=newPIXI.Graphics();;
}catch(e){
dat.dat={};
if(dat.frm==null)dat.frm=GRAPHIC.ROUNDED_RECTANGLE;
if(dat.w==null)dat.w=333;
if(dat.h==null)dat.h=333;
if(dat.x==null)dat.x=0;
if(dat.y==null)dat.y=0;
if(dat.a==null)dat.a=1;
if(dat.clr==null)dat.clr=0x00FF00;
if(dat.crv==null)dat.crv=13;
if(bal.src!=null)bit=awaitste.hunt(ActVsg.NEST_VISAGE,{src:bal.src,dat})
if(bal.slv!=null)returnbal.slv({fmeBit:{idx:"create-frame",dat:dat}});
exportconstdeleteFrame=async(cpy:FrameModel,bal:FrameBit,ste:State)=>{
if(typeofwindow!="object")returnbal.slv({fceBit:{idx:"error-delete-frame",dat:{}}});
bit=awaitste.hunt(ActFme.READ_FRAME,{idx:bal.idx})
vardat:HoldBit=bit.fmeBit.dat
vargraphic=dat.bit;
graphic.destroy()
dat.bit=null
if(bal.slv!=null)returnbal.slv({fmeBit:{idx:"delete-frame",dat}});
exportdefaultinterfaceFrameBit{
idx:string;
src?:string;
val?:number;
dat?:any;
slv?:Function;
importFrameBitfrom"./frame.bit";
exportdefaultinterfaceFrame{
import*asPIXIfrom'pixi.js';
exportdefaultinterfaceHoldBit{
idx:string;
src?:string;
typ?:string;
frm?:string;
can?:string;
dat?:any;
bit?:PIXI.Graphics;
clr?:number;
crv?:number;
w?:number;
h?:number;
x?:number;
y?:number;
a?:number;
import{Action}from"../99.core/interface/action.interface";
importFrameBitfrom"./fce/frame.bit";
exportconstINIT_FRAME="[Frameaction]InitFrame";
exportclassInitFrameimplementsAction{
readonlytype=INIT_FRAME;
constructor(publicbale:FrameBit){}
exportconstUPDATE_FRAME="[Frameaction]UpdateFrame";
exportclassUpdateFrameimplementsAction{
readonlytype=UPDATE_FRAME;
constructor(publicbale:FrameBit){}
exportconstREAD_FRAME="[Readaction]ReadFrame";
exportclassReadFrameimplementsAction{
readonlytype=READ_FRAME;
constructor(publicbale:FrameBit){}
exportconstWRITE_FRAME="[Writeaction]WriteFrame";
exportclassWriteFrameimplementsAction{
readonlytype=WRITE_FRAME;
constructor(publicbale:FrameBit){}
exportconstREMOVE_FRAME="[Removeaction]RemoveFrame";
exportclassRemoveFrameimplementsAction{
readonlytype=REMOVE_FRAME;
constructor(publicbale:FrameBit){}
exportconstCREATE_FRAME="[Createaction]CreateFrame";
exportclassCreateFrameimplementsAction{
readonlytype=CREATE_FRAME;
constructor(publicbale:FrameBit){}
exportconstDELETE_FRAME="[Deleteaction]DeleteFrame";
exportclassDeleteFrameimplementsAction{
readonlytype=DELETE_FRAME;
constructor(publicbale:FrameBit){}
exporttypeActions=|InitFrame|UpdateFrame
|ReadFrame
|WriteFrame
|RemoveFrame
|CreateFrame
|DeleteFrame
export{initFrame}from"./buz/frame.buzz";
export{updateFrame}from"./buz/frame.buzz";
export{readFrame}from"./buz/frame.buzz";
export{writeFrame}from"./buz/frame.buzz";
export{removeFrame}from"./buz/frame.buzz";
export{createFrame}from"./buz/frame.buzz";
export{deleteFrame}from"./buz/frame.buzz";
importFramefrom"./fce/frame.interface";
importFrameBitfrom"./fce/frame.interface";
exportclassFrameModelimplementsFrame{
import*asclonefrom"clone-deep";
import*asActfrom"./frame.action";
import{FrameModel}from"./frame.model";
import*asBuzzfrom"./frame.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:FrameModel=newFrameModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.UPDATE_FRAME:
returnBuzz.updateFrame(clone(model),act.bale,state);
caseAct.INIT_FRAME:
returnBuzz.initFrame(clone(model),act.bale,state);
caseAct.READ_FRAME:
returnBuzz.readFrame(clone(model),act.bale,state);
caseAct.WRITE_FRAME:
returnBuzz.writeFrame(clone(model),act.bale,state);
caseAct.REMOVE_FRAME:
returnBuzz.removeFrame(clone(model),act.bale,state);
caseAct.CREATE_FRAME:
returnBuzz.createFrame(clone(model),act.bale,state);
caseAct.DELETE_FRAME:
returnBuzz.deleteFrame(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassFrameUnit{
constructor(state:State){
import*asActColfrom"../../97.collect.unit/collect.action";
import*asActFcefrom"../../02.surface.unit/surface.action";
import*asActCanfrom"../../03.container.unit/container.action";
import*asActVsgfrom"../../21.visage.unit/visage.action";
import*asActCamfrom"../../13.camera.unit/camera.action";
varbit,val,idx,dex,lst,dat;
exportconstinitCamera=(cpy:CameraModel,bal:CameraBit,ste:State)=>{
debugger
exportconstupdateCamera=async(cpy:CameraModel,bal:CameraBit,ste:State)=>{
bit=awaitste.hunt(ActCam.READ_CAMERA,{idx:bal.idx})
vardat:LensBit=bit.camBit.dat;
varvsgBit=awaitste.hunt(ActVsg.READ_VISAGE,{idx:"vsg00"})
varcanvas=vsgBit.vsgBit.dat.bit
varx=canvas.width*.5-dat.can.width*.5;
vary=canvas.height*.5-dat.can.height*.5;
x-=bit.x;
y-=bit.y
varauto=dat.can.getGlobalPosition()
dat.twn=gsap.to(dat.bit,{y,x,duration:1,ease:"linear"});
if(bal.slv!=null)returnbal.slv({camBit:{idx:"update-camera",dat}});
exportconstcreateCamera=(cpy:CameraModel,bal:CameraBit,ste:State)=>{
vardat:LensBit={idx:bal.idx,src:bal.src,typ:'core',x:0,y:0};
for(varkeyinbal.dat){
dat[key]=bal.dat[key]
if(bal.slv!=null)returnbal.slv({camBit:{idx:"create-camera",dat}});
exportconstreadCamera=async(cpy:CameraModel,bal:CameraBit,ste:State)=>{
if(bal.idx==null)bal.idx='can00';
bit=awaitste.hunt(ActCol.READ_COLLECT,{idx:bal.idx,bit:ActCam.CREATE_CAMERA})
bal.slv({camBit:{idx:"read-camera",dat:bit.clcBit.dat}});
exportconstwriteCamera=async(cpy:CameraModel,bal:CameraBit,ste:State)=>{
bit=awaitste.hunt(ActCol.WRITE_COLLECT,{idx:bal.idx,src:bal.src,dat:bal.dat,bit:ActCam.CREATE_CAMERA})
ste.hunt(ActCam.UPDATE_CAMERA,{idx:bal.idx})
if(bal.slv!=null)bal.slv({camBit:{idx:"write-camera",dat:bit.clcBit.dat}});
exportconstremoveCamera=(cpy:CameraModel,bal:CameraBit,ste:State)=>{
debugger
exportconstdeleteCamera=(cpy:CameraModel,bal:CameraBit,ste:State)=>{
debugger
import{CameraModel}from"../camera.model";
importCameraBitfrom"../fce/camera.bit";
importStatefrom"../../99.core/state";
importgsapfrom"gsap";
importLensBitfrom"../fce/lens.bit";
import{Action}from"../99.core/interface/action.interface";
importCameraBitfrom"./fce/camera.bit";
exportconstINIT_CAMERA="[Cameraaction]InitCamera";
exportclassInitCameraimplementsAction{
readonlytype=INIT_CAMERA;
constructor(publicbale:CameraBit){}
exportconstUPDATE_CAMERA="[Cameraaction]UpdateCamera";
exportclassUpdateCameraimplementsAction{
readonlytype=UPDATE_CAMERA;
constructor(publicbale:CameraBit){}
exportconstREAD_CAMERA="[Readaction]ReadCamera";
exportclassReadCameraimplementsAction{
readonlytype=READ_CAMERA;
constructor(publicbale:CameraBit){}
exportconstWRITE_CAMERA="[Writeaction]WriteCamera";
exportclassWriteCameraimplementsAction{
readonlytype=WRITE_CAMERA;
constructor(publicbale:CameraBit){}
exportconstREMOVE_CAMERA="[Removeaction]RemoveCamera";
exportclassRemoveCameraimplementsAction{
readonlytype=REMOVE_CAMERA;
constructor(publicbale:CameraBit){}
exportconstDELETE_CAMERA="[Deleteaction]DeleteCamera";
exportclassDeleteCameraimplementsAction{
readonlytype=DELETE_CAMERA;
constructor(publicbale:CameraBit){}
exportconstCREATE_CAMERA="[Createaction]CreateCamera";
exportclassCreateCameraimplementsAction{
readonlytype=CREATE_CAMERA;
constructor(publicbale:CameraBit){}
exporttypeActions=|InitCamera|UpdateCamera
|ReadCamera
|WriteCamera
|RemoveCamera
|DeleteCamera
|CreateCamera
export{initCamera}from"./buz/camera.buzz";
export{updateCamera}from"./buz/camera.buzz";
export{readCamera}from"./buz/camera.buzz";
export{writeCamera}from"./buz/camera.buzz";
export{removeCamera}from"./buz/camera.buzz";
export{deleteCamera}from"./buz/camera.buzz";
export{createCamera}from"./buz/camera.buzz";
importCamerafrom"./fce/camera.interface";
importCameraBitfrom"./fce/camera.interface";
exportclassCameraModelimplementsCamera{
import*asclonefrom"clone-deep";
import*asActfrom"./camera.action";
import{CameraModel}from"./camera.model";
import*asBuzzfrom"./camera.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:CameraModel=newCameraModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.UPDATE_CAMERA:
returnBuzz.updateCamera(clone(model),act.bale,state);
caseAct.INIT_CAMERA:
returnBuzz.initCamera(clone(model),act.bale,state);
caseAct.READ_CAMERA:
returnBuzz.readCamera(clone(model),act.bale,state);
caseAct.WRITE_CAMERA:
returnBuzz.writeCamera(clone(model),act.bale,state);
caseAct.REMOVE_CAMERA:
returnBuzz.removeCamera(clone(model),act.bale,state);
caseAct.DELETE_CAMERA:
returnBuzz.deleteCamera(clone(model),act.bale,state);
caseAct.CREATE_CAMERA:
returnBuzz.createCamera(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassCameraUnit{
constructor(state:State){
exportdefaultinterfaceCameraBit{
idx:string;
src?:string;
val?:number;
dat?:any;
slv?:Function;
importCameraBitfrom"./camera.bit";
exportdefaultinterfaceCamera{
import*asPIXIfrom'pixi.js';;
exportdefaultinterfaceLensBit{
idx:string;
src?:string;
typ?:string;
x:number;
y:number
val?:number;
dat?:any;
bit?:any;
twn?:any;
can?:any
import*asActSdefrom"../../00.shade.unit/shade.action";
import*asActVsgfrom"../../21.visage.unit/visage.action";
import*asActColfrom"../../97.collect.unit/collect.action";
import*asActFcefrom"../../02.surface.unit/surface.action";
import*asActCanfrom"../../03.container.unit/container.action";
import*asActGphfrom"../../04.graphic.unit/graphic.action";
import*asActTxtfrom"../../05.text.unit/text.action";
import*asActSprfrom"../../06.sprite.unit/sprite.action";
import*asActHexfrom"../../07.hexagon.unit/hexagon.action";
import*asActVidfrom"../../11.video.unit/video.action";
import*asActLopfrom"../../09.loop.unit/loop.action";
varbit,val,idx,dex,lst,dat;
exportconstinitVisage=(cpy:VisageModel,bal:VisageBit,ste:State)=>{
exportconstupdateVisage=async(cpy:VisageModel,bal:VisageBit,ste:State)=>{
bit=awaitste.hunt(ActVsg.READ_VISAGE,{idx:bal.idx})
vardat:FrameBit=bit.vsgBit.dat
varfceBit=awaitste.hunt(ActFce.WRITE_SURFACE,{idx:dat.idx,dat:{src:dat.src,width:dat.width,height:dat.height}})
if(bal.slv!=null)bal.slv({vsgBit:{idx:"update-visage",dat}});
exportconstmountVisage=async(cpy:VisageModel,bal:VisageBit,ste:State)=>{
if(typeofwindow!="object")returnbal.slv({fceBit:{idx:"error-size-visage",dat:{}}});
if(bal.dat.h!=null)bal.dat.height=bal.dat.h;
if(bal.dat.w!=null)bal.dat.width=bal.dat.h;
if(bal.dat!=null)bal.dat={width:bal.dat.width,height:bal.dat.height}
elsebal.dat={width:null,height:null}
bal.dat.typ=VISAGE.MOUNT_FULL;
bal.dat
if(bal.dat.height!=null)bal.dat.typ=VISAGE.MOUNT_HEIGHT
if(bal.dat.width!=null)bal.dat.typ=VISAGE.MOUNT_WIDTH
if((bal.dat.height!=null)&&(bal.dat.width!=null))bal.dat.typ=VISAGE.MOUNT_PART
bal.dat.typ
bit=awaitste.hunt(ActVsg.WRITE_VISAGE,{idx:bal.idx,src:bal.src,dat:bal.dat})
if(bal.slv!=null)bal.slv({vsgBit:{idx:"mount-visage",dat:bit.vsgBit.dat}});
exportconstscreenVisage=async(cpy:VisageModel,bal:VisageBit,ste:State)=>{
bit=awaitste.hunt(ActVsg.WRITE_VISAGE,{idx:bal.idx,dat:{typ:VISAGE.SCREEN}})
if(bal.slv!=null)bal.slv({vsgBit:{idx:"sreen-visage",dat:bit.vsgBit.dat}});
exportconstreadVisage=async(cpy:VisageModel,bal:VisageBit,ste:State)=>{
varslv=bal.slv;
if(bal.idx==null)bal.idx='vsg00';
bit=awaitste.hunt(ActCol.READ_COLLECT,{idx:bal.idx,src:bal.src,bit:ActVsg.CREATE_VISAGE})
if(slv!=null)slv({vsgBit:{idx:"read-visage",dat:bit.clcBit.dat}});
exportconstwriteVisage=async(cpy:VisageModel,bal:VisageBit,ste:State)=>{
bit=awaitste.hunt(ActCol.WRITE_COLLECT,{idx:bal.idx,src:bal.src,dat:bal.dat,bit:ActVsg.CREATE_VISAGE})
ste.hunt(ActVsg.UPDATE_VISAGE,{idx:bal.idx})
if(bal.slv!=null)bal.slv({vsgBit:{idx:"write-visage",dat:bit.clcBit.dat}});
exportconstremoveVisage=async(cpy:VisageModel,bal:VisageBit,ste:State)=>{
if(typeofwindow!="object")returnbal.slv({fceBit:{idx:"error-create-visage",dat:{}}});
bit=awaitste.hunt(ActCol.REMOVE_COLLECT,{idx:bal.idx,src:bal.src,dat:bal.dat,bit:ActVsg.DELETE_VISAGE})
if(bal.slv!=null)bal.slv({vsgBit:{idx:"remove-visage",dat:bit.clcBit}});
exportconstcreateVisage=async(cpy:VisageModel,bal:VisageBit,ste:State)=>{
if(typeofwindow!="object")returnbal.slv({fceBit:{idx:"error-create-visage",dat:{}}});
vardat:FrameBit={idx:bal.idx,src:bal.src,typ:bal.dat.typ};
varcanvas:HTMLElement=document.getElementById(dat.src)asHTMLElement;
if(canvas==null){
canvas=document.createElement("canvas");
canvas.id=dat.src;
varbody=document.body;
if(body!=null)body.appendChild(canvas);
dat.bit=canvasasHTMLCanvasElement
dat.parent=dat.bit.parentElement;
dat.height=bal.dat.height;
dat.width=bal.dat.width;
dat.canLst=[];
dat.gphLst=[];
dat.txtLst=[];
dat.sprLst=[];
dat.hexLst=[];
dat.vidLst=[];
dat.lopLst=[];
dat.tonLst=[]
bit=awaitste.hunt(ActVsg.SIZE_VISAGE,{dat})
if(bal.slv!=null)returnbal.slv({vsgBit:{idx:"create-visage",dat}});
exportconstdeleteVisage=async(cpy:VisageModel,bal:VisageBit,ste:State)=>{
if(typeofwindow!="object")returnbal.slv({fceBit:{idx:"error-size-visage",dat:{}}});
bit=awaitste.hunt(ActVsg.READ_VISAGE,{idx:bal.idx})
vardat:FrameBit=bit.vsgBit.dat
dat.canLst.forEach(async(a)=>ste.hunt(ActCan.REMOVE_CONTAINER,{idx:a}))
dat.gphLst.forEach(async(a)=>ste.hunt(ActGph.REMOVE_GRAPHIC,{idx:a}))
dat.txtLst.forEach(async(a)=>ste.hunt(ActTxt.REMOVE_TEXT,{idx:a}))
dat.sprLst.forEach(async(a)=>ste.hunt(ActSpr.REMOVE_SPRITE,{idx:a}))
dat.hexLst.forEach(async(a)=>ste.hunt(ActHex.REMOVE_HEXAGON,{idx:a}))
dat.vidLst.forEach(async(a)=>ste.hunt(ActVid.REMOVE_VIDEO,{idx:a}))
dat.lopLst.forEach(async(a)=>ste.hunt(ActLop.REMOVE_LOOP,{idx:a}))
varfceBit=awaitste.hunt(ActFce.REMOVE_SURFACE,{idx:dat.idx,dat:{src:dat.src}})
constcanvas=dat.bit
if(canvas==null)returnbal.slv({fceBit:{idx:"error-delete-visage",dat:{}}});
constcontext=canvas.getContext('2d');
if(context==null)returnbal.slv({fceBit:{idx:"error-delete-visage",dat:{}}});
context.clearRect(0,0,canvas.width,canvas.height);
context.fillStyle="white";
context.fillRect(0,0,canvas.width,canvas.height);
if(bal.slv!=null)returnbal.slv({vsgBit:{idx:"delete-visage",dat}});
exportconstsizeVisage=async(cpy:VisageModel,bal:VisageBit,ste:State)=>{
vardat:FrameBit=bal.dat;
varw,h;
dat.typ
switch(dat.typ){
caseVISAGE.MOUNT_FULL:
varbody=document.body,
html=document.documentElement;
varheight=Math.max(body.scrollHeight,body.offsetHeight,
html.clientHeight,html.scrollHeight,html.offsetHeight);
varcalcHeight=0
bit=awaitste.hunt(ActCol.FETCH_COLLECT,{val:0,bit:ActVsg.CREATE_VISAGE})
varclcLst=bit.clcBit.dat.bitList
clcLst.forEach((a)=>{
if(a.typ!=VISAGE.MOUNT_HEIGHT)return
calcHeight+=a.height
h=height-calcHeight-5;
w=dat.parent.clientWidth;
break
caseVISAGE.MOUNT_PART:
w=dat.width;
h=dat.height
break
caseVISAGE.MOUNT_HEIGHT:
w=dat.parent.clientWidth;
h=dat.height
break
caseVISAGE.MOUNT_WIDTH:
w=dat.width;
h=dat.parent.clientHeight;
break
constvw=Math.max(w||0)
constvh=Math.max(h||0)
dat.width=vw
dat.height=vh
if(bal.slv!=null)returnbal.slv({vsgBit:{idx:"size-visage",dat}});
exportconstrenderVisage=(cpy:VisageModel,bal:VisageBit,ste:State)=>{
varcanvas=document.getElementById(bal.idx)
varpngUrl=canvas['toDataURL']("image/png")
vardat=pngUrl
varbase64Data=dat.replace(/^data:image\/png;base64,/,"");
exportconstdimensionVisage=async(cpy:VisageModel,bal:VisageBit,ste:State)=>{
if(typeofwindow!="object")returnbal.slv({fceBit:{idx:"error-size-visage",dat:{}}});
bit=awaitste.hunt(ActCol.FETCH_COLLECT,{val:0,bit:ActVsg.CREATE_VISAGE})
varclcLst=bit.clcBit.dat.bitList
clcLst.forEach((a)=>{
sizeVisage(cpy,{idx:a.idx,typ:a.typ,dat:a},ste)
varheight=a.height;
varwidth=a.width;
ste.hunt(ActVsg.WRITE_VISAGE,{idx:a.idx,dat:{width,height}})
exportconstfullscreenVisage=async(cpy:VisageModel,bal:VisageBit,ste:State)=>{
bit=awaitste.hunt(ActVsg.WRITE_VISAGE,{idx:bal.idx,src:bal.src})
if(bal.slv!=null)bal.slv({stgBit:{idx:bal.idx}});
exportconstmainVisage=(cpy:VisageModel,bal:VisageBit,ste:State)=>{
if(typeofwindow!="object")returnbal.slv({fceBit:{idx:"error-size-visage",dat:{}}});
setTimeout(()=>{
if(bal.slv!=null)bal.slv({vsgBit:{idx:"size-visage"}});
},33)
exportconstclearVisage=async(cpy:VisageModel,bal:VisageBit,ste:State)=>{
bit=awaitste.hunt(ActVsg.READ_VISAGE,{idx:bal.idx})
vardat:FrameBit=bit.vsgBit.dat
exportconstlistVisage=async(cpy:VisageModel,bal:VisageBit,ste:State)=>{
dat=null
if(bal.src=='bus')bit=awaitste.bus(ActCol.FETCH_COLLECT,{val:0,bit:ActVsg.CREATE_VISAGE})
elsebit=awaitste.hunt(ActCol.FETCH_COLLECT,{val:0,bit:ActVsg.CREATE_VISAGE})
if(bit.clcBit.dat==null)lst=[]
elsedat=bit.clcBit.dat;
debugger
if(dat!=null){
dat.bitList.forEach((a)=>{
lst=[]
lst.push((a.idx))
if(bal.slv!=null)bal.slv({vsgBit:{idx:'list-visage',lst}});
exportconstnestVisage=async(cpy:VisageModel,bal:VisageBit,ste:State)=>{
bit=awaitste.hunt(ActVsg.READ_VISAGE,{idx:bal.src})
vardat:FrameBit=bit.vsgBit.dat;
switch(bal.dat.typ){
caseSHADE.CONTAINER:
dat.canLst.push(bal.dat.idx)
break
caseSHADE.GRAPHIC:
dat.gphLst.push(bal.dat.idx)
break
caseSHADE.SPRITE:
dat.sprLst.push(bal.dat.idx)
break
caseSHADE.TEXT:
dat.txtLst.push(bal.dat.idx)
caseSHADE.HEXAGON:
dat.hexLst.push(bal.dat.idx)
break
caseSHADE.VIDEO:
dat.vidLst.push(bal.dat.idx)
break
caseSHADE.LOOP:
dat.lopLst.push(bal.dat.idx)
break
bit=awaitste.hunt(ActVsg.WRITE_VISAGE,{idx:bal.src,dat})
if(bal.slv!=null)bal.slv({vsgBit:{idx:'nest-visage'}});
import{VisageModel}from"../visage.model";
importVisageBitfrom"../fce/visage.bit";
importStatefrom"../../99.core/state";
importFrameBitfrom"../fce/frame.bit";
import*asVISAGEfrom"../../val/visage"
import*asSHADEfrom"../../val/shade"
exportdefaultinterfaceFrameBit{
idx:string;
src?:string;
typ?:string;
width?:number;
height?:number;
dex?:number;
parent?:any;
bit?:HTMLCanvasElement
canLst?:string[];
gphLst?:string[];
txtLst?:string[];
sprLst?:string[];
hexLst?:string[];
vidLst?:string[];
lopLst?:string[];
tonLst?:string[];
exportdefaultinterfaceVisageBit{
idx:string;
src?:string;
typ:string;
val?:number;
dat?:any;
slv?:Function;
importVisageBitfrom"./visage.bit";
exportdefaultinterfaceVisage{
import{Action}from"../99.core/interface/action.interface";
importVisageBitfrom"./fce/visage.bit";
exportconstINIT_VISAGE="[Visageaction]InitVisage";
exportclassInitVisageimplementsAction{
readonlytype=INIT_VISAGE;
constructor(publicbale:VisageBit){}
exportconstUPDATE_VISAGE="[Visageaction]UpdateVisage";
exportclassUpdateVisageimplementsAction{
readonlytype=UPDATE_VISAGE;
constructor(publicbale:VisageBit){}
exportconstFULLSCREEN_VISAGE="[Fullscreenaction]FullscreenVisage";
exportclassFullscreenVisageimplementsAction{
readonlytype=FULLSCREEN_VISAGE;
constructor(publicbale:VisageBit){}
exportconstREAD_VISAGE="[Readaction]ReadVisage";
exportclassReadVisageimplementsAction{
readonlytype=READ_VISAGE;
constructor(publicbale:VisageBit){}
exportconstWRITE_VISAGE="[Writeaction]WriteVisage";
exportclassWriteVisageimplementsAction{
readonlytype=WRITE_VISAGE;
constructor(publicbale:VisageBit){}
exportconstREMOVE_VISAGE="[Writeaction]RemoveVisage";
exportclassRemoveVisageimplementsAction{
readonlytype=REMOVE_VISAGE;
constructor(publicbale:VisageBit){}
exportconstCREATE_VISAGE="[Createaction]CreateVisage";
exportclassCreateVisageimplementsAction{
readonlytype=CREATE_VISAGE;
constructor(publicbale:VisageBit){}
exportconstSIZE_VISAGE="[Sizeaction]SizeVisage";
exportclassSizeVisageimplementsAction{
readonlytype=SIZE_VISAGE;
constructor(publicbale:VisageBit){}
exportconstRENDER_VISAGE="[Renderaction]RenderVisage";
exportclassRenderVisageimplementsAction{
readonlytype=RENDER_VISAGE;
constructor(publicbale:VisageBit){}
exportconstDIMENSION_VISAGE="[Dimensionaction]DimensionVisage";
exportclassDimensionVisageimplementsAction{
readonlytype=DIMENSION_VISAGE;
constructor(publicbale:VisageBit){}
exportconstSCREEN_VISAGE="[Screenaction]ScreenVisage";
exportclassScreenVisageimplementsAction{
readonlytype=SCREEN_VISAGE;
constructor(publicbale:VisageBit){}
exportconstMOUNT_VISAGE="[Mountaction]MountVisage";
exportclassMountVisageimplementsAction{
readonlytype=MOUNT_VISAGE;
constructor(publicbale:VisageBit){}
exportconstMAIN_VISAGE="[Mainaction]MainVisage";
exportclassMainVisageimplementsAction{
readonlytype=MAIN_VISAGE;
constructor(publicbale:VisageBit){}
exportconstCLEAR_VISAGE="[Clearaction]ClearVisage";
exportclassClearVisageimplementsAction{
readonlytype=CLEAR_VISAGE;
constructor(publicbale:VisageBit){}
exportconstDELETE_VISAGE="[Deleteaction]DeleteVisage";
exportclassDeleteVisageimplementsAction{
readonlytype=DELETE_VISAGE;
constructor(publicbale:VisageBit){}
exportconstLIST_VISAGE="[Listaction]ListVisage";
exportclassListVisageimplementsAction{
readonlytype=LIST_VISAGE;
constructor(publicbale:VisageBit){}
exportconstNEST_VISAGE="[Nestaction]NestVisage";
exportclassNestVisageimplementsAction{
readonlytype=NEST_VISAGE;
constructor(publicbale:VisageBit){}
exporttypeActions=|InitVisage|UpdateVisage
|FullscreenVisage
|ReadVisage
|WriteVisage
|CreateVisage
|SizeVisage
|RenderVisage
|DimensionVisage
|ScreenVisage
|MountVisage
|MainVisage
|ClearVisage
|DeleteVisage
|ListVisage
|RemoveVisage
|NestVisage
export{initVisage}from"./buz/visage.buzz";
export{updateVisage}from"./buz/visage.buzz";
export{fullscreenVisage}from"./buz/visage.buzz";
export{readVisage}from"./buz/visage.buzz";
export{writeVisage}from"./buz/visage.buzz";
export{removeVisage}from"./buz/visage.buzz";
export{createVisage}from"./buz/visage.buzz";
export{sizeVisage}from"./buz/visage.buzz";
export{renderVisage}from"./buz/visage.buzz";
export{dimensionVisage}from"./buz/visage.buzz";
export{screenVisage}from"./buz/visage.buzz";
export{mountVisage}from"./buz/visage.buzz";
export{mainVisage}from"./buz/visage.buzz";
export{clearVisage}from"./buz/visage.buzz";
export{deleteVisage}from"./buz/visage.buzz";
export{listVisage}from"./buz/visage.buzz";
export{nestVisage}from"./buz/visage.buzz";
importVisagefrom"./fce/visage.interface";
importVisageBitfrom"./fce/visage.interface";
exportclassVisageModelimplementsVisage{
import*asclonefrom"clone-deep";
import*asActfrom"./visage.action";
import{VisageModel}from"./visage.model";
import*asBuzzfrom"./visage.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:VisageModel=newVisageModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.UPDATE_VISAGE:
returnBuzz.updateVisage(clone(model),act.bale,state);
caseAct.INIT_VISAGE:
returnBuzz.initVisage(clone(model),act.bale,state);
caseAct.FULLSCREEN_VISAGE:
returnBuzz.fullscreenVisage(clone(model),act.bale,state);
caseAct.READ_VISAGE:
returnBuzz.readVisage(clone(model),act.bale,state);
caseAct.WRITE_VISAGE:
returnBuzz.writeVisage(clone(model),act.bale,state);
caseAct.CREATE_VISAGE:
returnBuzz.createVisage(clone(model),act.bale,state);
caseAct.SIZE_VISAGE:
returnBuzz.sizeVisage(clone(model),act.bale,state);
caseAct.RENDER_VISAGE:
returnBuzz.renderVisage(clone(model),act.bale,state);
caseAct.DIMENSION_VISAGE:
returnBuzz.dimensionVisage(clone(model),act.bale,state);
caseAct.SCREEN_VISAGE:
returnBuzz.screenVisage(clone(model),act.bale,state);
caseAct.MOUNT_VISAGE:
returnBuzz.mountVisage(clone(model),act.bale,state);
caseAct.MAIN_VISAGE:
returnBuzz.mainVisage(clone(model),act.bale,state);
caseAct.CLEAR_VISAGE:
returnBuzz.clearVisage(clone(model),act.bale,state);
caseAct.DELETE_VISAGE:
returnBuzz.deleteVisage(clone(model),act.bale,state);
caseAct.LIST_VISAGE:
returnBuzz.listVisage(clone(model),act.bale,state);
caseAct.REMOVE_VISAGE:
returnBuzz.removeVisage(clone(model),act.bale,state);
caseAct.NEST_VISAGE:
returnBuzz.nestVisage(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassVisageUnit{
constructor(state:State){
import*asActColfrom"../../97.collect.unit/collect.action";
import*asActFcefrom"../../02.surface.unit/surface.action";
import*asActCanfrom"../../03.container.unit/container.action";
import*asActChrfrom"../../24.chrome.unit/chrome.action";
import*asActVsgfrom"../../21.visage.unit/visage.action";
varbit,val,idx,dex,lst,dat;
exportconstinitChrome=(cpy:ChromeModel,bal:ChromeBit,ste:State)=>{
debugger
exportconstupdateChrome=(cpy:ChromeModel,bal:ChromeBit,ste:State)=>{
exportconstreadChrome=async(cpy:ChromeModel,bal:ChromeBit,ste:State)=>{
varslv=bal.slv;
if(bal.idx==null)bal.idx='ert00';
bit=awaitste.hunt(ActCol.READ_COLLECT,{idx:bal.idx,bit:ActChr.CREATE_CHROME})
if(slv!=null)slv({ambBit:{idx:"read-ambit",dat:bit.clcBit.dat}});
exportconstwriteChrome=async(cpy:ChromeModel,bal:ChromeBit,ste:State)=>{
vardat;
if(bal.src==null){
bit=awaitste.hunt(ActChr.UPDATE_CHROME,bal)
}else{
dat=bal.dat
bit=awaitste.hunt(ActCol.WRITE_COLLECT,{idx:bal.idx,dat,bit:ActChr.CREATE_CHROME})
if(bal.slv!=null)bal.slv({ambBit:{idx:"write-ambit",dat:bit.clcBit.dat}});
exportconstremoveChrome=(cpy:ChromeModel,bal:ChromeBit,ste:State)=>{
debugger
exportconstdeleteChrome=(cpy:ChromeModel,bal:ChromeBit,ste:State)=>{
debugger
exportconstcreateChrome=async(cpy:ChromeModel,bal:ChromeBit,ste:State)=>{
if(bal.idx==null)bal.idx='chr00';
idx=bal.idx
varshi:ShineBit=bal.dat
if(shi.idx==null)shi.idx=bal.idx;
if(shi.src==null)shi.src="chrome-bit";
shi.bit=bit
if(bal.slv!=null)bal.slv({chrBit:{idx:"create-chrome",dat:shi}});
import{ChromeModel}from"../chrome.model";
importChromeBitfrom"../fce/chrome.bit";
importStatefrom"../../99.core/state";
importShineBitfrom"../fce/shine.bit";
import{Action}from"../99.core/interface/action.interface";
importChromeBitfrom"./fce/chrome.bit";
exportconstINIT_CHROME="[Chromeaction]InitChrome";
exportclassInitChromeimplementsAction{
readonlytype=INIT_CHROME;
constructor(publicbale:ChromeBit){}
exportconstUPDATE_CHROME="[Chromeaction]UpdateChrome";
exportclassUpdateChromeimplementsAction{
readonlytype=UPDATE_CHROME;
constructor(publicbale:ChromeBit){}
exportconstREAD_CHROME="[Readaction]ReadChrome";
exportclassReadChromeimplementsAction{
readonlytype=READ_CHROME;
constructor(publicbale:ChromeBit){}
exportconstWRITE_CHROME="[Writeaction]WriteChrome";
exportclassWriteChromeimplementsAction{
readonlytype=WRITE_CHROME;
constructor(publicbale:ChromeBit){}
exportconstREMOVE_CHROME="[Removeaction]RemoveChrome";
exportclassRemoveChromeimplementsAction{
readonlytype=REMOVE_CHROME;
constructor(publicbale:ChromeBit){}
exportconstDELETE_CHROME="[Deleteaction]DeleteChrome";
exportclassDeleteChromeimplementsAction{
readonlytype=DELETE_CHROME;
constructor(publicbale:ChromeBit){}
exportconstCREATE_CHROME="[Createaction]CreateChrome";
exportclassCreateChromeimplementsAction{
readonlytype=CREATE_CHROME;
constructor(publicbale:ChromeBit){}
exporttypeActions=|InitChrome|UpdateChrome
|ReadChrome
|WriteChrome
|RemoveChrome
|DeleteChrome
|CreateChrome
export{initChrome}from"./buz/chrome.buzz";
export{updateChrome}from"./buz/chrome.buzz";
export{readChrome}from"./buz/chrome.buzz";
export{writeChrome}from"./buz/chrome.buzz";
export{removeChrome}from"./buz/chrome.buzz";
export{deleteChrome}from"./buz/chrome.buzz";
export{createChrome}from"./buz/chrome.buzz";
importChromefrom"./fce/chrome.interface";
importChromeBitfrom"./fce/chrome.interface";
exportclassChromeModelimplementsChrome{
import*asclonefrom"clone-deep";
import*asActfrom"./chrome.action";
import{ChromeModel}from"./chrome.model";
import*asBuzzfrom"./chrome.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:ChromeModel=newChromeModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.UPDATE_CHROME:
returnBuzz.updateChrome(clone(model),act.bale,state);
caseAct.INIT_CHROME:
returnBuzz.initChrome(clone(model),act.bale,state);
caseAct.READ_CHROME:
returnBuzz.readChrome(clone(model),act.bale,state);
caseAct.WRITE_CHROME:
returnBuzz.writeChrome(clone(model),act.bale,state);
caseAct.REMOVE_CHROME:
returnBuzz.removeChrome(clone(model),act.bale,state);
caseAct.DELETE_CHROME:
returnBuzz.deleteChrome(clone(model),act.bale,state);
caseAct.CREATE_CHROME:
returnBuzz.createChrome(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassChromeUnit{
constructor(state:State){
import*asPIXIfrom'pixi.js';
exportdefaultinterfaceChromeBit{
idx:string;
src?:string;
typ?:string;
x:number;
y:number
slv?:any;
val?:number;
dat?:any;
bit?:PIXI.Graphics;
importChromeBitfrom"./chrome.bit";
exportdefaultinterfaceChrome{
import*asPIXIfrom'pixi.js';;
exportdefaultinterfaceShineBit{
idx:string;
src?:string;
typ?:string;
x:number;
y:number
val?:number;
dat?:any;
bit?:PIXI.Graphics;
import*asActColfrom'../../97.collect.unit/collect.action';
varbit,lst,dat,idx,val,src,dex;
exportconstinitCollect=(cpy:CollectModel,bal:CollectBit,ste:State)=>{
exportconstupdateCollect=(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
exportconstfetchCollect=(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
if(bal.val==null)bal.val=1;
if(bal.bit==null)
bal.slv({clcBit:{idx:'fetch-collect-err',src:'no-bit'}});
vartype=bal.bit.split('').slice(-1).pop().toLowerCase();
varcabBit:CaboodleBit=cpy.caboodleBitList[cpy.caboodleBits[type]];
if(bal.val==1)bit=cabBit.bitList[0];
elsebit=cabBit;
if(bal.slv!=null)bal.slv({clcBit:{idx:'fetch-collect',dat:bit}});
exportconstreadCollect=async(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
if(bal.bit==null)
bal.slv({clcBit:{idx:'read-collect-err',src:'no-bit'}});
vartype=bal.bit.split('').slice(-1).pop().toLowerCase();
if(cpy.caboodleBits[type]==null)createCollect(cpy,{idx:type},ste);
varcabBit:CaboodleBit=cpy.caboodleBitList[cpy.caboodleBits[type]];
if(cabBit.bits[bal.idx]==null){
bit=awaitste.hunt(ActCol.WRITE_COLLECT,{
idx:bal.idx,
src:bal.src,
bit:bal.bit,
}else{
dat=cabBit.bitList[cabBit.bits[bal.idx]];
if(bal.slv!=null)bal.slv({clcBit:{idx:'read-collect',dat}});
exportconstwriteCollect=async(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
dat=null;
vartype=bal.bit.split('').slice(-1).pop().toLowerCase();
if(cpy.caboodleBits[type]==null)createCollect(cpy,{idx:type},ste);
if(bal.bit==null)
bal.slv({rskBit:{idx:'write-collect-err',src:'no-bit'}});
varcabBit:CaboodleBit=cpy.caboodleBitList[cpy.caboodleBits[type]];
bal.idx;
val=0;
if(cabBit.bits[bal.idx]==null){
bit=awaitste.hunt(bal.bit,{idx:bal.idx,src:bal.src,dat:bal.dat});
varobjDat=bit[Object.keys(bit)[0]];
dat=objDat.dat;
if(dat==null)dat={};
dat.dex=cabBit.bitList.length;
cabBit.bitList.push(dat);
varidx=bal.idx;
if(idx==null)idx=dat.idx;
if(idx==null)thrownewError('writecollecthasnoidx');
cabBit.bits[idx]=dat.dex;
}else{
varcabDat=cabBit.bitList[cabBit.bits[bal.idx]];
bal.dat;
val=1;
for(varkeyinbal.dat){
if(cabDat==null)cabDat={};
cabDat[key]=bal.dat[key];
cabBit.bitList[cabBit.bits[bal.idx]]=cabDat;
dat=cabDat;
if(dat==null&&bal.slv!=null)
bal.slv({rskBit:{idx:'write-collect-err',src:'no-dat'}});
if(bal.slv!=null)bal.slv({clcBit:{idx:'write-collect',val,dat}});
exportconstcreateCollect=(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
varcabBit:CaboodleBit={idx:bal.idx,dex:0,bits:{},bitList:[]};
cabBit.dex=cpy.caboodleBitList.length;
cpy.caboodleBitList.push(cabBit);
cpy.caboodleBits[cabBit.idx]=cabBit.dex;
if(bal.slv!=null)
bal.slv({clcBit:{idx:'create-collect',dat:cabBit}});
exportconstremoveCollect=async(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
vartype=bal.bit.split('').slice(-1).pop().toLowerCase();
if(cpy.caboodleBits[type]==null)
returnbal.slv({rskBit:{idx:'remove-collect-not-present'}});
varcabBit:CaboodleBit=cpy.caboodleBitList[cpy.caboodleBits[type]];
if(cabBit.bits[bal.idx]==null)
returnbal.slv({rskBit:{idx:'remove-collect-idx-not-present'}});
bit=awaitste.hunt(bal.bit,{idx:bal.idx,src:bal.src,dat:bal.dat});
varobjDat=bit[Object.keys(bit)[0]];
dat=objDat.dat;
dex=dat.dex;
for(vari=dex;i<cabBit.bitList.length-1;i++){
varupdate=cabBit.bitList[i];
update.dex-=1;
for(varkeyindat){
dat[key]=null;
deletecabBit.bits[bal.idx];
varitm=cabBit.bitList.splice(dex,1);
cabBit.dex-=1;
if(bal.slv!=null)
bal.slv({clcBit:{idx:'remove-collect',dat:itm[0]}});
exportconstputCollect=(cpy:CollectModel,bal:CollectBit,ste:State)=>{
cpy.caboodleBits[bal.idx]=bal.val;
cpy.caboodleBitList[bal.val]=bal.dat;
if(bal.slv!=null)
bal.slv({clcBit:{idx:'put-collect',dat:bal.dat}});
exportconstgetCollect=(cpy:CollectModel,bal:CollectBit,ste:State)=>{
val=cpy.caboodleBits[bal.idx];
dat=cpy.caboodleBitList[val];
if(bal.slv!=null)bal.slv({clcBit:{idx:'get-collect',val,dat}});
exportconstmodelCollect=(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
if(bal.slv!=null)bal.slv({clcBit:{idx:'model-collect',dat:cpy}});
exportconstdeleteCollect=(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
exportconstemptyCollect=(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
exportconstdotCollect=(cpy:CollectModel,bal:CollectBit,ste:State)=>{
vargel=bal.dat;
varout=[];
bal.src.split('\n').forEach((a,b)=>{
vardoTCompiled=doT.template(a);
varoutLine=doTCompiled(gel);
out.push(outLine);
if(bal.slv!=null)
bal.slv({clcBit:{idx:'dot-vurt',lst:out,src:out.join('\n')}});
exportconstformatCollect=(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
lst=bal.src.split(':');
varidx=lst[0];
varout=[];
idx=S(idx).collapseWhitespace().s;
varopt=lst[1].split(',');
opt.forEach((a,b)=>{
varnow=S(a).collapseWhitespace().s;
if(a.length<1)return;
out.push(now);
dat=[idx,out];
bal.slv({clcBit:{idx:'format-collect',dat}});
exportconstlistCollect=(cpy:CollectModel,bal:CollectBit,ste:State)=>{
vartype=bal.bit.split('').slice(-1).pop().toLowerCase();
if(cpy.caboodleBits[type]==null)createCollect(cpy,{idx:type},ste);
varcabBit:CaboodleBit=cpy.caboodleBitList[cpy.caboodleBits[type]];
lst=[];
cabBit.bitList.forEach((a)=>{
if(a.idx!=null)lst.push(a.idx);
if(a.id!=null)lst.push(a.id);
bal.slv({clcBit:{idx:'list-collect',lst}});
exportconsthashCollect=(cpy:CollectModel,bal:CollectBit,ste:State)=>{
if(bal.src==null)bal.src='';
lst=bal.src.split('\n');
dat={};
lst.forEach((a)=>{
a=S(a).collapseWhitespace().s;
if(a.length<3)return;
varhold=a.split(':');
vardom=hold[0];
varsub=hold[1];
varnow=sub.split(',');
now.forEach((b,c)=>{
now[c]=S(b).collapseWhitespace().s;
dat[dom]=now;
bal.slv({clcBit:{idx:'hash-collect',dat}});
import{CollectModel}from'../collect.model';
importCollectBitfrom'../fce/collect.bit';
importStatefrom'../../99.core/state';
importCaboodleBitfrom'../fce/caboodle.bit';
import*asSfrom'string';
import*asdoTfrom'dot';
import{Action}from"../99.core/interface/action.interface";
importCollectBitfrom"./fce/collect.bit";
exportconstINIT_COLLECT="[Collectaction]InitCollect";
exportclassInitCollectimplementsAction{
readonlytype=INIT_COLLECT;
constructor(publicbale:CollectBit){}
exportconstUPDATE_COLLECT="[Collectaction]UpdateCollect";
exportclassUpdateCollectimplementsAction{
readonlytype=UPDATE_COLLECT;
constructor(publicbale:CollectBit){}
exportconstFETCH_COLLECT="[Collectaction]FetchCollect";
exportclassFetchCollectimplementsAction{
readonlytype=FETCH_COLLECT;
constructor(publicbale:CollectBit){}
exportconstREAD_COLLECT="[Readaction]ReadCollect";
exportclassReadCollectimplementsAction{
readonlytype=READ_COLLECT;
constructor(publicbale:CollectBit){}
exportconstWRITE_COLLECT="[Writeaction]WriteCollect";
exportclassWriteCollectimplementsAction{
readonlytype=WRITE_COLLECT;
constructor(publicbale:CollectBit){}
exportconstCREATE_COLLECT="[Createaction]CreateCollect";
exportclassCreateCollectimplementsAction{
readonlytype=CREATE_COLLECT;
constructor(publicbale:CollectBit){}
exportconstREMOVE_COLLECT="[Createaction]RemoveCollect";
exportclassRemoveCollectimplementsAction{
readonlytype=REMOVE_COLLECT;
constructor(publicbale:CollectBit){}
exportconstDELETE_COLLECT="[Createaction]DeleteCollect";
exportclassDeleteCollectimplementsAction{
readonlytype=DELETE_COLLECT;
constructor(publicbale:CollectBit){}
exportconstEMPTY_COLLECT="[Emptyaction]EmptyCollect";
exportclassEmptyCollectimplementsAction{
readonlytype=EMPTY_COLLECT;
constructor(publicbale:CollectBit){}
exportconstMODEL_COLLECT="[Emptyaction]ModelCollect";
exportclassModelCollectimplementsAction{
readonlytype=MODEL_COLLECT;
constructor(publicbale:CollectBit){}
exportconstPUT_COLLECT="[Emptyaction]PutCollect";
exportclassPutCollectimplementsAction{
readonlytype=PUT_COLLECT;
constructor(publicbale:CollectBit){}
exportconstGET_COLLECT="[Emptyaction]GetCollect";
exportclassGetCollectimplementsAction{
readonlytype=GET_COLLECT;
constructor(publicbale:CollectBit){}
exportconstFORMAT_COLLECT="[Formataction]FormatCollect";
exportclassFormatCollectimplementsAction{
readonlytype=FORMAT_COLLECT;
constructor(publicbale:CollectBit){}
exportconstDOT_COLLECT="[Formataction]DotCollect";
exportclassDotCollectimplementsAction{
readonlytype=DOT_COLLECT;
constructor(publicbale:CollectBit){}
exportconstLIST_COLLECT="[Listaction]ListCollect";
exportclassListCollectimplementsAction{
readonlytype=LIST_COLLECT;
constructor(publicbale:CollectBit){}
exportconstHASH_COLLECT="[Hashaction]HashCollect";
exportclassHashCollectimplementsAction{
readonlytype=HASH_COLLECT;
constructor(publicbale:CollectBit){}
exporttypeActions=|InitCollect|UpdateCollect
|ReadCollect
|WriteCollect
|CreateCollect
|EmptyCollect
|FetchCollect
|DeleteCollect
|RemoveCollect
|ModelCollect
|GetCollect
|PutCollect
|FormatCollect
|DotCollect
|ListCollect
|HashCollect
export{initCollect}from"./buz/collect.buzz";
export{updateCollect}from"./buz/collect.buzz";
export{readCollect}from"./buz/collect.buzz";
export{writeCollect}from"./buz/collect.buzz";
export{createCollect}from"./buz/collect.buzz";
export{emptyCollect}from"./buz/collect.buzz";
export{fetchCollect}from"./buz/collect.buzz";
export{deleteCollect}from"./buz/collect.buzz";
export{removeCollect}from"./buz/collect.buzz";
export{modelCollect}from"./buz/collect.buzz";
export{putCollect}from"./buz/collect.buzz";
export{getCollect}from"./buz/collect.buzz";
export{formatCollect}from"./buz/collect.buzz";
export{dotCollect}from"./buz/collect.buzz";
export{listCollect}from"./buz/collect.buzz";
export{hashCollect}from"./buz/collect.buzz";
importCaboodleBitfrom"./fce/caboodle.bit";
importCollectfrom"./fce/collect.interface";
importCollectBitfrom"./fce/collect.interface";
exportclassCollectModelimplementsCollect{
idx:string='23.11.14';
caboodleBitList:CaboodleBit[]=[];
caboodleBits:any={};
import*asclonefrom"clone-deep";
import*asActfrom"./collect.action";
import{CollectModel}from"./collect.model";
import*asBuzzfrom"./collect.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:CollectModel=newCollectModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.UPDATE_COLLECT:
returnBuzz.updateCollect(clone(model),act.bale,state);
caseAct.INIT_COLLECT:
returnBuzz.initCollect(clone(model),act.bale,state);
caseAct.READ_COLLECT:
returnBuzz.readCollect(clone(model),act.bale,state);
caseAct.WRITE_COLLECT:
returnBuzz.writeCollect(clone(model),act.bale,state);
caseAct.CREATE_COLLECT:
returnBuzz.createCollect(clone(model),act.bale,state);
caseAct.DELETE_COLLECT:
returnBuzz.deleteCollect(clone(model),act.bale,state);
caseAct.REMOVE_COLLECT:
returnBuzz.removeCollect(clone(model),act.bale,state);
caseAct.EMPTY_COLLECT:
returnBuzz.emptyCollect(clone(model),act.bale,state);
caseAct.FETCH_COLLECT:
returnBuzz.fetchCollect(clone(model),act.bale,state);
caseAct.MODEL_COLLECT:
returnBuzz.modelCollect(clone(model),act.bale,state);
caseAct.GET_COLLECT:
returnBuzz.getCollect(clone(model),act.bale,state);
caseAct.PUT_COLLECT:
returnBuzz.putCollect(clone(model),act.bale,state);
caseAct.FORMAT_COLLECT:
returnBuzz.formatCollect(clone(model),act.bale,state);
caseAct.DOT_COLLECT:
returnBuzz.dotCollect(clone(model),act.bale,state);
caseAct.LIST_COLLECT:
returnBuzz.listCollect(clone(model),act.bale,state);
caseAct.HASH_COLLECT:
returnBuzz.hashCollect(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassCollectUnit{
constructor(state:State){
exportdefaultinterfaceCaboodleBit{
idx:string;
dex:number;
bitList:any[];
bits:any;
exportdefaultinterfaceCollectBit{
idx?:string;
src?:string;
val?:number;
dex?:number;
dat?:any;
bit?:any;
slv?:Function;
importCollectBitfrom"./collect.bit";
importCaboodleBitfrom"./caboodle.bit";
exportdefaultinterfaceCollect{
idx:string;
caboodleBitList:CaboodleBit[];
caboodleBits:any;
import*asActMnufrom"../menu.action";
import*asActShdfrom"../../00.shade.unit/shade.action";
import*asActVsgfrom"../../21.visage.unit/visage.action"
import*asActVrtfrom"../../act/vurt.action"
import*asActTrmfrom"../../act/terminal.action";
varbit,lst,dex
exportconstinitMenu=async(cpy:MenuModel,bal:MenuBit,ste:State)=>{
if(bal==null)bal={idx:null}
bit=awaitste.bus(ActTrm.INIT_TERMINAL,{})
updateMenu(cpy,bal,ste);
exportconstupdateMenu=async(cpy:MenuModel,bal:MenuBit,ste:State)=>{
bit=awaitste.bus(ActTrm.WRITE_TERMINAL,{src:"-----------",bit:'local'})
bit=awaitste.bus(ActTrm.WRITE_TERMINAL,{src:"SHADEPIVOTV1.1",bit:'local'})
bit=awaitste.bus(ActTrm.WRITE_TERMINAL,{src:"-----------",bit:"local"})
varlst=[ActShd.UPDATE_SHADE,ActShd.OPEN_SHADE,ActShd.TEST_SHADE,
ActShd.RUN_SHADE,ActShd.EDIT_SHADE,ActMnu.CONTAINER_MENU,
ActMnu.TEXT_MENU,ActMnu.VISAGE_MENU]
bit=awaitste.bus(ActTrm.UPDATE_TERMINAL,{lst})
bit=bit.trmBit;
varidx=lst[bit.val];
switch(idx){
caseActMnu.TEXT_MENU:
bit=awaitste.hunt(ActMnu.TEXT_MENU,{})
break;
caseActShd.TEST_SHADE:
ste.hunt(ActShd.TEST_SHADE,{})
break;
caseActMnu.CONTAINER_MENU:
bit=awaitste.hunt(ActMnu.CONTAINER_MENU,{})
break;
caseActMnu.VISAGE_MENU:
bit=awaitste.hunt(ActMnu.VISAGE_MENU,{})
break;
caseActMnu.SHADE_MENU:
bit=awaitste.hunt(ActMnu.SHADE_MENU,{})
break;
caseActShd.OPEN_SHADE:
bit=awaitste.hunt(ActShd.OPEN_SHADE,{})
break;
caseActShd.BROWSER_SHADE:
bit=awaitste.hunt(ActShd.BROWSER_SHADE,{})
break;
caseActShd.RUN_SHADE:
bit=awaitste.hunt(ActShd.RUN_SHADE,{})
break;
caseActShd.UPDATE_SHADE:
bit=awaitste.hunt(ActShd.UPDATE_SHADE,{})
break;
caseActShd.EDIT_SHADE:
bit=awaitste.hunt(ActShd.EDIT_SHADE,{})
bit=awaitste.bus(ActTrm.WRITE_TERMINAL,{src:"PATCHING...",bit:'local'})
bit=awaitste.bus(ActTrm.WRITE_TERMINAL,{src:"-----------",bit:"local"})
lst=[ActShd.PATCH_SHADE]
bit=awaitste.bus(ActTrm.UPDATE_TERMINAL,{lst})
bit=awaitste.hunt(ActShd.PATCH_SHADE,{})
break;
default:
bit=awaitawaitste.bus(ActTrm.CLOSE_TERMINAL,{})
break;
updateMenu(cpy,bal,ste);
exportconsttestMenu=async(cpy:MenuModel,bal:MenuBit,ste:State)=>{
exportconstcloseMenu=async(cpy:MenuModel,bal:MenuBit,ste:State)=>{
awaitste.bus(ActTrm.CLOSE_TERMINAL,{})
exportconstshadeMenu=async(cpy:MenuModel,bal:MenuBit,ste:State)=>{
bit=awaitste.bus(ActTrm.WRITE_TERMINAL,{src:"-----------",bit:'local'})
bit=awaitste.bus(ActTrm.WRITE_TERMINAL,{src:"SHADEPIVOTV0",bit:'local'})
bit=awaitste.bus(ActTrm.WRITE_TERMINAL,{src:"-----------",bit:"local"})
varlst=[ActMnu.VISAGE_MENU]
bit=awaitste.bus(ActTrm.UPDATE_TERMINAL,{lst})
bit=bit.trmBit;
varidx=lst[bit.val];
switch(idx){
caseActMnu.VISAGE_MENU:
bit=awaitste.hunt(ActMnu.VISAGE_MENU,{})
break;
default:
bit=awaitawaitste.hunt(ActMnu.UPDATE_MENU,{})
break;
shadeMenu(cpy,bal,ste)
varpatch=(ste,type,bale)=>ste.dispatch({type,bale});
exportconstvisageMenu=(cpy:MenuModel,bal:MenuBit,ste:State)=>{
debugger
import{MenuModel}from"../menu.model";
importMenuBitfrom"../fce/menu.bit";
importStatefrom"../../99.core/state";
import*asActMnufrom"../menu.action";
import*asActShdfrom"../../00.shade.unit/shade.action";
import*asActVsgfrom"../../21.visage.unit/visage.action"
import*asActCanfrom"../../03.container.unit/container.action"
import*asActTrmfrom"../../act/terminal.action";
varbit,lst,dex,src;
exportconstcontainerMenu=async(cpy:MenuModel,bal:MenuBit,ste:State)=>{
bit=awaitste.bus(ActTrm.WRITE_TERMINAL,{src:"-----------",bit:'local'})
bit=awaitste.bus(ActTrm.WRITE_TERMINAL,{src:"ContainerMenu",bit:'local'})
bit=awaitste.bus(ActTrm.WRITE_TERMINAL,{src:"-----------",bit:"local"})
varlst=[ActCan.WRITE_CONTAINER,ActCan.ADD_CONTAINER,ActCan.LIST_CONTAINER,ActMnu.UPDATE_MENU]
bit=awaitste.bus(ActTrm.UPDATE_TERMINAL,{lst})
bit=bit.trmBit;
varidx=lst[bit.val];
switch(idx){
caseActCan.WRITE_CONTAINER:
debugger
bit=awaitste.bus(ActVsg.LIST_VISAGE,{src:'bus'})
debugger
if(bit.vsgBit==null)bit.vsgBit={lst:[]}
lst=bit.vsgBit.lst;
if(lst.length==0){
bit=awaitste.bus(ActTrm.WRITE_TERMINAL,{src:"Visagepresent:0",bit:'local'})
bit=awaitawaitste.hunt(ActMnu.CONTAINER_MENU,{})
return
bit=awaitste.bus(ActTrm.UPDATE_TERMINAL,{lst})
bit=bit.trmBit;
src=lst[bit.val];
bit=awaitste.bus(ActTrm.WRITE_TERMINAL,{src:"Connectingto"+src,bit:'local'})
bit=awaitste.bus(ActTrm.INPUT_TERMINAL,{lst:["","identify..."]});
idx=bit.trmBit.src
bit=awaitste.bus(ActCan.WRITE_CONTAINER,{idx,src})
bit=awaitawaitste.hunt(ActMnu.CONTAINER_MENU,{})
break;
caseActCan.ADD_CONTAINER:
bit=awaitste.bus(ActVsg.MOUNT_VISAGE,{idx:"vsg00",src:"indexCanvas",dat:{height:720}},'remote')
bit=awaitawaitste.hunt(ActMnu.VISAGE_MENU,{})
break;
caseActCan.LIST_CONTAINER:
bit=awaitste.bus(ActCan.LIST_CONTAINER,{src:'bus'})
debugger
bit=awaitawaitste.hunt(ActMnu.CONTAINER_MENU,{})
break;
default:
bit=awaitawaitste.hunt(ActMnu.UPDATE_MENU,{})
break;
varpatch=(ste,type,bale)=>ste.dispatch({type,bale});
import{MenuModel}from"../menu.model";
importMenuBitfrom"../fce/menu.bit";
importStatefrom"../../99.core/state";
import*asActMnufrom"../menu.action";
import*asActShdfrom"../../00.shade.unit/shade.action";
import*asActVsgfrom"../../21.visage.unit/visage.action"
import*asActCanfrom"../../03.container.unit/container.action"
import*asActTxtfrom"../../05.text.unit/text.action"
import*asActTrmfrom"../../act/terminal.action";
varbit,lst,dex,src;
exportconstsurfaceMenu=async(cpy:MenuModel,bal:MenuBit,ste:State)=>{
bit=awaitste.bus(ActTrm.WRITE_TERMINAL,{src:"-----------",bit:'local'})
bit=awaitste.bus(ActTrm.WRITE_TERMINAL,{src:"SurfaceMenu",bit:'local'})
bit=awaitste.bus(ActTrm.WRITE_TERMINAL,{src:"-----------",bit:"local"})
varlst=[ActTxt.WRITE_TEXT,ActTxt.READ_TEXT,ActMnu.UPDATE_MENU]
bit=awaitste.bus(ActTrm.UPDATE_TERMINAL,{lst})
bit=bit.trmBit;
varidx=lst[bit.val];
switch(idx){
caseActTxt.WRITE_TEXT:
bit=bit.trmBit;
src=lst[bit.val];
bit=awaitste.bus(ActTrm.WRITE_TERMINAL,{src:"Connectingto"+src,bit:'local'})
bit=awaitste.bus(ActTrm.INPUT_TERMINAL,{lst:["","identify..."]});
idx=bit.trmBit.src
bit=awaitste.bus(ActTxt.WRITE_TEXT,{idx,src})
bit=awaitawaitste.hunt(ActMnu.VISAGE_MENU,{})
break;
caseActTxt.READ_TEXT:
bit=awaitste.bus(ActVsg.MOUNT_VISAGE,{idx:"vsg00",src:"indexCanvas",dat:{height:720}},'remote')
bit=awaitawaitste.hunt(ActMnu.VISAGE_MENU,{})
break;
default:
bit=awaitawaitste.hunt(ActMnu.UPDATE_MENU,{})
break;
varpatch=(ste,type,bale)=>ste.dispatch({type,bale});
import{MenuModel}from"../menu.model";
importMenuBitfrom"../fce/menu.bit";
importStatefrom"../../99.core/state";
import*asActMnufrom"../menu.action";
import*asActShdfrom"../../00.shade.unit/shade.action";
import*asActVsgfrom"../../21.visage.unit/visage.action"
import*asActCanfrom"../../03.container.unit/container.action"
import*asActTxtfrom"../../05.text.unit/text.action"
import*asActTrmfrom"../../act/terminal.action";
varbit,lst,dex,src;
exportconsttextMenu=async(cpy:MenuModel,bal:MenuBit,ste:State)=>{
bit=awaitste.bus(ActTrm.WRITE_TERMINAL,{src:"-----------",bit:'local'})
bit=awaitste.bus(ActTrm.WRITE_TERMINAL,{src:"TextMenu",bit:'local'})
bit=awaitste.bus(ActTrm.WRITE_TERMINAL,{src:"-----------",bit:"local"})
varlst=[ActTxt.WRITE_TEXT,ActTxt.READ_TEXT,ActMnu.UPDATE_MENU]
bit=awaitste.bus(ActTrm.UPDATE_TERMINAL,{lst})
bit=bit.trmBit;
varidx=lst[bit.val];
switch(idx){
caseActTxt.WRITE_TEXT:
bit=bit.trmBit;
src=lst[bit.val];
bit=awaitste.bus(ActTrm.WRITE_TERMINAL,{src:"Connectingto"+src,bit:'local'})
bit=awaitste.bus(ActTrm.INPUT_TERMINAL,{lst:["","identify..."]});
idx=bit.trmBit.src
bit=awaitste.bus(ActTxt.WRITE_TEXT,{idx,src})
bit=awaitawaitste.hunt(ActMnu.VISAGE_MENU,{})
break;
caseActTxt.READ_TEXT:
bit=awaitste.bus(ActVsg.MOUNT_VISAGE,{idx:"vsg00",src:"indexCanvas",dat:{height:720}},'remote')
bit=awaitawaitste.hunt(ActMnu.VISAGE_MENU,{})
break;
default:
bit=awaitawaitste.hunt(ActMnu.UPDATE_MENU,{})
break;
varpatch=(ste,type,bale)=>ste.dispatch({type,bale});
import{MenuModel}from"../menu.model";
importMenuBitfrom"../fce/menu.bit";
importStatefrom"../../99.core/state";
import*asActMnufrom"../menu.action";
import*asActShdfrom"../../00.shade.unit/shade.action";
import*asActVsgfrom"../../21.visage.unit/visage.action"
import*asActTrmfrom"../../act/terminal.action";
varbit,lst,dex
varcurrent='None'
exportconstvisageMenu=async(cpy:MenuModel,bal:MenuBit,ste:State)=>{
bit=awaitste.bus(ActTrm.WRITE_TERMINAL,{src:"-----------",bit:'local'})
bit=awaitste.bus(ActTrm.WRITE_TERMINAL,{src:"VisagePIVOTV0",bit:'local'})
bit=awaitste.bus(ActTrm.WRITE_TERMINAL,{src:"Current"+current,bit:'local'})
bit=awaitste.bus(ActTrm.WRITE_TERMINAL,{src:"-----------",bit:"local"})
varlst=[ActVsg.LIST_VISAGE,ActVsg.MOUNT_VISAGE,ActVsg.REMOVE_VISAGE,ActMnu.UPDATE_MENU]
bit=awaitste.bus(ActTrm.UPDATE_TERMINAL,{lst})
bit=bit.trmBit;
varidx=lst[bit.val];
switch(idx){
caseActVsg.LIST_VISAGE:
debugger
bit=awaitste.bus(ActVsg.LIST_VISAGE,{src:'bus'});
debugger
lst=bit.vsgBit.lst;
bit=awaitste.bus(ActTrm.UPDATE_TERMINAL,{lst})
bit=bit.trmBit;
idx=lst[bit.val];
current=idx
bit=awaitawaitste.hunt(ActMnu.VISAGE_MENU,{})
break;
caseActVsg.MOUNT_VISAGE:
bit=awaitste.bus(ActTrm.INPUT_TERMINAL,{lst:["","VisageIDX"]});
idx=bit.trmBit.src
varbit=awaitste.bus(ActVsg.MOUNT_VISAGE,{idx,src:"indexCanvas",dat:{}});
current=idx
bit=awaitawaitste.hunt(ActMnu.VISAGE_MENU,{})
break;
caseActVsg.REMOVE_VISAGE:
bit=awaitste.bus(ActVsg.LIST_VISAGE,{src:'bus'},'remote')
if(bit.vsgBit==null)bit.vsgBit={lst:[]}
lst=bit.vsgBit.lst;
if(lst.length==0){
bit=awaitste.bus(ActTrm.WRITE_TERMINAL,{src:"Visagepresent:0",bit:'local'})
bit=awaitawaitste.hunt(ActMnu.VISAGE_MENU,{})
return
bit=awaitste.bus(ActTrm.UPDATE_TERMINAL,{lst})
bit=bit.trmBit;
idx=lst[bit.val];
bit=awaitste.bus(ActVsg.REMOVE_VISAGE,{idx},'remote')
bit=awaitawaitste.hunt(ActMnu.VISAGE_MENU,{})
break;
caseActVsg.FULLSCREEN_VISAGE:
bit=awaitste.bus(ActVsg.FULLSCREEN_VISAGE,{},'remote')
bit=awaitawaitste.hunt(ActMnu.VISAGE_MENU,{})
break;
caseActVsg.SIZE_VISAGE:
bit=awaitste.bus(ActTrm.INPUT_TERMINAL,{lst:["","WVALUE"]});
varw=Number(bit.trmBit.src);
bit=awaitste.bus(ActTrm.INPUT_TERMINAL,{lst:["","HVALUE"]});
varh=Number(bit.trmBit.src);
bit=awaitste.bus(ActVsg.SIZE_VISAGE,{dat:{w,h}},'remote')
bit=awaitawaitste.hunt(ActMnu.VISAGE_MENU,{})
break;
caseActMnu.UPDATE_MENU:
bit=awaitawaitste.hunt(ActMnu.UPDATE_MENU,{})
break;
default:
bit=awaitawaitste.hunt(ActMnu.UPDATE_MENU,{})
break;
varpatch=(ste,type,bale)=>ste.dispatch({type,bale});
import{MenuModel}from"../menu.model";
importMenuBitfrom"../fce/menu.bit";
importStatefrom"../../99.core/state";
exportdefaultinterfaceMenuBit{
idx:string;
src?:string;
lst?:any;
importMenuBitfrom"./menu.bit";
exportdefaultinterfaceMenu{
import{Action}from"../99.core/interface/action.interface";
importMenuBitfrom"./fce/menu.bit";
exportconstINIT_MENU="[Menuaction]InitMenu";
exportclassInitMenuimplementsAction{
readonlytype=INIT_MENU;
constructor(publicbale:MenuBit){}
exportconstUPDATE_MENU="[Menuaction]UpdateMenu";
exportclassUpdateMenuimplementsAction{
readonlytype=UPDATE_MENU;
constructor(publicbale:MenuBit){}
exportconstTEST_MENU="[Menuaction]TestMenu";
exportclassTestMenuimplementsAction{
readonlytype=TEST_MENU;
constructor(publicbale:MenuBit){}
exportconstCLOSE_MENU="[Menuaction]CloseMenu";
exportclassCloseMenuimplementsAction{
readonlytype=CLOSE_MENU;
constructor(publicbale:MenuBit){}
exportconstSHADE_MENU="[Shadeaction]ShadeMenu";
exportclassShadeMenuimplementsAction{
readonlytype=SHADE_MENU;
constructor(publicbale:MenuBit){}
exportconstVISAGE_MENU="[Visageaction]VisageMenu";
exportclassVisageMenuimplementsAction{
readonlytype=VISAGE_MENU;
constructor(publicbale:MenuBit){}
exportconstCONTAINER_MENU="[Visageaction]ContainerMenu";
exportclassContainerMenuimplementsAction{
readonlytype=CONTAINER_MENU;
constructor(publicbale:MenuBit){}
exportconstTEXT_MENU="[Visageaction]TextMenu";
exportclassTextMenuimplementsAction{
readonlytype=TEXT_MENU;
constructor(publicbale:MenuBit){}
exporttypeActions=InitMenu|UpdateMenu|TestMenu|CloseMenu
|ShadeMenu
|VisageMenu
|ContainerMenu
|TextMenu
export{initMenu}from"./buz/00.menu.buzz";
export{updateMenu}from"./buz/00.menu.buzz";
export{testMenu}from"./buz/00.menu.buzz";
export{closeMenu}from"./buz/00.menu.buzz";
export{shadeMenu}from"./buz/00.menu.buzz";
export{visageMenu}from"./buz/visage-menu.buzz";
export{containerMenu}from"./buz/container-menu.buzz";
export{textMenu}from"./buz/text-menu.buzz";
importMenufrom"./fce/menu.interface";
importMenuBitfrom"./fce/menu.interface";
exportclassMenuModelimplementsMenu{
lst:string[]=[]
import*asclonefrom"clone-deep";
import*asActfrom"./menu.action";
import{MenuModel}from"./menu.model";
import*asBuzzfrom"./menu.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:MenuModel=newMenuModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.UPDATE_MENU:
returnBuzz.updateMenu(clone(model),act.bale,state);
caseAct.INIT_MENU:
returnBuzz.initMenu(clone(model),act.bale,state);
caseAct.TEST_MENU:
returnBuzz.testMenu(clone(model),act.bale,state);
caseAct.CLOSE_MENU:
returnBuzz.closeMenu(clone(model),act.bale,state);
caseAct.SHADE_MENU:
returnBuzz.shadeMenu(clone(model),act.bale,state);
caseAct.VISAGE_MENU:
returnBuzz.visageMenu(clone(model),act.bale,state);
caseAct.CONTAINER_MENU:
returnBuzz.containerMenu(clone(model),act.bale,state);
caseAct.TEXT_MENU:
returnBuzz.textMenu(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassMenuUnit{
constructor(state:State){
import{Action}from"../99.core/interface/action.interface";
importBusBitfrom"./fce/bus.bit";
exportconstINIT_BUS="[Busaction]InitBus";
exportclassInitBusimplementsAction{
readonlytype=INIT_BUS;
constructor(publicbale:BusBit){}
exportconstOPEN_BUS="[Busaction]OpenBus";
exportclassOpenBusimplementsAction{
readonlytype=OPEN_BUS;
constructor(publicbale:BusBit){}
exportconstCONNECT_BUS="[Busaction]ConnectBus";
exportclassConnectBusimplementsAction{
readonlytype=CONNECT_BUS;
constructor(publicbale:BusBit){}
exportconstMESSAGE_BUS="[Busaction]MessageBus";
exportclassMessageBusimplementsAction{
readonlytype=MESSAGE_BUS;
constructor(publicbale:BusBit){}
exportconstUPDATE_BUS="[Busaction]UpdateBus";
exportclassUpdateBusimplementsAction{
readonlytype=UPDATE_BUS;
constructor(publicbale:BusBit){}
exportconstCREATE_BUS="[Busaction]CreateBus";
exportclassCreateBusimplementsAction{
readonlytype=CREATE_BUS;
constructor(publicbale:BusBit){}
exporttypeActions=|InitBus|OpenBus|UpdateBus|ConnectBus|MessageBus|CreateBus;
export{initBus}from"./buz/bus.buzz";
export{openBus}from"./buz/bus.buzz";
export{updateBus}from"./buz/bus.buzz";
export{connectBus}from"./buz/bus.buzz";
export{messageBus}from"./buz/bus.buzz";
export{createBus}from"./buz/bus.buzz";
importBusfrom"./fce/bus.interface";
importBusBitfrom"./fce/bus.interface";
exportclassBusModelimplementsBus{
MQTT:any;
actList:any;
client:any;
bus:Function;
responseSuffix:string='-response'
promises:any={}
import*asclonefrom"clone-deep";
import*asActfrom"./bus.action";
import{BusModel}from"./bus.model";
import*asBuzzfrom"./bus.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:BusModel=newBusModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.UPDATE_BUS:
returnBuzz.updateBus(clone(model),act.bale,state);
caseAct.OPEN_BUS:
returnBuzz.openBus(clone(model),act.bale,state);
caseAct.CONNECT_BUS:
returnBuzz.connectBus(clone(model),act.bale,state);
caseAct.CREATE_BUS:
returnBuzz.createBus(clone(model),act.bale,state);
caseAct.MESSAGE_BUS:
returnBuzz.connectBus(clone(model),act.bale,state);
caseAct.INIT_BUS:
returnBuzz.initBus(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassBusUnit{
constructor(state:State){
import*asActMnufrom"../../98.menu.unit/menu.action";
import*asActBusfrom"../../99.bus.unit/bus.action";
import*asActColfrom"../../97.collect.unit/collect.action";
varlst,idx,bit,src,dat,dex;
exportconstinitBus=(cpy:BusModel,bal:BusBit,ste:State)=>{
cpy.actList=[]
if(bal==null)bal={idx:null}
if(bal.lst==null)bal.lst=[]
if((bal.src!=null)&&(bal.src.constructor==Array))lst=bal.src;
bal.lst.forEach((a)=>{
for(varkeyina){
cpy.actList.push(a[key])
ste.bus=(idx,dat,bit)=>updateBus(cpy,{idx,dat,bit},ste)
if(bal.dat!=null){
cpy.MQTT=bal.dat;
else{
if(lst==null){
if(bal.src!=null)cpy.host=bal.src
cpy.client=cpy.MQTT.connect(cpy.host);
cpy.client.on('message',(tpc,msg)=>{messageBus(cpy,{idx:tpc,src:msg},ste)})
cpy.client.on('connect',()=>{
openBus(cpy,{idx:'init-bus',lst:cpy.actList},ste)
if(bal.slv!=null)bal.slv({intBit:{idx:"init-bus"}})
}else{
varcomplete=(lst)=>{
lst.shift()
if(lst.length!=0)return
if(bal.slv!=null)bal.slv({intBit:{idx:"init-bus"}})
lst.forEach(async(a)=>{
bit=awaitste.hunt(ActCol.WRITE_COLLECT,{idx:a.idx,src:a.src,bit:ActBus.CREATE_BUS})
varclient=bit.clcBit.dat;
client.on('message',(tpc,msg)=>{messageBus(cpy,{idx:tpc,src:msg,bit:a.idx},ste)})
client.on('connect',()=>{
openBus(cpy,{idx:'init-bus',lst:cpy.actList,bit:a.idx},ste)
complete(lst)
exportconstcreateBus=(cpy:BusModel,bal:BusBit,ste:State)=>{
varclient=cpy.MQTT.connect(bal.src);
if(bal.slv!=null)bal.slv({busBit:{idx:"create-bus",dat:client}});
exportconstopenBus=async(cpy:BusModel,bal:BusBit,ste:State)=>{
varout=[]
bal.lst.forEach((a)=>{
if(a==null)return
if(a.includes==null)return
if(a.includes('[')&&a.includes(']')==false)return
out.push(a)
varclient=cpy.client;
if(bal.bit!=null){
bit=awaitste.hunt(ActCol.READ_COLLECT,{idx:bal.bit,bit:ActBus.CREATE_BUS})
client=bit.clcBit.dat
out.forEach((a)=>{
client.subscribe(a,(err)=>{
if(!err){
exportconstconnectBus=(cpy:BusModel,bal:BusBit,ste:State)=>{
varlst=[]
if(bal.val==1)patch(ste,ActMnu.INIT_MENU,{lst})
exportconstmessageBus=async(cpy:BusModel,bal:BusBit,ste:State)=>{
if(bal.src!=null)dat=bal.src.toString()
idx=bal.idx
dat=JSON.parse(dat)
varclient=cpy.client;
if(bal.bit!=null){
bit=awaitste.hunt(ActCol.READ_COLLECT,{idx:bal.bit,bit:ActBus.CREATE_BUS})
client=bit.clcBit.dat
if(idx.includes(cpy.responseSuffix)==true){
varresponseIDX=bal.idx;
varobj=cpy.promises[responseIDX];
if(obj.slv!=null)obj.slv(dat);
client.unsubscribe(responseIDX,(err)=>{
if(!err){
}else{
varbit=awaitste.hunt(idx,dat)
varcloneBit=clone(bit)
for(varkeyincloneBit){
varitm=cloneBit[key]
if(itm.dat!=null){
if(itm.dat.bit!=null)itm.dat.bit=null
cloneBit
client.publish(bal.idx+cpy.responseSuffix,JSON.stringify(cloneBit))
exportconstupdateBus=async(cpy:BusModel,bal:BusBit,ste:State)=>{
varclient=cpy.client;
if(bal.bit!=null){
bit=awaitste.hunt(ActCol.READ_COLLECT,{idx:bal.bit,bit:ActBus.CREATE_BUS})
client=bit.clcBit.dat
if((client==null)&&(bal.bit==null)){
bit=awaitste.hunt(ActCol.FETCH_COLLECT,{bit:ActBus.CREATE_BUS})
client=bit.clcBit.dat
varresponseIDX=bal.idx+cpy.responseSuffix;
varslv;
constpromo=newPromise((rslv,rjct)=>(slv=rslv));
varobj={slv:(val0)=>slv(val0)};
cpy.promises[responseIDX]=obj
client.subscribe(responseIDX,(err)=>{
if(!err){
client.publish(bal.idx,JSON.stringify(bal.dat))
returnpromo;
varpatch=(ste,type,bale)=>ste.dispatch({type,bale});
import{BusModel}from"../bus.model";
importBusBitfrom"../fce/bus.bit";
importStatefrom"../../99.core/state";
importSfrom"string";
import*asclonefrom"clone-deep";
exportdefaultinterfaceBusBit{
idx:string;
val?:number;
lst?:any;
src?:any;
bit?:string;
slv?:Function;
dat?:any;
importBusBitfrom"./bus.bit";
exportdefaultinterfaceBus{
"usestrict";
exports.__esModule=true;
exportinterfaceAction<T=any>{
type:string;
bale?:T;
"usestrict";
exports.__esModule=true;
exportdefaultinterfaceModel{}
import{BehaviorSubject}from"rx-lite";
import{Subject}from"rx-lite";
import{Action}from"./interface/action.interface";
importUnitModelfrom"../BEE";
import*asEffectfrom"../BEE";
exportdefaultclassStateextendsBehaviorSubject<any>{
publichunt:any;
publicvalue:any;
publicpivot:any;
publicbus:any;
privatedispatcher:Subject=newSubject();
constructor(init:UnitModel=newUnitModel()){
super(init);
this.dispatcher
.scan((state,action)=>this.reducedApp(state,action),init)
.subscribe((state)=>{
super.onNext(state);
reducedApp(nextState:any,key:any){
for(varkinEffect.reducer)Effect.reducer[k](nextState[k],key,this);
returnnextState;
dispatch(value:Action){
varresult=this.dispatcher.onNext(value);
returnresult;
pat(value:Action){
this.dispatch(value);
next(value:any){
this.dispatcher.onNext(value);
exportconstINIT_CONSOLE="[Consoleaction]InitConsole";
exportconstUPDATE_CONSOLE="[Consoleaction]UpdateConsole";
exportconstREAD_CONSOLE="[Readaction]ReadConsole";
exportconstWRITE_CONSOLE="[Writeaction]WriteConsole";
exportconstREMOVE_CONSOLE="[Removeaction]RemoveConsole";
exportconstDELETE_CONSOLE="[Deleteaction]DeleteConsole";
exportconstCREATE_CONSOLE="[Createaction]CreateConsole";
exportconstINIT_DISK="[Diskaction]InitDisk";
exportconstUPDATE_DISK="[Diskaction]UpdateDisk";
exportconstREAD_DISK="[Diskaction]ReadDisk";
exportconstWRITE_DISK="[Diskaction]WriteDisk";
exportconstLIST_DISK="[Listaction]ListDisk";
exportconstLOAD_LIST_DISK="[Load_listaction]Load_listDisk";
exportconstCOPY_DISK="[Copyaction]CopyDisk";
exportconstINIT_PIVOT="[Pivotaction]InitPivot";
exportconstUPDATE_PIVOT="[Pivotaction]UpdatePivot";
exportconstOPEN_PIVOT="[Openaction]OpenPivot";
exportconstRUN_PIVOT="[Runaction]RunPivot";
exportconstEDIT_PIVOT="[Editaction]EditPivot";
exportconstPATCH_PIVOT="[Patchaction]PatchPivot";
exportconstCOUNT_PIVOT="[Patchaction]CountPivot";
exportconstLIST_PIVOT="[Patchaction]ListPivot";
exportconstCREATE_PIVOT="[Patchaction]CreatePivot";
exportconstCONTAINS_PIVOT="[Patchaction]ContainsPivot";
exportconstBUNDLE_PIVOT="[Patchaction]BundlePivot";
exportconstINIT_RENPY="[Renpyaction]InitRenpy";
exportconstUPDATE_RENPY="[Renpyaction]UpdateRenpy";
exportconstOPEN_RENPY="[Renpyaction]OpenRenpy";
exportconstINIT_SHINY="[Shinyaction]InitShiny";
exportconstUPDATE_SHINY="[Shinyaction]UpdateShiny";
exportconstOPEN_SHINY="[Shinyaction]OpenShiny";
exportconstINIT_SPACE="[Spaceaction]InitSpace";
exportconstUPDATE_SPACE="[Spaceaction]UpdateSpace";
exportconstREADY_SPACE="[Readyaction]ReadySpace";
exportconstINIT_TERMINAL="[Terminalaction]InitTerminal";
exportconstOPEN_TERMINAL="[Terminalaction]OpenTerminal";
exportconstFOCUS_TERMINAL="[Terminalaction]FocusTerminal";
exportconstWRITE_TERMINAL="[Terminalaction]WriteTerminal";
exportconstUPDATE_TERMINAL="[Terminalaction]UpdateTerminal";
exportconstCLEAR_TERMINAL="[Terminalaction]ClearTerminal";
exportconstINPUT_TERMINAL="[Terminalaction]InputTerminal";
exportconstTABLE_TERMINAL="[Terminalaction]TableTerminal";
exportconstCLOSE_TERMINAL="[Terminalaction]CloseTerminal";
exportconstROOT_TERMINAL="[Terminalaction]RootTerminal";
exportconstCONTENT_TERMINAL="[Terminalaction]ContentTerminal";
exportconstADD_PORT="[Terminalaction]AddPort";
exportconstINIT_VURT="[Vurtaction]InitVurt";
exportconstDELAY_VURT="[Vurtaction]DelayVurt";
exportconstTEST_CLOUD_VURT="[Vurtaction]TestCloudVurt";
exportconstFETCH_VURT="[Vurtaction]FetchVurt";
exportconstUPDATE_VURT="[Vurtaction]UpdateVurt";
exportconstREPLACE_VURT="[Vurtaction]ReplaceVurt";
exportconstUNIT_VURT="[Vurtaction]UnitVurt";
exportconstCOUNT_VURT="[Vurtaction]CountVurt";
exportconstLIST_PIVOT_VURT="[Vurtaction]ListPivotVurt";
exportconstLIST_UNIT_VURT="[Vurtaction]ListUnitVurt";
exportconstCONTAINS_VURT="[Containsaction]ContainsVurt";
exportconstBUNDLE_VURT="[Bundleaction]BundleVurt";
exportconstVALUE_VURT="[Valueaction]ValueVurt";
importModelfrom"./99.core/interface/model.interface";
importShadeUnitfrom"./00.shade.unit/shade.unit";
importSurfaceUnitfrom"./02.surface.unit/surface.unit";
importContainerUnitfrom"./03.container.unit/container.unit";
importGraphicUnitfrom"./04.graphic.unit/graphic.unit";
importTextUnitfrom"./05.text.unit/text.unit";
importSpriteUnitfrom"./06.sprite.unit/sprite.unit";
importHexagonUnitfrom"./07.hexagon.unit/hexagon.unit";
importFocigonUnitfrom"./08.focigon.unit/focigon.unit";
importLoopUnitfrom"./09.loop.unit/loop.unit";
importToonUnitfrom"./10.toon.unit/toon.unit";
importVideoUnitfrom"./11.video.unit/video.unit";
importFrameUnitfrom"./12.frame.unit/frame.unit";
importCameraUnitfrom"./13.camera.unit/camera.unit";
importVisageUnitfrom"./21.visage.unit/visage.unit";
importChromeUnitfrom"./24.chrome.unit/chrome.unit";
importCollectUnitfrom"./97.collect.unit/collect.unit";
importMenuUnitfrom"./98.menu.unit/menu.unit";
importBusUnitfrom"./99.bus.unit/bus.unit";
importShadefrom"./00.shade.unit/fce/shade.interface";
import{ShadeModel}from"./00.shade.unit/shade.model";
importSurfacefrom"./02.surface.unit/fce/surface.interface";
import{SurfaceModel}from"./02.surface.unit/surface.model";
importContainerfrom"./03.container.unit/fce/container.interface";
import{ContainerModel}from"./03.container.unit/container.model";
importGraphicfrom"./04.graphic.unit/fce/graphic.interface";
import{GraphicModel}from"./04.graphic.unit/graphic.model";
importTextfrom"./05.text.unit/fce/text.interface";
import{TextModel}from"./05.text.unit/text.model";
importSpritefrom"./06.sprite.unit/fce/sprite.interface";
import{SpriteModel}from"./06.sprite.unit/sprite.model";
importHexagonfrom"./07.hexagon.unit/fce/hexagon.interface";
import{HexagonModel}from"./07.hexagon.unit/hexagon.model";
importFocigonfrom"./08.focigon.unit/fce/focigon.interface";
import{FocigonModel}from"./08.focigon.unit/focigon.model";
importLoopfrom"./09.loop.unit/fce/loop.interface";
import{LoopModel}from"./09.loop.unit/loop.model";
importToonfrom"./10.toon.unit/fce/toon.interface";
import{ToonModel}from"./10.toon.unit/toon.model";
importVideofrom"./11.video.unit/fce/video.interface";
import{VideoModel}from"./11.video.unit/video.model";
importFramefrom"./12.frame.unit/fce/frame.interface";
import{FrameModel}from"./12.frame.unit/frame.model";
importCamerafrom"./13.camera.unit/fce/camera.interface";
import{CameraModel}from"./13.camera.unit/camera.model";
importVisagefrom"./21.visage.unit/fce/visage.interface";
import{VisageModel}from"./21.visage.unit/visage.model";
importChromefrom"./24.chrome.unit/fce/chrome.interface";
import{ChromeModel}from"./24.chrome.unit/chrome.model";
importCollectfrom"./97.collect.unit/fce/collect.interface";
import{CollectModel}from"./97.collect.unit/collect.model";
importMenufrom"./98.menu.unit/fce/menu.interface";
import{MenuModel}from"./98.menu.unit/menu.model";
importBusfrom"./99.bus.unit/fce/bus.interface";
import{BusModel}from"./99.bus.unit/bus.model";
exportconstlist:Array<any>=[ShadeUnit,SurfaceUnit,ContainerUnit,GraphicUnit,TextUnit,SpriteUnit,HexagonUnit,FocigonUnit,LoopUnit,ToonUnit,VideoUnit,FrameUnit,CameraUnit,VisageUnit,ChromeUnit,CollectUnit,MenuUnit,BusUnit];
import*asreduceFromShadefrom"./00.shade.unit/shade.reduce";
import*asreduceFromSurfacefrom"./02.surface.unit/surface.reduce";
import*asreduceFromContainerfrom"./03.container.unit/container.reduce";
import*asreduceFromGraphicfrom"./04.graphic.unit/graphic.reduce";
import*asreduceFromTextfrom"./05.text.unit/text.reduce";
import*asreduceFromSpritefrom"./06.sprite.unit/sprite.reduce";
import*asreduceFromHexagonfrom"./07.hexagon.unit/hexagon.reduce";
import*asreduceFromFocigonfrom"./08.focigon.unit/focigon.reduce";
import*asreduceFromLoopfrom"./09.loop.unit/loop.reduce";
import*asreduceFromToonfrom"./10.toon.unit/toon.reduce";
import*asreduceFromVideofrom"./11.video.unit/video.reduce";
import*asreduceFromFramefrom"./12.frame.unit/frame.reduce";
import*asreduceFromCamerafrom"./13.camera.unit/camera.reduce";
import*asreduceFromVisagefrom"./21.visage.unit/visage.reduce";
import*asreduceFromChromefrom"./24.chrome.unit/chrome.reduce";
import*asreduceFromCollectfrom"./97.collect.unit/collect.reduce";
import*asreduceFromMenufrom"./98.menu.unit/menu.reduce";
import*asreduceFromBusfrom"./99.bus.unit/bus.reduce";
exportconstreducer:any={
shade:reduceFromShade.reducer,
surface:reduceFromSurface.reducer,
container:reduceFromContainer.reducer,
graphic:reduceFromGraphic.reducer,
text:reduceFromText.reducer,
sprite:reduceFromSprite.reducer,
hexagon:reduceFromHexagon.reducer,
focigon:reduceFromFocigon.reducer,
loop:reduceFromLoop.reducer,
toon:reduceFromToon.reducer,
video:reduceFromVideo.reducer,
frame:reduceFromFrame.reducer,
camera:reduceFromCamera.reducer,
visage:reduceFromVisage.reducer,
chrome:reduceFromChrome.reducer,
collect:reduceFromCollect.reducer,
menu:reduceFromMenu.reducer,
bus:reduceFromBus.reducer,
exportdefaultclassUnitDataimplementsModel{
shade:Shade=newShadeModel();
surface:Surface=newSurfaceModel();
container:Container=newContainerModel();
graphic:Graphic=newGraphicModel();
text:Text=newTextModel();
sprite:Sprite=newSpriteModel();
hexagon:Hexagon=newHexagonModel();
focigon:Focigon=newFocigonModel();
loop:Loop=newLoopModel();
toon:Toon=newToonModel();
video:Video=newVideoModel();
frame:Frame=newFrameModel();
camera:Camera=newCameraModel();
visage:Visage=newVisageModel();
chrome:Chrome=newChromeModel();
collect:Collect=newCollectModel();
menu:Menu=newMenuModel();
bus:Bus=newBusModel();
varsim={
hunt:null,
state:null
sim.hunt=(typ,obj)=>{returnhost(obj,typ)}
varhost=(obj,typ)=>{
init();
varslv;
constpromo=newPromise((rslv,rjct)=>(slv=rslv));
if(obj==null)obj={};
if(obj.slv==null)obj.slv=(val0)=>slv(val0);
sim.state.dispatch({type:typ,bale:obj});
returnpromo;
varinit=()=>{
if(sim.state!=null)return;
sim.state=newState();
sim.state.pivot=sim;
sim.state.hunt=sim.hunt
for(varkinImport.list)newImport.list[k](sim.state);
import*asImportfrom"./BEE";
importStatefrom"./99.core/state";
module.exports=sim;
"usestrict";
exports.__esModule=true;
exports.CYAN=exports.MAGENTA=exports.YELLOW=exports.GREEN=exports.RED=void0;
exports.RED="\x1b[31m%s\x1b[0m";
exports.GREEN="\x1b[32m%s\x1b[0m";
exports.YELLOW="\x1b[33m%s\x1b[0m";
exports.MAGENTA="\x1b[34m%s\x1b[0m";
exports.CYAN="\x1b[36m%s\x1b[0m";
exportconstRED:string="\x1b[31m%s\x1b[0m";
exportconstGREEN:string="\x1b[32m%s\x1b[0m";
exportconstYELLOW:string="\x1b[33m%s\x1b[0m";
exportconstMAGENTA:string="\x1b[34m%s\x1b[0m";
exportconstCYAN:string="\x1b[36m%s\x1b[0m";
"usestrict";
exports.__esModule=true;
exports.WISE_NORTH_EAST=exports.WISE_NORTH=exports.WISE_NORTH_WEST=exports.WISE_WEST=exports.WISE_SOUTH_WEST=exports.WISE_SOUTH=exports.WISE_SOUTH_EAST=exports.WISE_EAST=exports.NORTH_EAST=exports.NORTH=exports.NORTH_WEST=exports.WEST=exports.SOUTH_WEST=exports.SOUTH=exports.SOUTH_EAST=exports.EAST=void0;
exports.EAST="E";
exports.SOUTH_EAST="SE";
exports.SOUTH="S";
exports.SOUTH_WEST="SW";
exports.WEST="W";
exports.NORTH_WEST="NW";
exports.NORTH="N";
exports.NORTH_EAST="NE";
exports.WISE_EAST="WiseE";
exports.WISE_SOUTH_EAST="WiseSE";
exports.WISE_SOUTH="WiseS";
exports.WISE_SOUTH_WEST="WiseSW";
exports.WISE_WEST="WiseW";
exports.WISE_NORTH_WEST="WiseNW";
exports.WISE_NORTH="WiseN";
exports.WISE_NORTH_EAST="WiseNE";
exportconstEAST="E";
exportconstSOUTH_EAST="SE";
exportconstSOUTH="S";
exportconstSOUTH_WEST="SW";
exportconstWEST="W";
exportconstNORTH_WEST="NW";
exportconstNORTH="N";
exportconstNORTH_EAST="NE";
exportconstWISE_EAST="WiseE";
exportconstWISE_SOUTH_EAST="WiseSE";
exportconstWISE_SOUTH="WiseS";
exportconstWISE_SOUTH_WEST="WiseSW";
exportconstWISE_WEST="WiseW";
exportconstWISE_NORTH_WEST="WiseNW";
exportconstWISE_NORTH="WiseN";
exportconstWISE_NORTH_EAST="WiseNE";
"usestrict";
exports.__esModule=true;
exports.CIRCLE=exports.ROUNDED_RECTANGLE=exports.RECTANGLE=void0;
exports.RECTANGLE="rectangle";
exports.ROUNDED_RECTANGLE="rounded-rectangle";
exports.CIRCLE="circle";
exportconstRECTANGLE:string="rectangle";
exportconstROUNDED_RECTANGLE:string="rounded-rectangle";
exportconstCIRCLE:string="circle";
"usestrict";
exports.__esModule=true;
exports.HEXMAP=exports.FOCUS=void0;
exports.FOCUS="focus";
exports.HEXMAP="hexmap";
exportconstFOCUS:string="focus";
exportconstHEXMAP:string="hexmap";
"usestrict";
exports.__esModule=true;
exports.PASTURE=exports.FANG_SWAMP=exports.GEORGIA=exports.GALLBLADDER=void0;
exports.GALLBLADDER="00000.gallbladder";
exports.GEORGIA="00001.georgia";
exports.FANG_SWAMP="00002.fang-swamp";
exports.PASTURE="00003.pasture";
exportconstGALLBLADDER:string="00000.gallbladder";
exportconstGEORGIA:string="00001.georgia";
exportconstFANG_SWAMP:string="00002.fang-swamp";
exportconstPASTURE:string="00003.pasture";
"usestrict";
exports.__esModule=true;
exports.MAGENTA=exports.YELLOW=exports.BLUE=exports.GREEN=exports.RED=exports.CYAN=exports.CLEAN=exports.MENU_SINGLE=exports.TIMELINE=exports.SPACE=void0;
exports.SPACE="space";
exports.TIMELINE="timeline";
exports.MENU_SINGLE="menu_single";
exports.CLEAN="clean";
exports.CYAN="cyan";
exports.RED="red";
exports.GREEN="green";
exports.BLUE="blue";
exports.YELLOW="yellow";
exports.MAGENTA="magenta";
exportconstSPACE:string="space";
exportconstTIMELINE:string="timeline";
exportconstMENU_SINGLE:string="menu_single";
exportconstCLEAN:string="clean";
exportconstCYAN:string="cyan";
exportconstRED:string="red";
exportconstGREEN:string="green";
exportconstBLUE:string="blue";
exportconstYELLOW:string="yellow";
exportconstMAGENTA:string="magenta";
"usestrict";
exports.__esModule=true;
exports.LOOP=exports.VIDEO=exports.HEXAGON=exports.SPRITE=exports.TEXT=exports.GRAPHIC=exports.CONTAINER=exports.SURFACE=exports.VISAGE=void0;
exports.VISAGE="visage";
exports.SURFACE="surface";
exports.CONTAINER="container";
exports.GRAPHIC="graphic";
exports.TEXT="text";
exports.SPRITE="sprite";
exports.HEXAGON="hexagon";
exports.VIDEO="video";
exports.LOOP="loop";
exportconstVISAGE:string="visage";
exportconstSURFACE:string="surface";
exportconstCONTAINER:string="container";
exportconstGRAPHIC:string="graphic";
exportconstTEXT:string="text";
exportconstSPRITE:string="sprite";
exportconstHEXAGON:string="hexagon";
exportconstVIDEO:string="video";
exportconstLOOP:string="loop";
"usestrict";
exports.__esModule=true;
exports.MOUNT_WIDTH=exports.MOUNT_HEIGHT=exports.MOUNT_PART=exports.MOUNT_FULL=exports.SCREEN=void0;
exports.SCREEN="screen-visage";
exports.MOUNT_FULL="mount-visage-full";
exports.MOUNT_PART="mount-visage-part";
exports.MOUNT_HEIGHT="mount-visage-height";
exports.MOUNT_WIDTH="mount-visage-width";
exportconstSCREEN:string="screen-visage";
exportconstMOUNT_FULL:string="mount-visage-full";
exportconstMOUNT_PART:string="mount-visage-part";
exportconstMOUNT_HEIGHT:string="mount-visage-height";
exportconstMOUNT_WIDTH:string="mount-visage-width";
exportconstinitSolid=(cpy:SolidModel,bal:SolidBit,ste:State)=>{
if(bal.slv!=null)bal.slv({intBit:{idx:"init-solid"}});
exportconstupdateSolid=(cpy:SolidModel,bal:SolidBit,ste:State)=>{
exportconstshadeSolid=(cpy:SolidModel,bal:SolidBit,ste:State)=>{
debugger
import{SolidModel}from"../solid.model";
importSolidBitfrom"../fce/solid.bit";
importStatefrom"../../99.core/state";
exportdefaultinterfaceSolidBit{
idx:string;
src?:string;
val?:number;
dat?:any;
slv?:Function;
importSolidBitfrom"./solid.bit";
exportdefaultinterfaceSolid{
import{Action}from"../99.core/interface/action.interface";
importSolidBitfrom"./fce/solid.bit";
exportconstINIT_SOLID="[Solidaction]InitSolid";
exportclassInitSolidimplementsAction{
readonlytype=INIT_SOLID;
constructor(publicbale:SolidBit){}
exportconstUPDATE_SOLID="[Solidaction]UpdateSolid";
exportclassUpdateSolidimplementsAction{
readonlytype=UPDATE_SOLID;
constructor(publicbale:SolidBit){}
exportconstSHADE_SOLID="[Shadeaction]ShadeSolid";
exportclassShadeSolidimplementsAction{
readonlytype=SHADE_SOLID;
constructor(publicbale:SolidBit){}
exporttypeActions=|InitSolid|UpdateSolid
|ShadeSolid
export{initSolid}from"./buz/solid.buzz";
export{updateSolid}from"./buz/solid.buzz";
export{shadeSolid}from"./buz/solid.buzz";
importSolidfrom"./fce/solid.interface";
importSolidBitfrom"./fce/solid.interface";
exportclassSolidModelimplementsSolid{
shade:any;
import*asActfrom"./solid.action";
import{SolidModel}from"./solid.model";
import*asBuzzfrom"./solid.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:SolidModel=newSolidModel(),act:Act.Actions,state?:State){
varclone=require('clone-deep');
switch(act.type){
caseAct.UPDATE_SOLID:
returnBuzz.updateSolid(clone(model),act.bale,state);
caseAct.INIT_SOLID:
returnBuzz.initSolid(clone(model),act.bale,state);
caseAct.SHADE_SOLID:
returnBuzz.shadeSolid(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassSolidUnit{
constructor(state:State){
window.SOLID=require("../dist/111.solid/hunt");
window.MQTT=require("async-mqtt");
window.SOLID.ActSSld=require("../dist/111.solid/00.solid.unit/solid.action");
import{Action}from"../99.core/interface/action.interface";
importBabylonBitfrom"./fce/babylon.bit";
exportconstINIT_BABYLON="[Babylonaction]InitBabylon";
exportclassInitBabylonimplementsAction{
readonlytype=INIT_BABYLON;
constructor(publicbale:BabylonBit){}
exportconstUPDATE_BABYLON="[Babylonaction]UpdateBabylon";
exportclassUpdateBabylonimplementsAction{
readonlytype=UPDATE_BABYLON;
constructor(publicbale:BabylonBit){}
exportconstOPEN_BABYLON="[Babylonaction]OpenBabylon";
exportclassOpenBabylonimplementsAction{
readonlytype=OPEN_BABYLON;
constructor(publicbale:BabylonBit){}
exportconstRECORD_BABYLON="[Babylonaction]RecordBabylon";
exportclassRecordBabylonimplementsAction{
readonlytype=RECORD_BABYLON;
constructor(publicbale:BabylonBit){}
exportconstACTION_BABYLON="[Babylonaction]ActionBabylon";
exportclassActionBabylonimplementsAction{
readonlytype=ACTION_BABYLON;
constructor(publicbale:BabylonBit){}
exportconstCUT_BABYLON="[Babylonaction]CutBabylon";
exportclassCutBabylonimplementsAction{
readonlytype=CUT_BABYLON;
constructor(publicbale:BabylonBit){}
exportconstCAMERA_BABYLON="[Babylonaction]CutBabylon";
exportclassCameraBabylonimplementsAction{
readonlytype=CAMERA_BABYLON;
constructor(publicbale:BabylonBit){}
exporttypeActions=|InitBabylon|UpdateBabylon|OpenBabylon|RecordBabylon
|ActionBabylon
|CutBabylon
|CameraBabylon
export{initBabylon}from"./buz/babylon.buzz";
export{updateBabylon}from"./buz/babylon.buzz";
export{openBabylon}from"./buz/babylon.buzz";
export{recordBabylon}from"./buz/babylon.buzz";
export{actionBabylon}from"./buz/babylon.buzz";
export{cutBabylon}from"./buz/babylon.buzz";
export{cameraBabylon}from"./buz/babylon.buzz";
importBabylonfrom"./fce/babylon.interface";
importBabylonBitfrom"./fce/babylon.interface";
exportclassBabylonModelimplementsBabylon{
recorder:any;
engine:any;
scene:any;
mmdRuntime:any;
motion:any;
import*asActfrom"./babylon.action";
import{BabylonModel}from"./babylon.model";
import*asBuzzfrom"./babylon.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:BabylonModel=newBabylonModel(),act:Act.Actions,state?:State){
varclone=require('clone-deep');
switch(act.type){
caseAct.UPDATE_BABYLON:
returnBuzz.updateBabylon(clone(model),act.bale,state);
caseAct.INIT_BABYLON:
returnBuzz.initBabylon(clone(model),act.bale,state);
caseAct.OPEN_BABYLON:
returnBuzz.openBabylon(clone(model),act.bale,state);
caseAct.RECORD_BABYLON:
returnBuzz.recordBabylon(clone(model),act.bale,state);
caseAct.ACTION_BABYLON:
returnBuzz.actionBabylon(clone(model),act.bale,state);
caseAct.CUT_BABYLON:
returnBuzz.cutBabylon(structuredClone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassBabylonUnit{
constructor(state:State){
import{Container,AnimatedSprite,Texture,Spritesheet,Assets,Sprite}from'pixi.js';
import*asBABYLONfrom'babylonjs'
importHavokPhysicsfrom"@babylonjs/havok";
import"babylon-mmd/esm/Loader/pmxLoader";
import*asPIXIfrom'pixi.js'
import*asActMkufrom"../../10.miku.unit/miku.action"
import*asActScrfrom"../../08.screen.unit/screen.action"
declareconstBABYLONMMD:any;
import*asActBbyfrom"../../01.babylon.unit/babylon.action";
varbit
exportconstinitBabylon=async(cpy:BabylonModel,bal:BabylonBit,ste:State)=>{
debugger
bal.slv({intBit:{idx:"init-babylon"}});
varopened=false
varrecorder;
exportconstopenBabylon=async(cpy:BabylonModel,bal:BabylonBit,ste:State)=>{
if(opened==true){
return
opened=true;
asyncfunctiongetInitializedHavok(){
returnawaitHavokPhysics();
constcanvas=document.getElementById(bal.src);
constengine=newBABYLON.Engine(canvas,true);
constscene=newBABYLON.Scene(engine);
cpy.scene=scene;
varlight=newBABYLON.HemisphericLight('light1',newBABYLON.Vector3(0,1,0),scene);
engine.runRenderLoop(function(){
scene.render();
cpy.engine=engine
constcamera=newBABYLON.UniversalCamera("UniversalCamera",newBABYLON.Vector3(0,0,-10),scene);
constv0=newBABYLON.Vector3(0,0,0)
camera.setTarget(v0);
camera.attachControl(canvas,true);
recorder=newBABYLON.VideoRecorder(cpy.engine);
globalThis.HK=awaitgetInitializedHavok()
awaitnewPromise((resolve)=>{
constbabylonMmdScript=document.createElement("script");
babylonMmdScript.src="./babylon.mmd.min.js";
document.head.appendChild(babylonMmdScript);
babylonMmdScript.onload=resolve;
BABYLONMMD.SdefInjector.OverrideEngineCreateEffect(engine);
consthavokPlugin=newBABYLON.HavokPlugin();
scene.enablePhysics(newBABYLON.Vector3(0,-98,0),havokPlugin);
bit=awaitste.hunt(ActScr.WRITE_SCREEN,{idx:'src00'})
debugger
constmmdRuntime=newBABYLONMMD.MmdRuntime(scene,newBABYLONMMD.MmdPhysics(scene));
mmdRuntime.register(scene);
cpy.mmdRuntime=mmdRuntime
constmmdCamera=newBABYLONMMD.MmdCamera("MmdCamera",newBABYLON.Vector3(0,10,0),scene);
mmdCamera.maxZ=5000;
constvmdLoader=newBABYLONMMD.VmdLoader(scene);
constmotion=awaitvmdLoader.loadAsync("motion","./Motion.vmd")
cpy.motion=motion;
mmdRuntime.setCamera(mmdCamera);
bit=awaitste.hunt(ActMku.WRITE_MIKU,{idx:'mku00a',src:'greasi/00.pmx',dat:{position:{z:-7}}})
bit=awaitste.hunt(ActMku.WRITE_MIKU,{idx:'mku00a',dat:{position:{z:40}}})
varvalue=100;
bal.slv({intBit:{idx:"open-babylon"}});
exportconstupdateBabylon=(cpy:BabylonModel,bal:BabylonBit,ste:State)=>{
exportconstrecordBabylon=(cpy:BabylonModel,bal:BabylonBit,ste:State)=>{
recorder.startRecording("000.webm",22);
bal.slv({bbyBit:{idx:"record-babylon"}});
exportconstactionBabylon=async(cpy:BabylonModel,bal:BabylonBit,ste:State)=>{
recorder.startRecording("000.webm",60).then(async(videoBlob)=>{
constformData=newFormData();
try{
constresponse=awaitfetch('/api/upload-video',{
method:'POST',
body:formData,
if(response.ok){
constdata=awaitresponse.json();
}else{
console.error('Uploadfailed:',response.status,response.statusText);
}catch(error){
console.error('Errorduringupload:',error);
bal.slv({bbyBit:{idx:"action-babylon"}});
exportconstcutBabylon=(cpy:BabylonModel,bal:BabylonBit,ste:State)=>{
recorder.stopRecording()
bal.slv({bbyBit:{idx:"cut-babylon"}});
exportconstcameraBabylon=(cpy:BabylonModel,bal:BabylonBit,ste:State)=>{
bal.slv({bbyBit:{idx:"camera-babylon"}});
import{BabylonModel}from"../babylon.model";
importBabylonBitfrom"../fce/babylon.bit";
importStatefrom"../../99.core/state";
exportdefaultinterfaceBabylonBit{
idx:string;
src?:string;
val?:number;
dat?:any;
slv?:Function;
importBabylonBitfrom"./babylon.bit";
exportdefaultinterfaceBabylon{
import{CameraModel}from"../camera.model";
importCameraBitfrom"../fce/camera.bit";
importStatefrom"../../99.core/state";
import*asActColfrom"../../97.collect.unit/collect.action";
import*asActCamfrom"../camera.action";
importCamBitfrom"../fce/camera.bit"
import{BabylonModel}from"../../01.babylon.unit/babylon.model";
varbit,dat;
exportconstinitCamera=(cpy:CameraModel,bal:CameraBit,ste:State)=>{
debugger
exportconstupdateCamera=async(cpy:CameraModel,bal:CameraBit,ste:State)=>{
bal.slv({mkuBit:{idx:"update-camera"}});
exportconstreadCamera=async(cpy:CameraModel,bal:CameraBit,ste:State)=>{
varslv=bal.slv;
if(bal.idx==null)bal.idx='can00';
bit=awaitste.hunt(ActCol.READ_COLLECT,{idx:bal.idx,bit:ActCam.CREATE_CAMERA})
bal.slv({mkuBit:{idx:"read-camera",dat:bit.clcBit.dat}});
exportconstwriteCamera=async(cpy:CameraModel,bal:CameraBit,ste:State)=>{
if(typeofwindow!="object")returnbal.slv({canBit:{idx:"error-write-camera",dat:{}}});
bit=awaitste.hunt(ActCol.WRITE_COLLECT,{idx:bal.idx,src:bal.src,dat:bal.dat,bit:ActCam.CREATE_CAMERA})
if(bit.clcBit.val!=0)ste.hunt(ActCam.UPDATE_CAMERA,{idx:bal.idx})
bal.slv({mkuBit:{idx:"write-camera",dat:bit.clcBit.dat}});
exportconstremoveCamera=async(cpy:CameraModel,bal:CameraBit,ste:State)=>{
bit=awaitste.hunt(ActCol.REMOVE_COLLECT,{idx:bal.idx,src:bal.src,dat:bal.dat,bit:ActCam.CREATE_CAMERA})
if(bal.slv!=null)bal.slv({vsgBit:{idx:"remove-container",dat:bit.clcBit}});
bal.slv({mkuBit:{idx:"remove-miku"}});
exportconstdeleteCamera=async(cpy:CameraModel,bal:CameraBit,ste:State)=>{
bal.slv({mkuBit:{idx:"delete-miku"}});
exportconstcreateCamera=async(cpy:CameraModel,bal:CameraBit,ste:State)=>{
if(ste.value.babylon==null){
returnalert("babylonerror")
varmodBab:BabylonModel=ste.value.babylon
if(typeofwindow!="object")returnbal.slv({canBit:{idx:"error-create-container",dat:{}}});
vardat:CamBit={
idx:bal.idx,src:bal.src,
for(varkeyinbal.dat){
dat[key]=bal.dat[key]
bal.slv({mkuBit:{idx:"create-camera",dat}});
import{Action}from"../99.core/interface/action.interface";
importCameraBitfrom"./fce/camera.bit";
exportconstINIT_CAMERA="[Cameraaction]InitCamera";
exportclassInitCameraimplementsAction{
readonlytype=INIT_CAMERA;
constructor(publicbale:CameraBit){}
exportconstUPDATE_CAMERA="[Cameraaction]UpdateCamera";
exportclassUpdateCameraimplementsAction{
readonlytype=UPDATE_CAMERA;
constructor(publicbale:CameraBit){}
exportconstREAD_CAMERA="[Readaction]ReadCamera";
exportclassReadCameraimplementsAction{
readonlytype=READ_CAMERA;
constructor(publicbale:CameraBit){}
exportconstWRITE_CAMERA="[Writeaction]WriteCamera";
exportclassWriteCameraimplementsAction{
readonlytype=WRITE_CAMERA;
constructor(publicbale:CameraBit){}
exportconstREMOVE_CAMERA="[Removeaction]RemoveCamera";
exportclassRemoveCameraimplementsAction{
readonlytype=REMOVE_CAMERA;
constructor(publicbale:CameraBit){}
exportconstDELETE_CAMERA="[Deleteaction]DeleteCamera";
exportclassDeleteCameraimplementsAction{
readonlytype=DELETE_CAMERA;
constructor(publicbale:CameraBit){}
exportconstCREATE_CAMERA="[Createaction]CreateCamera";
exportclassCreateCameraimplementsAction{
readonlytype=CREATE_CAMERA;
constructor(publicbale:CameraBit){}
exporttypeActions=|InitCamera|UpdateCamera
|ReadCamera
|WriteCamera
|RemoveCamera
|DeleteCamera
|CreateCamera
export{initCamera}from"./buz/camera.buzz";
export{updateCamera}from"./buz/camera.buzz";
export{readCamera}from"./buz/camera.buzz";
export{writeCamera}from"./buz/camera.buzz";
export{removeCamera}from"./buz/camera.buzz";
export{deleteCamera}from"./buz/camera.buzz";
export{createCamera}from"./buz/camera.buzz";
importCamerafrom"./fce/camera.interface";
importCameraBitfrom"./fce/camera.interface";
exportclassCameraModelimplementsCamera{
import*asclonefrom"clone-deep";
import*asActfrom"./camera.action";
import{CameraModel}from"./camera.model";
import*asBuzzfrom"./camera.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:CameraModel=newCameraModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.UPDATE_CAMERA:
returnBuzz.updateCamera(clone(model),act.bale,state);
caseAct.INIT_CAMERA:
returnBuzz.initCamera(clone(model),act.bale,state);
caseAct.READ_CAMERA:
returnBuzz.readCamera(clone(model),act.bale,state);
caseAct.WRITE_CAMERA:
returnBuzz.writeCamera(clone(model),act.bale,state);
caseAct.REMOVE_CAMERA:
returnBuzz.removeCamera(clone(model),act.bale,state);
caseAct.DELETE_CAMERA:
returnBuzz.deleteCamera(clone(model),act.bale,state);
caseAct.CREATE_CAMERA:
returnBuzz.createCamera(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassCameraUnit{
constructor(state:State){
exportdefaultinterfaceCameraBit{
idx:string;
exportdefaultinterfaceCameraBit{
idx:string;
src?:string;
val?:number;
dat?:any;
slv?:Function;
importCameraBitfrom"./camera.bit";
exportdefaultinterfaceCamera{
import{LightModel}from"../light.model";
importLightBitfrom"../fce/light.bit";
importStatefrom"../../99.core/state";
import*asActColfrom"../../97.collect.unit/collect.action";
import*asActLgtfrom"../light.action";
importLgtBitfrom"../fce/light.bit"
import{BabylonModel}from"../../01.babylon.unit/babylon.model";
importLitBitfrom"../fce/lit.bit";
varbit,dat;
exportconstinitLight=(cpy:LightModel,bal:LightBit,ste:State)=>{
debugger
exportconstupdateLight=async(cpy:LightModel,bal:LightBit,ste:State)=>{
bit=awaitste.hunt(ActLgt.READ_LIGHT,{idx:bal.idx})
dat=bit.lgtBit.dat
bal.slv({lgtBit:{idx:"update-light"}});
exportconstreadLight=async(cpy:LightModel,bal:LightBit,ste:State)=>{
varslv=bal.slv;
if(bal.idx==null)bal.idx='lgt00';
bit=awaitste.hunt(ActCol.READ_COLLECT,{idx:bal.idx,bit:ActLgt.CREATE_LIGHT})
bal.slv({mkuBit:{idx:"read-light",dat:bit.clcBit.dat}});
exportconstwriteLight=async(cpy:LightModel,bal:LightBit,ste:State)=>{
if(typeofwindow!="object")returnbal.slv({canBit:{idx:"error-write-light",dat:{}}});
bit=awaitste.hunt(ActCol.WRITE_COLLECT,{idx:bal.idx,src:bal.src,dat:bal.dat,bit:ActLgt.CREATE_LIGHT})
if(bit.clcBit.val!=0)ste.hunt(ActLgt.UPDATE_LIGHT,{idx:bal.idx})
bal.slv({mkuBit:{idx:"write-light",dat:bit.clcBit.dat}});
exportconstremoveLight=async(cpy:LightModel,bal:LightBit,ste:State)=>{
bit=awaitste.hunt(ActCol.REMOVE_COLLECT,{idx:bal.idx,src:bal.src,dat:bal.dat,bit:ActLgt.DELETE_LIGHT})
if(bal.slv!=null)bal.slv({vsgBit:{idx:"remove-light",dat:bit.clcBit}});
bal.slv({mkuBit:{idx:"remove-light"}});
exportconstdeleteLight=(cpy:LightModel,bal:LightBit,ste:State)=>{
debugger
exportconstcreateLight=async(cpy:LightModel,bal:LightBit,ste:State)=>{
if(ste.value.babylon==null){
returnalert("babylonerror")
varmodBab:BabylonModel=ste.value.babylon
if(typeofwindow!="object")returnbal.slv({canBit:{idx:"error-create-light",dat:{}}});
vardat:LitBit={idx:bal.idx}
for(varkeyinbal.dat){
dat[key]=bal.dat[key]
bal.slv({mkuBit:{idx:"create-light",dat}});
exportdefaultinterfaceLightBit{
idx:string;
src?:string;
val?:number;
dat?:any;
slv?:Function;
importLightBitfrom"./light.bit";
exportdefaultinterfaceLight{
exportdefaultinterfaceLitBit{
idx:string;
import{Action}from"../99.core/interface/action.interface";
importLightBitfrom"./fce/light.bit";
exportconstINIT_LIGHT="[Lightaction]InitLight";
exportclassInitLightimplementsAction{
readonlytype=INIT_LIGHT;
constructor(publicbale:LightBit){}
exportconstUPDATE_LIGHT="[Lightaction]UpdateLight";
exportclassUpdateLightimplementsAction{
readonlytype=UPDATE_LIGHT;
constructor(publicbale:LightBit){}
exportconstREAD_LIGHT="[Readaction]ReadLight";
exportclassReadLightimplementsAction{
readonlytype=READ_LIGHT;
constructor(publicbale:LightBit){}
exportconstWRITE_LIGHT="[Writeaction]WriteLight";
exportclassWriteLightimplementsAction{
readonlytype=WRITE_LIGHT;
constructor(publicbale:LightBit){}
exportconstREMOVE_LIGHT="[Removeaction]RemoveLight";
exportclassRemoveLightimplementsAction{
readonlytype=REMOVE_LIGHT;
constructor(publicbale:LightBit){}
exportconstDELETE_LIGHT="[Deleteaction]DeleteLight";
exportclassDeleteLightimplementsAction{
readonlytype=DELETE_LIGHT;
constructor(publicbale:LightBit){}
exportconstCREATE_LIGHT="[Createaction]CreateLight";
exportclassCreateLightimplementsAction{
readonlytype=CREATE_LIGHT;
constructor(publicbale:LightBit){}
exporttypeActions=|InitLight|UpdateLight
|ReadLight
|WriteLight
|RemoveLight
|DeleteLight
|CreateLight
export{initLight}from"./buz/light.buzz";
export{updateLight}from"./buz/light.buzz";
export{readLight}from"./buz/light.buzz";
export{writeLight}from"./buz/light.buzz";
export{removeLight}from"./buz/light.buzz";
export{deleteLight}from"./buz/light.buzz";
export{createLight}from"./buz/light.buzz";
importLightfrom"./fce/light.interface";
importLightBitfrom"./fce/light.interface";
exportclassLightModelimplementsLight{
import*asclonefrom"clone-deep";
import*asActfrom"./light.action";
import{LightModel}from"./light.model";
import*asBuzzfrom"./light.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:LightModel=newLightModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.UPDATE_LIGHT:
returnBuzz.updateLight(clone(model),act.bale,state);
caseAct.INIT_LIGHT:
returnBuzz.initLight(clone(model),act.bale,state);
caseAct.READ_LIGHT:
returnBuzz.readLight(clone(model),act.bale,state);
caseAct.WRITE_LIGHT:
returnBuzz.writeLight(clone(model),act.bale,state);
caseAct.REMOVE_LIGHT:
returnBuzz.removeLight(clone(model),act.bale,state);
caseAct.DELETE_LIGHT:
returnBuzz.deleteLight(clone(model),act.bale,state);
caseAct.CREATE_LIGHT:
returnBuzz.createLight(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassLightUnit{
constructor(state:State){
import{ScreenModel}from"../screen.model";
importScreenBitfrom"../fce/screen.bit";
importStatefrom"../../99.core/state";
import*asActColfrom"../../97.collect.unit/collect.action";
import*asActScrfrom"../screen.action";
importSeeBitfrom"../fce/see.bit";
import*asActFcefrom'../../act/surface.action'
import{BabylonModel}from"../../01.babylon.unit/babylon.model";
varbit
exportconstinitScreen=(cpy:ScreenModel,bal:ScreenBit,ste:State)=>{
debugger
exportconstupdateScreen=(cpy:ScreenModel,bal:ScreenBit,ste:State)=>{
exportconstreadScreen=async(cpy:ScreenModel,bal:ScreenBit,ste:State)=>{
if(bal.idx==null)bal.idx='can00';
bit=awaitste.hunt(ActCol.READ_COLLECT,{idx:bal.idx,bit:ActScr.CREATE_SCREEN})
bal.slv({scrBit:{idx:"read-screen",dat:bit.clcBit.dat}});
exportconstwriteScreen=async(cpy:ScreenModel,bal:ScreenBit,ste:State)=>{
bit=awaitste.hunt(ActCol.WRITE_COLLECT,{idx:bal.idx,src:bal.src,dat:bal.dat,bit:ActScr.CREATE_SCREEN})
if(bit.clcBit.val!=0)ste.hunt(ActScr.UPDATE_SCREEN,{idx:bal.idx})
bal.slv({srcBit:{idx:"write-screen",dat:bit.clcBit.dat}});
exportconstremoveScreen=async(cpy:ScreenModel,bal:ScreenBit,ste:State)=>{
bit=awaitste.hunt(ActCol.REMOVE_COLLECT,{idx:bal.idx,src:bal.src,dat:bal.dat,bit:ActScr.REMOVE_SCREEN})
if(bal.slv!=null)bal.slv({vsgBit:{idx:"remove-screen",dat:bit.clcBit}});
bal.slv({mkuBit:{idx:"remove-screen"}});
exportconstdeleteScreen=(cpy:ScreenModel,bal:ScreenBit,ste:State)=>{
debugger
exportconstcreateScreen=async(cpy:ScreenModel,bal:ScreenBit,ste:State)=>{
vardat:SeeBit={
idx:bal.idx,src:bal.src,
bit:null
for(varkeyinbal.dat){
dat[key]=bal.dat[key]
if(ste.value.babylon==null){
returnalert("babylonerror")
varmodBab:BabylonModel=ste.value.babylon
if(typeofwindow!="object")returnbal.slv({canBit:{idx:"error-create-container",dat:{}}});
varscene=modBab.scene;
if(scene==null){
bal.slv({scrBit:{idx:"create-screen-err",dat:{bit:null}}});
return
bit=awaitwindow['SHADE'](ActFce.LIST_SURFACE,{})
vardex=bit.fceBit.lst.length
varidx='fce'+dex;
bit=awaitwindow['SHADE'](ActFce.WRITE_SURFACE,{idx})
constapp=bit.fceBit.dat.bit
awaitapp.init({background:'#ff00ff',resizeTo:window});
conststageSize=newBABYLON.Vector2(1280,720)
constout=BABYLON.MeshBuilder.CreateGround('out',{width:1,height:1},scene)
constbaseOutScale=stageSize.clone().scale(0.05)
out.scaling.set(baseOutScale.x,1,baseOutScale.y)
out.rotation.x=-Math.PI*0.5
constoutMat=newBABYLON.StandardMaterial('outMat',scene)
out.material=outMat
out.isVisible=true
out.position.z=130;
out.position.y=10;
out.position.x=-10;
constpixiDt=newBABYLON.DynamicTexture('pixi-extract',{width:stageSize.x,height:stageSize.y},scene,false)
constpCtx=pixiDt.getContext()
outMat.emissiveTexture=pixiDt
outMat.diffuseTexture=pixiDt
outMat.opacityTexture=pixiDt
pixiDt.hasAlpha=true
outMat.disableLighting=true
scene.onBeforeRenderObservable.add(()=>{
pCtx.clearRect(0,0,app.canvas.width,app.canvas.height)
pCtx.drawImage(app.canvas,0,0)
pixiDt.update()
scene.onAfterRenderObservable.add(()=>{
app.renderer.clear()
dat.bit=out
bal.slv({scrBit:{idx:"create-screen",dat}});
exportdefaultinterfaceScreenBit{
idx:string;
src?:string;
val?:number;
dat?:any;
slv?:Function;
importScreenBitfrom"./screen.bit";
exportdefaultinterfaceScreen{
exportdefaultinterfaceSeeBit{
idx:string;
src?:string;
bit?:any;
import{Action}from"../99.core/interface/action.interface";
importScreenBitfrom"./fce/screen.bit";
exportconstINIT_SCREEN="[Screenaction]InitScreen";
exportclassInitScreenimplementsAction{
readonlytype=INIT_SCREEN;
constructor(publicbale:ScreenBit){}
exportconstUPDATE_SCREEN="[Screenaction]UpdateScreen";
exportclassUpdateScreenimplementsAction{
readonlytype=UPDATE_SCREEN;
constructor(publicbale:ScreenBit){}
exportconstREAD_SCREEN="[Readaction]ReadScreen";
exportclassReadScreenimplementsAction{
readonlytype=READ_SCREEN;
constructor(publicbale:ScreenBit){}
exportconstWRITE_SCREEN="[Writeaction]WriteScreen";
exportclassWriteScreenimplementsAction{
readonlytype=WRITE_SCREEN;
constructor(publicbale:ScreenBit){}
exportconstREMOVE_SCREEN="[Removeaction]RemoveScreen";
exportclassRemoveScreenimplementsAction{
readonlytype=REMOVE_SCREEN;
constructor(publicbale:ScreenBit){}
exportconstDELETE_SCREEN="[Deleteaction]DeleteScreen";
exportclassDeleteScreenimplementsAction{
readonlytype=DELETE_SCREEN;
constructor(publicbale:ScreenBit){}
exportconstCREATE_SCREEN="[Createaction]CreateScreen";
exportclassCreateScreenimplementsAction{
readonlytype=CREATE_SCREEN;
constructor(publicbale:ScreenBit){}
exporttypeActions=|InitScreen|UpdateScreen
|ReadScreen
|WriteScreen
|RemoveScreen
|DeleteScreen
|CreateScreen
export{initScreen}from"./buz/screen.buzz";
export{updateScreen}from"./buz/screen.buzz";
export{readScreen}from"./buz/screen.buzz";
export{writeScreen}from"./buz/screen.buzz";
export{removeScreen}from"./buz/screen.buzz";
export{deleteScreen}from"./buz/screen.buzz";
export{createScreen}from"./buz/screen.buzz";
importScreenfrom"./fce/screen.interface";
importScreenBitfrom"./fce/screen.interface";
exportclassScreenModelimplementsScreen{
import*asclonefrom"clone-deep";
import*asActfrom"./screen.action";
import{ScreenModel}from"./screen.model";
import*asBuzzfrom"./screen.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:ScreenModel=newScreenModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.UPDATE_SCREEN:
returnBuzz.updateScreen(clone(model),act.bale,state);
caseAct.INIT_SCREEN:
returnBuzz.initScreen(clone(model),act.bale,state);
caseAct.READ_SCREEN:
returnBuzz.readScreen(clone(model),act.bale,state);
caseAct.WRITE_SCREEN:
returnBuzz.writeScreen(clone(model),act.bale,state);
caseAct.REMOVE_SCREEN:
returnBuzz.removeScreen(clone(model),act.bale,state);
caseAct.DELETE_SCREEN:
returnBuzz.deleteScreen(clone(model),act.bale,state);
caseAct.CREATE_SCREEN:
returnBuzz.createScreen(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassScreenUnit{
constructor(state:State){
import{GlopModel}from"../glop.model";
importGlopBitfrom"../fce/glop.bit";
importStatefrom"../../99.core/state";
import*asActColfrom"../../97.collect.unit/collect.action";
import*asActGlpfrom"../glop.action";
importGlpBitfrom"../fce/glp.bit";
import{BabylonModel}from"../../01.babylon.unit/babylon.model";
varbit,dat;
exportconstinitGlop=(cpy:GlopModel,bal:GlopBit,ste:State)=>{
debugger
exportconstupdateGlop=async(cpy:GlopModel,bal:GlopBit,ste:State)=>{
bit=awaitste.hunt(ActGlp.READ_GLOP,{idx:bal.idx})
dat=bit.mkuBit.dat
bal.slv({mkuBit:{idx:"update-miku"}});
exportconstreadGlop=async(cpy:GlopModel,bal:GlopBit,ste:State)=>{
varslv=bal.slv;
if(bal.idx==null)bal.idx='can00';
bit=awaitste.hunt(ActCol.READ_COLLECT,{idx:bal.idx,bit:ActGlp.CREATE_GLOP})
bal.slv({glpBit:{idx:"read-glop",dat:bit.clcBit.dat}});
exportconstwriteGlop=async(cpy:GlopModel,bal:GlopBit,ste:State)=>{
if(typeofwindow!="object")returnbal.slv({canBit:{idx:"error-write-miku",dat:{}}});
bit=awaitste.hunt(ActCol.WRITE_COLLECT,{idx:bal.idx,src:bal.src,dat:bal.dat,bit:ActGlp.CREATE_GLOP})
if(bit.clcBit.val!=0)ste.hunt(ActGlp.UPDATE_GLOP,{idx:bal.idx})
bal.slv({glpBit:{idx:"write-glop",dat:bit.clcBit.dat}});
exportconstdeleteGlop=async(cpy:GlopModel,bal:GlopBit,ste:State)=>{
bit=awaitste.hunt(ActCol.REMOVE_COLLECT,{idx:bal.idx,src:bal.src,dat:bal.dat,bit:ActGlp.CREATE_GLOP})
bal.slv({glpBit:{idx:"remove-miku"}});
exportconstcreateGlop=async(cpy:GlopModel,bal:GlopBit,ste:State)=>{
vardat:GlpBit={idx:bal.idx,src:''}
for(varkeyinbal.dat){
dat[key]=bal.dat[key]
varmodBab:BabylonModel=ste.value.babylon
constmesh=awaitBABYLON.SceneLoader.ImportMeshAsync(undefined,'./hexTile.glb',undefined,modBab.scene).then((result)=>result.meshes[0]);
debugger
modBab.scene.stopAllAnimations();
bal.slv({mkuBit:{idx:"create-miku",dat}});
exportconstremoveGlop=(cpy:GlopModel,bal:GlopBit,ste:State)=>{
debugger
exportdefaultinterfaceGlopBit{
idx:string;
src?:string;
val?:number;
dat?:any;
slv?:Function;
importGlopBitfrom"./glop.bit";
exportdefaultinterfaceGlop{
exportdefaultinterfaceGlpBit{
idx:string;
src:string;
import{Action}from"../99.core/interface/action.interface";
importGlopBitfrom"./fce/glop.bit";
exportconstINIT_GLOP="[Glopaction]InitGlop";
exportclassInitGlopimplementsAction{
readonlytype=INIT_GLOP;
constructor(publicbale:GlopBit){}
exportconstUPDATE_GLOP="[Glopaction]UpdateGlop";
exportclassUpdateGlopimplementsAction{
readonlytype=UPDATE_GLOP;
constructor(publicbale:GlopBit){}
exportconstREAD_GLOP="[Readaction]ReadGlop";
exportclassReadGlopimplementsAction{
readonlytype=READ_GLOP;
constructor(publicbale:GlopBit){}
exportconstWRITE_GLOP="[Writeaction]WriteGlop";
exportclassWriteGlopimplementsAction{
readonlytype=WRITE_GLOP;
constructor(publicbale:GlopBit){}
exportconstDELETE_GLOP="[Deleteaction]DeleteGlop";
exportclassDeleteGlopimplementsAction{
readonlytype=DELETE_GLOP;
constructor(publicbale:GlopBit){}
exportconstCREATE_GLOP="[Createaction]CreateGlop";
exportclassCreateGlopimplementsAction{
readonlytype=CREATE_GLOP;
constructor(publicbale:GlopBit){}
exportconstREMOVE_GLOP="[Removeaction]RemoveGlop";
exportclassRemoveGlopimplementsAction{
readonlytype=REMOVE_GLOP;
constructor(publicbale:GlopBit){}
exporttypeActions=|InitGlop|UpdateGlop
|ReadGlop
|WriteGlop
|DeleteGlop
|CreateGlop
|RemoveGlop
export{initGlop}from"./buz/glop.buzz";
export{updateGlop}from"./buz/glop.buzz";
export{readGlop}from"./buz/glop.buzz";
export{writeGlop}from"./buz/glop.buzz";
export{deleteGlop}from"./buz/glop.buzz";
export{createGlop}from"./buz/glop.buzz";
export{removeGlop}from"./buz/glop.buzz";
importGlopfrom"./fce/glop.interface";
importGlopBitfrom"./fce/glop.interface";
exportclassGlopModelimplementsGlop{
import*asclonefrom"clone-deep";
import*asActfrom"./glop.action";
import{GlopModel}from"./glop.model";
import*asBuzzfrom"./glop.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:GlopModel=newGlopModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.UPDATE_GLOP:
returnBuzz.updateGlop(clone(model),act.bale,state);
caseAct.INIT_GLOP:
returnBuzz.initGlop(clone(model),act.bale,state);
caseAct.READ_GLOP:
returnBuzz.readGlop(clone(model),act.bale,state);
caseAct.WRITE_GLOP:
returnBuzz.writeGlop(clone(model),act.bale,state);
caseAct.DELETE_GLOP:
returnBuzz.deleteGlop(clone(model),act.bale,state);
caseAct.CREATE_GLOP:
returnBuzz.createGlop(clone(model),act.bale,state);
caseAct.REMOVE_GLOP:
returnBuzz.removeGlop(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassGlopUnit{
constructor(state:State){
import{MikuModel}from"../miku.model";
importMikuBitfrom"../fce/miku.bit";
importStatefrom"../../99.core/state";
import*asActColfrom"../../97.collect.unit/collect.action";
import*asActMkufrom"../miku.action";
importMmdBitfrom"../fce/mmd.bit"
import{BabylonModel}from"../../01.babylon.unit/babylon.model";
varbit,dat;
exportconstinitMiku=async(cpy:MikuModel,bal:MikuBit,ste:State)=>{
debugger
exportconstupdateMiku=async(cpy:MikuModel,bal:MikuBit,ste:State)=>{
bit=awaitste.hunt(ActMku.READ_MIKU,{idx:bal.idx})
dat=bit.mkuBit.dat
dat.bit.position=newBABYLON.Vector3(dat.position.x,dat.position.y,dat.position.z);
bal.slv({mkuBit:{idx:"update-miku"}});
exportconstreadMiku=async(cpy:MikuModel,bal:MikuBit,ste:State)=>{
varslv=bal.slv;
if(bal.idx==null)bal.idx='can00';
bit=awaitste.hunt(ActCol.READ_COLLECT,{idx:bal.idx,bit:ActMku.CREATE_MIKU})
bal.slv({mkuBit:{idx:"read-miku",dat:bit.clcBit.dat}});
exportconstwriteMiku=async(cpy:MikuModel,bal:MikuBit,ste:State)=>{
if(typeofwindow!="object")returnbal.slv({canBit:{idx:"error-write-miku",dat:{}}});
bit=awaitste.hunt(ActCol.WRITE_COLLECT,{idx:bal.idx,src:bal.src,dat:bal.dat,bit:ActMku.CREATE_MIKU})
if(bit.clcBit.val!=0)ste.hunt(ActMku.UPDATE_MIKU,{idx:bal.idx})
bal.slv({mkuBit:{idx:"write-miku",dat:bit.clcBit.dat}});
exportconstremoveMiku=async(cpy:MikuModel,bal:MikuBit,ste:State)=>{
bit=awaitste.hunt(ActCol.REMOVE_COLLECT,{idx:bal.idx,src:bal.src,dat:bal.dat,bit:ActMku.DELETE_MIKU})
if(bal.slv!=null)bal.slv({vsgBit:{idx:"remove-container",dat:bit.clcBit}});
bal.slv({mkuBit:{idx:"remove-miku"}});
exportconstdeleteMiku=async(cpy:MikuModel,bal:MikuBit,ste:State)=>{
bal.slv({mkuBit:{idx:"delete-miku"}});
exportconstcreateMiku=async(cpy:MikuModel,bal:MikuBit,ste:State)=>{
if(ste.value.babylon==null){
returnalert("babylonerror")
varmodBab:BabylonModel=ste.value.babylon
if(typeofwindow!="object")returnbal.slv({canBit:{idx:"error-create-container",dat:{}}});
vardat:MmdBit={
idx:bal.idx,src:bal.src,
postition:{x:0,y:0,z:0},
scale:{x:0,y:0,z:0},
rotation:{x:0,y:0,z:0}
for(varkeyinbal.dat){
dat[key]=bal.dat[key]
constmmdMesh=awaitBABYLON.SceneLoader.ImportMeshAsync(undefined,bal.src,undefined,modBab.scene).then((result)=>result.meshes[0]);
constmodelMesh=mmdMeshasBABYLON.Mesh
constmmdModel=modBab.mmdRuntime.createMmdModel(modelMesh);
mmdModel.addAnimation(modBab.motion);
mmdModel.setAnimation("motion");
modBab.mmdRuntime.playAnimation();
dat.bit=modelMesh
bal.slv({mkuBit:{idx:"create-miku",dat}});
exportdefaultinterfaceMikuBit{
idx:string;
src?:string;
val?:number;
dat?:any;
slv?:Function;
importMikuBitfrom"./miku.bit";
exportdefaultinterfaceMiku{
importVBitfrom"./v.bit";
exportdefaultinterfaceMmdBit{
idx:string;
src:string;
postition:VBit;
scale:VBit;
rotation:VBit;
bit:any;
exportdefaultinterfaceVBit{
x:number;
y:number;
z:number;
import{Action}from"../99.core/interface/action.interface";
importMikuBitfrom"./fce/miku.bit";
exportconstINIT_MIKU="[Mikuaction]InitMiku";
exportclassInitMikuimplementsAction{
readonlytype=INIT_MIKU;
constructor(publicbale:MikuBit){}
exportconstUPDATE_MIKU="[Mikuaction]UpdateMiku";
exportclassUpdateMikuimplementsAction{
readonlytype=UPDATE_MIKU;
constructor(publicbale:MikuBit){}
exportconstREAD_MIKU="[Mikuaction]ReadMiku";
exportclassReadMikuimplementsAction{
readonlytype=READ_MIKU;
constructor(publicbale:MikuBit){}
exportconstWRITE_MIKU="[Mikuaction]WriteMiku";
exportclassWriteMikuimplementsAction{
readonlytype=WRITE_MIKU;
constructor(publicbale:MikuBit){}
exportconstDELETE_MIKU="[Mikuaction]DeleteMiku";
exportclassDeleteMikuimplementsAction{
readonlytype=DELETE_MIKU;
constructor(publicbale:MikuBit){}
exportconstREMOVE_MIKU="[Mikuaction]RemoveMiku";
exportclassRemoveMikuimplementsAction{
readonlytype=REMOVE_MIKU;
constructor(publicbale:MikuBit){}
exportconstCREATE_MIKU="[Mikuaction]CreateMiku";
exportclassCreateMikuimplementsAction{
readonlytype=CREATE_MIKU;
constructor(publicbale:MikuBit){}
exporttypeActions=|InitMiku|UpdateMiku|ReadMiku|WriteMiku|DeleteMiku|RemoveMiku|CreateMiku;
export{initMiku}from"./buz/miku.buzz";
export{updateMiku}from"./buz/miku.buzz";
export{readMiku}from"./buz/miku.buzz";
export{writeMiku}from"./buz/miku.buzz";
export{removeMiku}from"./buz/miku.buzz";
export{deleteMiku}from"./buz/miku.buzz";
export{createMiku}from"./buz/miku.buzz";
importMikufrom"./fce/miku.interface";
importMikuBitfrom"./fce/miku.interface";
exportclassMikuModelimplementsMiku{
import*asActfrom"./miku.action";
import{MikuModel}from"./miku.model";
import*asBuzzfrom"./miku.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:MikuModel=newMikuModel(),act:Act.Actions,state?:State){
varclone=require('clone-deep');
switch(act.type){
caseAct.UPDATE_MIKU:
returnBuzz.updateMiku(clone(model),act.bale,state);
caseAct.INIT_MIKU:
returnBuzz.initMiku(clone(model),act.bale,state);
caseAct.READ_MIKU:
returnBuzz.readMiku(clone(model),act.bale,state);
caseAct.WRITE_MIKU:
returnBuzz.writeMiku(clone(model),act.bale,state);
caseAct.REMOVE_MIKU:
returnBuzz.removeMiku(clone(model),act.bale,state);
caseAct.DELETE_MIKU:
returnBuzz.deleteMiku(clone(model),act.bale,state);
caseAct.CREATE_MIKU:
returnBuzz.createMiku(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassMikuUnit{
constructor(state:State){
import*asActColfrom'../../97.collect.unit/collect.action';
varbit,lst,dat,idx,val,src,dex;
exportconstinitCollect=(cpy:CollectModel,bal:CollectBit,ste:State)=>{
exportconstupdateCollect=(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
exportconstfetchCollect=(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
if(bal.val==null)bal.val=1;
if(bal.bit==null)
bal.slv({clcBit:{idx:'fetch-collect-err',src:'no-bit'}});
vartype=bal.bit.split('').slice(-1).pop().toLowerCase();
varcabBit:CaboodleBit=cpy.caboodleBitList[cpy.caboodleBits[type]];
if(bal.val==1)bit=cabBit.bitList[0];
elsebit=cabBit;
if(bal.slv!=null)bal.slv({clcBit:{idx:'fetch-collect',dat:bit}});
exportconstreadCollect=async(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
if(bal.bit==null)
bal.slv({clcBit:{idx:'read-collect-err',src:'no-bit'}});
vartype=bal.bit.split('').slice(-1).pop().toLowerCase();
if(cpy.caboodleBits[type]==null)createCollect(cpy,{idx:type},ste);
varcabBit:CaboodleBit=cpy.caboodleBitList[cpy.caboodleBits[type]];
if(cabBit.bits[bal.idx]==null){
bit=awaitste.hunt(ActCol.WRITE_COLLECT,{
idx:bal.idx,
src:bal.src,
bit:bal.bit,
}else{
dat=cabBit.bitList[cabBit.bits[bal.idx]];
if(bal.slv!=null)bal.slv({clcBit:{idx:'read-collect',dat}});
exportconstwriteCollect=async(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
dat=null;
vartype=bal.bit.split('').slice(-1).pop().toLowerCase();
if(cpy.caboodleBits[type]==null)createCollect(cpy,{idx:type},ste);
if(bal.bit==null)
bal.slv({rskBit:{idx:'write-collect-err',src:'no-bit'}});
varcabBit:CaboodleBit=cpy.caboodleBitList[cpy.caboodleBits[type]];
bal.idx;
val=0;
if(cabBit.bits[bal.idx]==null){
bit=awaitste.hunt(bal.bit,{idx:bal.idx,src:bal.src,dat:bal.dat});
varobjDat=bit[Object.keys(bit)[0]];
dat=objDat.dat;
if(dat==null)dat={};
dat.dex=cabBit.bitList.length;
cabBit.bitList.push(dat);
varidx=bal.idx;
if(idx==null)idx=dat.idx;
if(idx==null)thrownewError('writecollecthasnoidx');
cabBit.bits[idx]=dat.dex;
}else{
varcabDat=cabBit.bitList[cabBit.bits[bal.idx]];
bal.dat;
val=1;
for(varkeyinbal.dat){
if(cabDat==null)cabDat={};
cabDat[key]=bal.dat[key];
cabBit.bitList[cabBit.bits[bal.idx]]=cabDat;
dat=cabDat;
if(dat==null&&bal.slv!=null)
bal.slv({rskBit:{idx:'write-collect-err',src:'no-dat'}});
if(bal.slv!=null)bal.slv({clcBit:{idx:'write-collect',val,dat}});
exportconstcreateCollect=(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
varcabBit:CaboodleBit={idx:bal.idx,dex:0,bits:{},bitList:[]};
cabBit.dex=cpy.caboodleBitList.length;
cpy.caboodleBitList.push(cabBit);
cpy.caboodleBits[cabBit.idx]=cabBit.dex;
if(bal.slv!=null)
bal.slv({clcBit:{idx:'create-collect',dat:cabBit}});
exportconstremoveCollect=async(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
vartype=bal.bit.split('').slice(-1).pop().toLowerCase();
if(cpy.caboodleBits[type]==null)
returnbal.slv({rskBit:{idx:'remove-collect-not-present'}});
varcabBit:CaboodleBit=cpy.caboodleBitList[cpy.caboodleBits[type]];
if(cabBit.bits[bal.idx]==null)
returnbal.slv({rskBit:{idx:'remove-collect-idx-not-present'}});
bit=awaitste.hunt(bal.bit,{idx:bal.idx,src:bal.src,dat:bal.dat});
varobjDat=bit[Object.keys(bit)[0]];
dat=objDat.dat;
dex=dat.dex;
for(vari=dex;i<cabBit.bitList.length-1;i++){
varupdate=cabBit.bitList[i];
update.dex-=1;
for(varkeyindat){
dat[key]=null;
deletecabBit.bits[bal.idx];
varitm=cabBit.bitList.splice(dex,1);
cabBit.dex-=1;
if(bal.slv!=null)
bal.slv({clcBit:{idx:'remove-collect',dat:itm[0]}});
exportconstputCollect=(cpy:CollectModel,bal:CollectBit,ste:State)=>{
cpy.caboodleBits[bal.idx]=bal.val;
cpy.caboodleBitList[bal.val]=bal.dat;
if(bal.slv!=null)
bal.slv({clcBit:{idx:'put-collect',dat:bal.dat}});
exportconstgetCollect=(cpy:CollectModel,bal:CollectBit,ste:State)=>{
val=cpy.caboodleBits[bal.idx];
dat=cpy.caboodleBitList[val];
if(bal.slv!=null)bal.slv({clcBit:{idx:'get-collect',val,dat}});
exportconstmodelCollect=(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
if(bal.slv!=null)bal.slv({clcBit:{idx:'model-collect',dat:cpy}});
exportconstdeleteCollect=(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
exportconstemptyCollect=(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
exportconstdotCollect=(cpy:CollectModel,bal:CollectBit,ste:State)=>{
vargel=bal.dat;
varout=[];
bal.src.split('\n').forEach((a,b)=>{
vardoTCompiled=doT.template(a);
varoutLine=doTCompiled(gel);
out.push(outLine);
if(bal.slv!=null)
bal.slv({clcBit:{idx:'dot-vurt',lst:out,src:out.join('\n')}});
exportconstformatCollect=(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
lst=bal.src.split(':');
varidx=lst[0];
varout=[];
idx=S(idx).collapseWhitespace().s;
varopt=lst[1].split(',');
opt.forEach((a,b)=>{
varnow=S(a).collapseWhitespace().s;
if(a.length<1)return;
out.push(now);
dat=[idx,out];
bal.slv({clcBit:{idx:'format-collect',dat}});
exportconstlistCollect=(cpy:CollectModel,bal:CollectBit,ste:State)=>{
vartype=bal.bit.split('').slice(-1).pop().toLowerCase();
if(cpy.caboodleBits[type]==null)createCollect(cpy,{idx:type},ste);
varcabBit:CaboodleBit=cpy.caboodleBitList[cpy.caboodleBits[type]];
lst=[];
cabBit.bitList.forEach((a)=>{
if(a.idx!=null)lst.push(a.idx);
if(a.id!=null)lst.push(a.id);
bal.slv({clcBit:{idx:'list-collect',lst}});
exportconsthashCollect=(cpy:CollectModel,bal:CollectBit,ste:State)=>{
if(bal.src==null)bal.src='';
lst=bal.src.split('\n');
dat={};
lst.forEach((a)=>{
a=S(a).collapseWhitespace().s;
if(a.length<3)return;
varhold=a.split(':');
vardom=hold[0];
varsub=hold[1];
varnow=sub.split(',');
now.forEach((b,c)=>{
now[c]=S(b).collapseWhitespace().s;
dat[dom]=now;
bal.slv({clcBit:{idx:'hash-collect',dat}});
import{CollectModel}from'../collect.model';
importCollectBitfrom'../fce/collect.bit';
importStatefrom'../../99.core/state';
importCaboodleBitfrom'../fce/caboodle.bit';
import*asSfrom'string';
import*asdoTfrom'dot';
import{Action}from"../99.core/interface/action.interface";
importCollectBitfrom"./fce/collect.bit";
exportconstINIT_COLLECT="[Collectaction]InitCollect";
exportclassInitCollectimplementsAction{
readonlytype=INIT_COLLECT;
constructor(publicbale:CollectBit){}
exportconstUPDATE_COLLECT="[Collectaction]UpdateCollect";
exportclassUpdateCollectimplementsAction{
readonlytype=UPDATE_COLLECT;
constructor(publicbale:CollectBit){}
exportconstFETCH_COLLECT="[Collectaction]FetchCollect";
exportclassFetchCollectimplementsAction{
readonlytype=FETCH_COLLECT;
constructor(publicbale:CollectBit){}
exportconstREAD_COLLECT="[Readaction]ReadCollect";
exportclassReadCollectimplementsAction{
readonlytype=READ_COLLECT;
constructor(publicbale:CollectBit){}
exportconstWRITE_COLLECT="[Writeaction]WriteCollect";
exportclassWriteCollectimplementsAction{
readonlytype=WRITE_COLLECT;
constructor(publicbale:CollectBit){}
exportconstCREATE_COLLECT="[Createaction]CreateCollect";
exportclassCreateCollectimplementsAction{
readonlytype=CREATE_COLLECT;
constructor(publicbale:CollectBit){}
exportconstREMOVE_COLLECT="[Createaction]RemoveCollect";
exportclassRemoveCollectimplementsAction{
readonlytype=REMOVE_COLLECT;
constructor(publicbale:CollectBit){}
exportconstDELETE_COLLECT="[Createaction]DeleteCollect";
exportclassDeleteCollectimplementsAction{
readonlytype=DELETE_COLLECT;
constructor(publicbale:CollectBit){}
exportconstEMPTY_COLLECT="[Emptyaction]EmptyCollect";
exportclassEmptyCollectimplementsAction{
readonlytype=EMPTY_COLLECT;
constructor(publicbale:CollectBit){}
exportconstMODEL_COLLECT="[Emptyaction]ModelCollect";
exportclassModelCollectimplementsAction{
readonlytype=MODEL_COLLECT;
constructor(publicbale:CollectBit){}
exportconstPUT_COLLECT="[Emptyaction]PutCollect";
exportclassPutCollectimplementsAction{
readonlytype=PUT_COLLECT;
constructor(publicbale:CollectBit){}
exportconstGET_COLLECT="[Emptyaction]GetCollect";
exportclassGetCollectimplementsAction{
readonlytype=GET_COLLECT;
constructor(publicbale:CollectBit){}
exportconstFORMAT_COLLECT="[Formataction]FormatCollect";
exportclassFormatCollectimplementsAction{
readonlytype=FORMAT_COLLECT;
constructor(publicbale:CollectBit){}
exportconstDOT_COLLECT="[Formataction]DotCollect";
exportclassDotCollectimplementsAction{
readonlytype=DOT_COLLECT;
constructor(publicbale:CollectBit){}
exportconstLIST_COLLECT="[Listaction]ListCollect";
exportclassListCollectimplementsAction{
readonlytype=LIST_COLLECT;
constructor(publicbale:CollectBit){}
exportconstHASH_COLLECT="[Hashaction]HashCollect";
exportclassHashCollectimplementsAction{
readonlytype=HASH_COLLECT;
constructor(publicbale:CollectBit){}
exporttypeActions=|InitCollect|UpdateCollect
|ReadCollect
|WriteCollect
|CreateCollect
|EmptyCollect
|FetchCollect
|DeleteCollect
|RemoveCollect
|ModelCollect
|GetCollect
|PutCollect
|FormatCollect
|DotCollect
|ListCollect
|HashCollect
export{initCollect}from"./buz/collect.buzz";
export{updateCollect}from"./buz/collect.buzz";
export{readCollect}from"./buz/collect.buzz";
export{writeCollect}from"./buz/collect.buzz";
export{createCollect}from"./buz/collect.buzz";
export{emptyCollect}from"./buz/collect.buzz";
export{fetchCollect}from"./buz/collect.buzz";
export{deleteCollect}from"./buz/collect.buzz";
export{removeCollect}from"./buz/collect.buzz";
export{modelCollect}from"./buz/collect.buzz";
export{putCollect}from"./buz/collect.buzz";
export{getCollect}from"./buz/collect.buzz";
export{formatCollect}from"./buz/collect.buzz";
export{dotCollect}from"./buz/collect.buzz";
export{listCollect}from"./buz/collect.buzz";
export{hashCollect}from"./buz/collect.buzz";
importCaboodleBitfrom"./fce/caboodle.bit";
importCollectfrom"./fce/collect.interface";
importCollectBitfrom"./fce/collect.interface";
exportclassCollectModelimplementsCollect{
idx:string='23.11.14';
caboodleBitList:CaboodleBit[]=[];
caboodleBits:any={};
import*asActfrom"./collect.action";
import{CollectModel}from"./collect.model";
import*asBuzzfrom"./collect.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:CollectModel=newCollectModel(),act:Act.Actions,state?:State){
varclone=require('clone-deep');
switch(act.type){
caseAct.UPDATE_COLLECT:
returnBuzz.updateCollect(clone(model),act.bale,state);
caseAct.INIT_COLLECT:
returnBuzz.initCollect(clone(model),act.bale,state);
caseAct.READ_COLLECT:
returnBuzz.readCollect(clone(model),act.bale,state);
caseAct.WRITE_COLLECT:
returnBuzz.writeCollect(clone(model),act.bale,state);
caseAct.CREATE_COLLECT:
returnBuzz.createCollect(clone(model),act.bale,state);
caseAct.DELETE_COLLECT:
returnBuzz.deleteCollect(clone(model),act.bale,state);
caseAct.REMOVE_COLLECT:
returnBuzz.removeCollect(clone(model),act.bale,state);
caseAct.EMPTY_COLLECT:
returnBuzz.emptyCollect(clone(model),act.bale,state);
caseAct.FETCH_COLLECT:
returnBuzz.fetchCollect(clone(model),act.bale,state);
caseAct.MODEL_COLLECT:
returnBuzz.modelCollect(clone(model),act.bale,state);
caseAct.GET_COLLECT:
returnBuzz.getCollect(clone(model),act.bale,state);
caseAct.PUT_COLLECT:
returnBuzz.putCollect(clone(model),act.bale,state);
caseAct.FORMAT_COLLECT:
returnBuzz.formatCollect(clone(model),act.bale,state);
caseAct.DOT_COLLECT:
returnBuzz.dotCollect(clone(model),act.bale,state);
caseAct.LIST_COLLECT:
returnBuzz.listCollect(clone(model),act.bale,state);
caseAct.HASH_COLLECT:
returnBuzz.hashCollect(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassCollectUnit{
constructor(state:State){
exportdefaultinterfaceCaboodleBit{
idx:string;
dex:number;
bitList:any[];
bits:any;
exportdefaultinterfaceCollectBit{
idx?:string;
src?:string;
val?:number;
dex?:number;
dat?:any;
bit?:any;
slv?:Function;
importCollectBitfrom"./collect.bit";
importCaboodleBitfrom"./caboodle.bit";
exportdefaultinterfaceCollect{
idx:string;
caboodleBitList:CaboodleBit[];
caboodleBits:any;
import{Action}from"../99.core/interface/action.interface";
importBusBitfrom"./fce/bus.bit";
exportconstINIT_BUS="[Busaction]InitBus";
exportclassInitBusimplementsAction{
readonlytype=INIT_BUS;
constructor(publicbale:BusBit){}
exportconstOPEN_BUS="[Busaction]OpenBus";
exportclassOpenBusimplementsAction{
readonlytype=OPEN_BUS;
constructor(publicbale:BusBit){}
exportconstCONNECT_BUS="[Busaction]ConnectBus";
exportclassConnectBusimplementsAction{
readonlytype=CONNECT_BUS;
constructor(publicbale:BusBit){}
exportconstMESSAGE_BUS="[Busaction]MessageBus";
exportclassMessageBusimplementsAction{
readonlytype=MESSAGE_BUS;
constructor(publicbale:BusBit){}
exportconstUPDATE_BUS="[Busaction]UpdateBus";
exportclassUpdateBusimplementsAction{
readonlytype=UPDATE_BUS;
constructor(publicbale:BusBit){}
exportconstCREATE_BUS="[Busaction]CreateBus";
exportclassCreateBusimplementsAction{
readonlytype=CREATE_BUS;
constructor(publicbale:BusBit){}
exporttypeActions=|InitBus|OpenBus|UpdateBus|ConnectBus|MessageBus|CreateBus;
export{initBus}from"./buz/bus.buzz";
export{openBus}from"./buz/bus.buzz";
export{updateBus}from"./buz/bus.buzz";
export{connectBus}from"./buz/bus.buzz";
export{messageBus}from"./buz/bus.buzz";
export{createBus}from"./buz/bus.buzz";
importBusfrom"./fce/bus.interface";
importBusBitfrom"./fce/bus.interface";
exportclassBusModelimplementsBus{
MQTT:any;
actList:any;
client:any;
bus:Function;
responseSuffix:string='-response'
promises:any={}
import*asActfrom"./bus.action";
import{BusModel}from"./bus.model";
import*asBuzzfrom"./bus.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:BusModel=newBusModel(),act:Act.Actions,state?:State){
varclone=require('clone-deep');
switch(act.type){
caseAct.UPDATE_BUS:
returnBuzz.updateBus(clone(model),act.bale,state);
caseAct.OPEN_BUS:
returnBuzz.openBus(clone(model),act.bale,state);
caseAct.CONNECT_BUS:
returnBuzz.connectBus(clone(model),act.bale,state);
caseAct.CREATE_BUS:
returnBuzz.createBus(clone(model),act.bale,state);
caseAct.MESSAGE_BUS:
returnBuzz.connectBus(clone(model),act.bale,state);
caseAct.INIT_BUS:
returnBuzz.initBus(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassBusUnit{
constructor(state:State){
import*asActBusfrom"../../99.bus.unit/bus.action";
import*asActColfrom"../../97.collect.unit/collect.action";
varlst,idx,bit,src,dat,dex;
exportconstinitBus=(cpy:BusModel,bal:BusBit,ste:State)=>{
cpy.actList=[]
if(bal==null)bal={idx:null}
if(bal.lst==null)bal.lst=[]
if((bal.src!=null)&&(bal.src.constructor==Array))lst=bal.src;
bal.lst.forEach((a)=>{
for(varkeyina){
cpy.actList.push(a[key])
ste.bus=(idx,dat,bit)=>updateBus(cpy,{idx,dat,bit},ste)
if(bal.dat!=null){
cpy.MQTT=bal.dat;
else{
if(lst==null){
if(bal.src!=null)cpy.host=bal.src
cpy.client=cpy.MQTT.connect(cpy.host);
cpy.client.on('message',(tpc,msg)=>{messageBus(cpy,{idx:tpc,src:msg},ste)})
cpy.client.on('connect',()=>{
openBus(cpy,{idx:'init-bus',lst:cpy.actList},ste)
if(bal.slv!=null)bal.slv({intBit:{idx:"init-bus"}})
}else{
varcomplete=(lst)=>{
lst.shift()
if(lst.length!=0)return
if(bal.slv!=null)bal.slv({intBit:{idx:"init-bus"}})
lst.forEach(async(a)=>{
bit=awaitste.hunt(ActCol.WRITE_COLLECT,{idx:a.idx,src:a.src,bit:ActBus.CREATE_BUS})
varclient=bit.clcBit.dat;
client.on('message',(tpc,msg)=>{messageBus(cpy,{idx:tpc,src:msg,bit:a.idx},ste)})
client.on('connect',()=>{
openBus(cpy,{idx:'init-bus',lst:cpy.actList,bit:a.idx},ste)
complete(lst)
exportconstcreateBus=(cpy:BusModel,bal:BusBit,ste:State)=>{
varclient=cpy.MQTT.connect(bal.src);
if(bal.slv!=null)bal.slv({busBit:{idx:"create-bus",dat:client}});
exportconstopenBus=async(cpy:BusModel,bal:BusBit,ste:State)=>{
varout=[]
bal.lst.forEach((a)=>{
if(a==null)return
if(a.includes==null)return
if(a.includes('[')&&a.includes(']')==false)return
out.push(a)
varclient=cpy.client;
if(bal.bit!=null){
bit=awaitste.hunt(ActCol.READ_COLLECT,{idx:bal.bit,bit:ActBus.CREATE_BUS})
client=bit.clcBit.dat
out.forEach((a)=>{
client.subscribe(a,(err)=>{
if(!err){
exportconstconnectBus=(cpy:BusModel,bal:BusBit,ste:State)=>{
varlst=[]
exportconstmessageBus=async(cpy:BusModel,bal:BusBit,ste:State)=>{
if(bal.src!=null)dat=bal.src.toString()
idx=bal.idx
dat=JSON.parse(dat)
varclient=cpy.client;
if(bal.bit!=null){
bit=awaitste.hunt(ActCol.READ_COLLECT,{idx:bal.bit,bit:ActBus.CREATE_BUS})
client=bit.clcBit.dat
if(idx.includes(cpy.responseSuffix)==true){
varresponseIDX=bal.idx;
varobj=cpy.promises[responseIDX];
if(obj.slv!=null)obj.slv(dat);
client.unsubscribe(responseIDX,(err)=>{
if(!err){
}else{
varbit=awaitste.hunt(idx,dat)
varcloneBit=clone(bit)
for(varkeyincloneBit){
varitm=cloneBit[key]
if(itm.dat!=null){
if(itm.dat.bit!=null)itm.dat.bit=null
cloneBit
client.publish(bal.idx+cpy.responseSuffix,JSON.stringify(cloneBit))
exportconstupdateBus=async(cpy:BusModel,bal:BusBit,ste:State)=>{
varclient=cpy.client;
if(bal.bit!=null){
bit=awaitste.hunt(ActCol.READ_COLLECT,{idx:bal.bit,bit:ActBus.CREATE_BUS})
client=bit.clcBit.dat
if((client==null)&&(bal.bit==null)){
bit=awaitste.hunt(ActCol.FETCH_COLLECT,{bit:ActBus.CREATE_BUS})
client=bit.clcBit.dat
varresponseIDX=bal.idx+cpy.responseSuffix;
varslv;
constpromo=newPromise((rslv,rjct)=>(slv=rslv));
varobj={slv:(val0)=>slv(val0)};
cpy.promises[responseIDX]=obj
client.subscribe(responseIDX,(err)=>{
if(!err){
client.publish(bal.idx,JSON.stringify(bal.dat))
returnpromo;
varpatch=(ste,type,bale)=>ste.dispatch({type,bale});
import{BusModel}from"../bus.model";
importBusBitfrom"../fce/bus.bit";
importStatefrom"../../99.core/state";
importSfrom"string";
import*asclonefrom"clone-deep";
exportdefaultinterfaceBusBit{
idx:string;
val?:number;
lst?:any;
src?:any;
bit?:string;
slv?:Function;
dat?:any;
importBusBitfrom"./bus.bit";
exportdefaultinterfaceBus{
exportinterfaceAction<T=any>{
type:string;
bale?:T;
exportdefaultinterfaceModel{}
import{BehaviorSubject}from"rx-lite";
import{Subject}from"rx-lite";
import{Action}from"./interface/action.interface";
importUnitModelfrom"../BEE";
import*asEffectfrom"../BEE";
exportdefaultclassStateextendsBehaviorSubject<any>{
publichunt:any;
publicvalue:any;
publicpivot:any;
publicbus:any;
privatedispatcher:Subject=newSubject();
constructor(init:UnitModel=newUnitModel()){
super(init);
this.dispatcher
.scan((state,action)=>this.reducedApp(state,action),init)
.subscribe((state)=>{
super.onNext(state);
reducedApp(nextState:any,key:any){
for(varkinEffect.reducer)Effect.reducer[k](nextState[k],key,this);
returnnextState;
dispatch(value:Action){
varresult=this.dispatcher.onNext(value);
returnresult;
pat(value:Action){
this.dispatch(value);
next(value:any){
this.dispatcher.onNext(value);
exportconstINIT_CONSOLE="[Consoleaction]InitConsole";
exportconstUPDATE_CONSOLE="[Consoleaction]UpdateConsole";
exportconstREAD_CONSOLE="[Readaction]ReadConsole";
exportconstWRITE_CONSOLE="[Writeaction]WriteConsole";
exportconstREMOVE_CONSOLE="[Removeaction]RemoveConsole";
exportconstDELETE_CONSOLE="[Deleteaction]DeleteConsole";
exportconstCREATE_CONSOLE="[Createaction]CreateConsole";
exportconstINIT_DISK="[Diskaction]InitDisk";
exportconstUPDATE_DISK="[Diskaction]UpdateDisk";
exportconstREAD_DISK="[Diskaction]ReadDisk";
exportconstWRITE_DISK="[Diskaction]WriteDisk";
exportconstLIST_DISK="[Listaction]ListDisk";
exportconstLOAD_LIST_DISK="[Load_listaction]Load_listDisk";
exportconstCOPY_DISK="[Copyaction]CopyDisk";
exportconstINIT_PIVOT="[Pivotaction]InitPivot";
exportconstUPDATE_PIVOT="[Pivotaction]UpdatePivot";
exportconstOPEN_PIVOT="[Openaction]OpenPivot";
exportconstRUN_PIVOT="[Runaction]RunPivot";
exportconstEDIT_PIVOT="[Editaction]EditPivot";
exportconstPATCH_PIVOT="[Patchaction]PatchPivot";
exportconstCOUNT_PIVOT="[Patchaction]CountPivot";
exportconstLIST_PIVOT="[Patchaction]ListPivot";
exportconstCREATE_PIVOT="[Patchaction]CreatePivot";
exportconstCONTAINS_PIVOT="[Patchaction]ContainsPivot";
exportconstBUNDLE_PIVOT="[Patchaction]BundlePivot";
exportconstINIT_RENPY="[Renpyaction]InitRenpy";
exportconstUPDATE_RENPY="[Renpyaction]UpdateRenpy";
exportconstOPEN_RENPY="[Renpyaction]OpenRenpy";
exportconstINIT_SHINY="[Shinyaction]InitShiny";
exportconstUPDATE_SHINY="[Shinyaction]UpdateShiny";
exportconstOPEN_SHINY="[Shinyaction]OpenShiny";
exportconstINIT_SPACE="[Spaceaction]InitSpace";
exportconstUPDATE_SPACE="[Spaceaction]UpdateSpace";
exportconstREADY_SPACE="[Readyaction]ReadySpace";
exportconstINIT_SURFACE="[Surfaceaction]InitSurface";
exportconstUPDATE_SURFACE="[Surfaceaction]UpdateSurface";
exportconstREAD_SURFACE="[Readaction]ReadSurface";
exportconstWRITE_SURFACE="[Writeaction]WriteSurface";
exportconstREMOVE_SURFACE="[Writeaction]RemoveSurface";
exportconstCREATE_SURFACE="[Createaction]CreateSurface";
exportconstDIMENSION_SURFACE="[Dimensionaction]DimensionSurface";
exportconstDELETE_SURFACE="[Deleteaction]DeleteSurface";
exportconstEXTRACT_SURFACE="[Extractaction]ExtractSurface";
exportconstLIST_SURFACE="[Listaction]ListSurface";
exportconstINIT_TERMINAL="[Terminalaction]InitTerminal";
exportconstOPEN_TERMINAL="[Terminalaction]OpenTerminal";
exportconstFOCUS_TERMINAL="[Terminalaction]FocusTerminal";
exportconstWRITE_TERMINAL="[Terminalaction]WriteTerminal";
exportconstUPDATE_TERMINAL="[Terminalaction]UpdateTerminal";
exportconstCLEAR_TERMINAL="[Terminalaction]ClearTerminal";
exportconstINPUT_TERMINAL="[Terminalaction]InputTerminal";
exportconstTABLE_TERMINAL="[Terminalaction]TableTerminal";
exportconstCLOSE_TERMINAL="[Terminalaction]CloseTerminal";
exportconstROOT_TERMINAL="[Terminalaction]RootTerminal";
exportconstCONTENT_TERMINAL="[Terminalaction]ContentTerminal";
exportconstADD_PORT="[Terminalaction]AddPort";
exportconstINIT_VURT="[Vurtaction]InitVurt";
exportconstDELAY_VURT="[Vurtaction]DelayVurt";
exportconstTEST_CLOUD_VURT="[Vurtaction]TestCloudVurt";
exportconstFETCH_VURT="[Vurtaction]FetchVurt";
exportconstUPDATE_VURT="[Vurtaction]UpdateVurt";
exportconstREPLACE_VURT="[Vurtaction]ReplaceVurt";
exportconstUNIT_VURT="[Vurtaction]UnitVurt";
exportconstCOUNT_VURT="[Vurtaction]CountVurt";
exportconstLIST_PIVOT_VURT="[Vurtaction]ListPivotVurt";
exportconstLIST_UNIT_VURT="[Vurtaction]ListUnitVurt";
exportconstCONTAINS_VURT="[Containsaction]ContainsVurt";
exportconstBUNDLE_VURT="[Bundleaction]BundleVurt";
exportconstVALUE_VURT="[Valueaction]ValueVurt";
importModelfrom"./99.core/interface/model.interface";
importSolidUnitfrom"./00.solid.unit/solid.unit";
importBabylonUnitfrom"./01.babylon.unit/babylon.unit";
importCameraUnitfrom"./02.camera.unit/camera.unit";
importLightUnitfrom"./03.light.unit/light.unit";
importScreenUnitfrom"./08.screen.unit/screen.unit";
importGlopUnitfrom"./09.glop.unit/glop.unit";
importMikuUnitfrom"./10.miku.unit/miku.unit";
importCollectUnitfrom"./97.collect.unit/collect.unit";
importBusUnitfrom"./99.bus.unit/bus.unit";
importSolidfrom"./00.solid.unit/fce/solid.interface";
import{SolidModel}from"./00.solid.unit/solid.model";
importBabylonfrom"./01.babylon.unit/fce/babylon.interface";
import{BabylonModel}from"./01.babylon.unit/babylon.model";
importCamerafrom"./02.camera.unit/fce/camera.interface";
import{CameraModel}from"./02.camera.unit/camera.model";
importLightfrom"./03.light.unit/fce/light.interface";
import{LightModel}from"./03.light.unit/light.model";
importScreenfrom"./08.screen.unit/fce/screen.interface";
import{ScreenModel}from"./08.screen.unit/screen.model";
importGlopfrom"./09.glop.unit/fce/glop.interface";
import{GlopModel}from"./09.glop.unit/glop.model";
importMikufrom"./10.miku.unit/fce/miku.interface";
import{MikuModel}from"./10.miku.unit/miku.model";
importCollectfrom"./97.collect.unit/fce/collect.interface";
import{CollectModel}from"./97.collect.unit/collect.model";
importBusfrom"./99.bus.unit/fce/bus.interface";
import{BusModel}from"./99.bus.unit/bus.model";
exportconstlist:Array<any>=[SolidUnit,BabylonUnit,CameraUnit,LightUnit,ScreenUnit,GlopUnit,MikuUnit,CollectUnit,BusUnit];
import*asreduceFromSolidfrom"./00.solid.unit/solid.reduce";
import*asreduceFromBabylonfrom"./01.babylon.unit/babylon.reduce";
import*asreduceFromCamerafrom"./02.camera.unit/camera.reduce";
import*asreduceFromLightfrom"./03.light.unit/light.reduce";
import*asreduceFromScreenfrom"./08.screen.unit/screen.reduce";
import*asreduceFromGlopfrom"./09.glop.unit/glop.reduce";
import*asreduceFromMikufrom"./10.miku.unit/miku.reduce";
import*asreduceFromCollectfrom"./97.collect.unit/collect.reduce";
import*asreduceFromBusfrom"./99.bus.unit/bus.reduce";
exportconstreducer:any={
solid:reduceFromSolid.reducer,
babylon:reduceFromBabylon.reducer,
camera:reduceFromCamera.reducer,
light:reduceFromLight.reducer,
screen:reduceFromScreen.reducer,
glop:reduceFromGlop.reducer,
miku:reduceFromMiku.reducer,
collect:reduceFromCollect.reducer,
bus:reduceFromBus.reducer,
exportdefaultclassUnitDataimplementsModel{
solid:Solid=newSolidModel();
babylon:Babylon=newBabylonModel();
camera:Camera=newCameraModel();
light:Light=newLightModel();
screen:Screen=newScreenModel();
glop:Glop=newGlopModel();
miku:Miku=newMikuModel();
collect:Collect=newCollectModel();
bus:Bus=newBusModel();
varsim={
hunt:null,
state:null
sim.hunt=(typ,obj)=>{returnhost(obj,typ)}
varhost=(obj,typ)=>{
init();
varslv;
constpromo=newPromise((rslv,rjct)=>(slv=rslv));
if(obj==null)obj={};
if(obj.slv==null)obj.slv=(val0)=>slv(val0);
sim.state.dispatch({type:typ,bale:obj});
returnpromo;
varinit=()=>{
if(sim.state!=null)return;
sim.state=newState();
sim.state.pivot=sim;
sim.state.hunt=sim.hunt
for(varkinImport.list)newImport.list[k](sim.state);
import*asImportfrom"./BEE";
importStatefrom"./99.core/state";
module.exports=sim;
"usestrict";
exports.__esModule=true;
exports.CYAN=exports.MAGENTA=exports.YELLOW=exports.GREEN=exports.RED=void0;
exports.RED="\x1b[31m%s\x1b[0m";
exports.GREEN="\x1b[32m%s\x1b[0m";
exports.YELLOW="\x1b[33m%s\x1b[0m";
exports.MAGENTA="\x1b[34m%s\x1b[0m";
exports.CYAN="\x1b[36m%s\x1b[0m";
exportconstRED:string="\x1b[31m%s\x1b[0m";
exportconstGREEN:string="\x1b[32m%s\x1b[0m";
exportconstYELLOW:string="\x1b[33m%s\x1b[0m";
exportconstMAGENTA:string="\x1b[34m%s\x1b[0m";
exportconstCYAN:string="\x1b[36m%s\x1b[0m";
"usestrict";
exports.__esModule=true;
exports.WISE_NORTH_EAST=exports.WISE_NORTH=exports.WISE_NORTH_WEST=exports.WISE_WEST=exports.WISE_SOUTH_WEST=exports.WISE_SOUTH=exports.WISE_SOUTH_EAST=exports.WISE_EAST=exports.NORTH_EAST=exports.NORTH=exports.NORTH_WEST=exports.WEST=exports.SOUTH_WEST=exports.SOUTH=exports.SOUTH_EAST=exports.EAST=void0;
exports.EAST="E";
exports.SOUTH_EAST="SE";
exports.SOUTH="S";
exports.SOUTH_WEST="SW";
exports.WEST="W";
exports.NORTH_WEST="NW";
exports.NORTH="N";
exports.NORTH_EAST="NE";
exports.WISE_EAST="WiseE";
exports.WISE_SOUTH_EAST="WiseSE";
exports.WISE_SOUTH="WiseS";
exports.WISE_SOUTH_WEST="WiseSW";
exports.WISE_WEST="WiseW";
exports.WISE_NORTH_WEST="WiseNW";
exports.WISE_NORTH="WiseN";
exports.WISE_NORTH_EAST="WiseNE";
exportconstEAST="E";
exportconstSOUTH_EAST="SE";
exportconstSOUTH="S";
exportconstSOUTH_WEST="SW";
exportconstWEST="W";
exportconstNORTH_WEST="NW";
exportconstNORTH="N";
exportconstNORTH_EAST="NE";
exportconstWISE_EAST="WiseE";
exportconstWISE_SOUTH_EAST="WiseSE";
exportconstWISE_SOUTH="WiseS";
exportconstWISE_SOUTH_WEST="WiseSW";
exportconstWISE_WEST="WiseW";
exportconstWISE_NORTH_WEST="WiseNW";
exportconstWISE_NORTH="WiseN";
exportconstWISE_NORTH_EAST="WiseNE";
"usestrict";
exports.__esModule=true;
exports.CIRCLE=exports.ROUNDED_RECTANGLE=exports.RECTANGLE=void0;
exports.RECTANGLE="rectangle";
exports.ROUNDED_RECTANGLE="rounded-rectangle";
exports.CIRCLE="circle";
exportconstRECTANGLE:string="rectangle";
exportconstROUNDED_RECTANGLE:string="rounded-rectangle";
exportconstCIRCLE:string="circle";
"usestrict";
exports.__esModule=true;
exports.HEXMAP=exports.FOCUS=void0;
exports.FOCUS="focus";
exports.HEXMAP="hexmap";
exportconstFOCUS:string="focus";
exportconstHEXMAP:string="hexmap";
"usestrict";
exports.__esModule=true;
exports.PASTURE=exports.FANG_SWAMP=exports.GEORGIA=exports.GALLBLADDER=void0;
exports.GALLBLADDER="00000.gallbladder";
exports.GEORGIA="00001.georgia";
exports.FANG_SWAMP="00002.fang-swamp";
exports.PASTURE="00003.pasture";
exportconstGALLBLADDER:string="00000.gallbladder";
exportconstGEORGIA:string="00001.georgia";
exportconstFANG_SWAMP:string="00002.fang-swamp";
exportconstPASTURE:string="00003.pasture";
"usestrict";
exports.__esModule=true;
exports.MAGENTA=exports.YELLOW=exports.BLUE=exports.GREEN=exports.RED=exports.CYAN=exports.CLEAN=exports.MENU_SINGLE=exports.TIMELINE=exports.SPACE=void0;
exports.SPACE="space";
exports.TIMELINE="timeline";
exports.MENU_SINGLE="menu_single";
exports.CLEAN="clean";
exports.CYAN="cyan";
exports.RED="red";
exports.GREEN="green";
exports.BLUE="blue";
exports.YELLOW="yellow";
exports.MAGENTA="magenta";
exportconstSPACE:string="space";
exportconstTIMELINE:string="timeline";
exportconstMENU_SINGLE:string="menu_single";
exportconstCLEAN:string="clean";
exportconstCYAN:string="cyan";
exportconstRED:string="red";
exportconstGREEN:string="green";
exportconstBLUE:string="blue";
exportconstYELLOW:string="yellow";
exportconstMAGENTA:string="magenta";
"usestrict";
exports.__esModule=true;
exports.LOOP=exports.VIDEO=exports.HEXAGON=exports.SPRITE=exports.TEXT=exports.GRAPHIC=exports.CONTAINER=exports.SURFACE=exports.VISAGE=void0;
exports.VISAGE="visage";
exports.SURFACE="surface";
exports.CONTAINER="container";
exports.GRAPHIC="graphic";
exports.TEXT="text";
exports.SPRITE="sprite";
exports.HEXAGON="hexagon";
exports.VIDEO="video";
exports.LOOP="loop";
exportconstVISAGE:string="visage";
exportconstSURFACE:string="surface";
exportconstCONTAINER:string="container";
exportconstGRAPHIC:string="graphic";
exportconstTEXT:string="text";
exportconstSPRITE:string="sprite";
exportconstHEXAGON:string="hexagon";
exportconstVIDEO:string="video";
exportconstLOOP:string="loop";
"usestrict";
exports.__esModule=true;
exports.MOUNT_WIDTH=exports.MOUNT_HEIGHT=exports.MOUNT_PART=exports.MOUNT_FULL=exports.SCREEN=void0;
exports.SCREEN="screen-visage";
exports.MOUNT_FULL="mount-visage-full";
exports.MOUNT_PART="mount-visage-part";
exports.MOUNT_HEIGHT="mount-visage-height";
exports.MOUNT_WIDTH="mount-visage-width";
exportconstSCREEN:string="screen-visage";
exportconstMOUNT_FULL:string="mount-visage-full";
exportconstMOUNT_PART:string="mount-visage-part";
exportconstMOUNT_HEIGHT:string="mount-visage-height";
exportconstMOUNT_WIDTH:string="mount-visage-width";
import{PixelModel}from"../pixel.model";
importPixelBitfrom"../fce/pixel.bit";
importStatefrom"../../99.core/state";
import*asActCnsfrom"../../act/console.action";
import*asActPxlfrom"../../00.pixel.unit/pixel.action";
import*asActColfrom"../../97.collect.unit/collect.action";
import*asActBusfrom"../../99.bus.unit/bus.action";
import*asActVrtfrom"../../act/vurt.action";
import*asActDskfrom"../../act/disk.action";
import*asActPvtfrom"../../act/pivot.action";
import*asActClrfrom"../../act/color.action";
import*asActLgtfrom"../../act/light.action";
import{ColorModel}from"400.pixel/01.color.unit/color.model";
import*asSfrom'string'
varbit,val,idx,dex,lst,dat,src;
exportconstinitPixel=async(cpy:PixelModel,bal:PixelBit,ste:State)=>{
bal.slv({intBit:{idx:"init-pixel"}});
exportconstupdatePixel=(cpy:PixelModel,bal:PixelBit,ste:State)=>{
exportconstopenPixel=(cpy:PixelModel,bal:PixelBit,ste:State)=>{
varcolorRead=function(png,x,y){
vardata=[];
varidx=(png.width*y+x)<<2;
returndata;
varupdate=function(){
vardata=[];
returndata;
exportconstprocessPixel=(cpy:PixelModel,bal:PixelBit,ste:State)=>{
varconvert=require("color-convert");
constdata=bal.dat;
varsource=data;
varwidth=source.width;
varheight=source.height;
varpixels=0;
varcolors={};
varcolorList=[];
varpixelList=[];
varcount;
for(vary=0;y<height;y++){
count=y;
for(varx=0;x<width;x++){
varnow=colorRead(source,x,y);
pixels+=1;
varid=convert.rgb.hex(now[0],now[1],now[2]);
varmarling={x,y,hex:id,r:now[0],g:now[1],b:now[2]};
pixelList.push(marling);
if(colors[id]!=null){
colors[id].push([x,y,now[3]]);
colors[id]=[];
colorList.push(now);
pixelList;
if(bal.slv!=null)
bal.slv({pixBit:{idx:"process-pixel",lst:pixelList,dat:colors}});
exportconstcolorPixel=async(
cpy:PixelModel,
bal:PixelBit,
ste:State
)=>{
varlst=bal.lst;
vardex=bal.lst.length-1;
varfin=[];
varnext=async()=>{
if(dex<=0){
fin;
debugger;
bal.slv({pixBit:{idx:"color-pixel",lst:fin}});
return;
varitm=lst[dex];
dex-=1;
varbit=awaitwindow["electronAPI"].readColor("#"+itm.hex);
varnowBit=JSON.parse(bit);
varnowDat=nowBit.clrBit.dat;
varmarling={
x:itm.x,
y:itm.y,
hex:nowDat.hex,
r:nowDat.r,
g:nowDat.g,
b:nowDat.b,
if(dex%10000==3)
fin.push(marling);
next();
next();
exportconstbuildPixel=async(
cpy:PixelModel,
bal:PixelBit,
ste:State
)=>{
varroot="./color/";
bit=awaitste.bus(ActDsk.READ_DISK,{src:bal.src});
dat=bit.dskBit.dat;
dat=JSON.parse(dat);
bit=awaitste.hunt(ActClr.OPEN_COLOR,{dat});
varcolorDat=bit.clrBit.dat;
bit=awaitste.hunt(ActLgt.READ_LIGHT,{val:0});
varwall0=bit.lgtBit;
bit=awaitste.hunt(ActLgt.READ_LIGHT,{val:1});
varwall1=bit.lgtBit;
varcolorList=[];
for(varkeyincolorDat){
varitm=colorDat[key].substring(1);
colorList.push(itm);
vardex=colorList.length-1;
colorList;
varoutput=[];
varnext=async()=>{
if(dex<0){
output;
output.forEach(async(a)=>{
vardir=root+a.flv+"/"+a.src+".png";
varnowClr=a.hex;
if(nowClr==null&&a.idx!=null)nowClr=a.idx;
bit=awaitste.bus(ActDsk.SWATCH_DISK,{idx:nowClr,src:dir});
if(bal.slv!=null)
bal.slv({pixBit:{idx:"build-pixel",lst:output}});
return;
varidx=colorList[dex];
dex-=1;
bit=awaitste.hunt(ActClr.READ_COLOR,{idx,val:1});
varcolorDat=bit.clrBit.dat;
output.push(colorDat);
next();
next();
varpatch=(ste,type,bale)=>ste.dispatch({type,bale});
exportconstreadPixel=async(cpy:PixelModel,bal:PixelBit,ste:State)=>{
varconvert=require("color-convert");
varPNG=require("pngjs").PNG;
varFS=require("fs-extra");
varr,g,b;
varhex;
bal.src;
varoutputList=[];
varoutputData={};
bal.src;
if(bal.val==null)bal.val=0;
if(bal.src==null)bal.src='./data/color-list/000.color.name.json'
varFS=require("fs-extra");
dat=FS.readJsonSync(bal.src);
bit=awaitste.hunt(ActClr.OPEN_COLOR,{dat});
if(bal.val==1){
varwant={}
for(varkeyinbit.clrBit.dat){
varhole=S(key).slugify().s
if(want[hole]!=null)continue
want[hole]=bit.clrBit.dat[key];
varneed=want[bal.idx]
if(need==null){
need='#00FF00'
bit=awaitste.hunt(ActClr.READ_COLOR,{idx:need});
bal.slv({pxlBit:{idx:"read-pixel",dat:bit.clrBit.dat.bit}});
return
varclrMod:ColorModel=ste.value.color;
bal.idx;
varstream;
varwidth;
varheight;
varlocation=0;
FS.createReadStream(bal.idx)
.pipe(
newPNG({
filterType:4,
.on("parsed",function(){
for(vary=0;y<this.height;y++){
for(varx=0;x<this.width;x++){
varidx=(this.width*y+x)<<2;
r=this.data[idx];
g=this.data[idx+1];
b=this.data[idx+2];
hex=convert.rgb.hex([r,g,b]);
varclr=clrMod.completeList(hex);
varname=clr.name;
if(outputData[name]==null)outputList.push(clr);
if(outputData[name]==null)outputData[name]=clr;
dat={x,y,r,g,b,hex,name};
this.data[idx]=clr.rgb.r;
this.data[idx+1]=clr.rgb.g;
this.data[idx+2]=clr.rgb.b;
this.pack().pipe(FS.createWriteStream("./data/index.png"));
for(varkeyinoutputData[key]){
varpal=outputData[key];
debugger;
FS.writeJsonSync("./data/index.json",outputList);
bal.slv({pxlBit:{idx:"read-pixel",lst:outputList}});
exportconstwritePixel=(cpy:PixelModel,bal:PixelBit,ste:State)=>{
bal.slv({pxlBit:{idx:"write-pixel"}});
exportconstpalettePixel=async(
cpy:PixelModel,
bal:PixelBit,
ste:State
)=>{
varconvert=require("color-convert");
varPNG=require("pngjs").PNG;
varFS=require("fs-extra");
varr,g,b;
varhex;
varnow=bal.src+"/index.json";
bit=awaitste.bus(ActDsk.READ_DISK,{src:now});
lst=JSON.parse(bit.dskBit.dat);
vardata={};
lst.forEach((a)=>{
varidx=a.name;
data[idx]=a.value;
data;
varnear=require("nearest-color").from(data);
varout="./data/fin.png";
if(bal.val!=null)out=bal.val;
bal.idx
FS.createReadStream(bal.idx)
.pipe(
newPNG({
filterType:4,
.on("parsed",function(){
for(vary=0;y<this.height;y++){
for(varx=0;x<this.width;x++){
varidx=(this.width*y+x)<<2;
r=this.data[idx];
g=this.data[idx+1];
b=this.data[idx+2];
hex=convert.rgb.hex([r,g,b]);
varclr=near(hex);
this.data[idx]=clr.rgb.r;
this.data[idx+1]=clr.rgb.g;
this.data[idx+2]=clr.rgb.b;
if(cpy.chroma!=null){
cpy.chroma.forEach((a)=>{
if(clr.rgb.r==a.rgb.r&&clr.rgb.g==a.rgb.g&&clr.rgb.b==a.rgb.b){
this.data[idx+3]=0;
if(clr.rgb.r==0&&clr.rgb.g==255&&clr.rgb.b==0){
this.data[idx+3]=0;
this.pack().pipe(FS.createWriteStream(out));
bal.slv({palBit:{idx:"palette-pixel"}});
exportconstbatchPixel=async(cpy:PixelModel,bal:PixelBit,ste:State)=>{
varFS=require("fs-extra");
if(bal.lst==null)bal.lst=[]
vardex=0;
FS.emptyDirSync('./output')
varnext=async()=>{
if(dex>=bal.lst.length-1){
bal.slv({palBit:{idx:"batch-pixel"}});
return
dex+=1
idx=bal.lst[dex]
constpath=require('path');
constfileName='./output/'+path.basename(idx);
varinside=idx
varoutside=bal.src
bit=awaitste.hunt(ActPxl.PALETTE_PIXEL,{idx,src:bal.src,val:fileName})
awaitnext()
awaitnext()
exportconstchromaPixel=async(cpy:PixelModel,bal:PixelBit,ste:State)=>{
bit=awaitste.bus(ActDsk.READ_DISK,{src:'./palette/chroma-key-green/index.json'});
vardat=JSON.parse(bit.dskBit.dat)
cpy.chroma=dat;
bal.slv({pxlBit:{idx:"chroma-pixel"}});
exportconstframePixel=async(cpy:PixelModel,bal:PixelBit,ste:State)=>{
constfs=require("fs");
varffmpegPath="./bin/ffmpeg.exe";
constvideoFile="data/000.mp4";
constoutputDir="./frames";
varFS=require('fs-extra')
FS.emptyDirSync(outputDir)
if(!fs.existsSync(outputDir)){
fs.mkdirSync(outputDir);
exportconstsortPixel=async(cpy:PixelModel,bal:PixelBit,ste:State)=>{
varFS=require('fs-extra')
FS.emptyDirSync('./output')
varlist=FS.readdirSync('./frames')
list.forEach((a,b)=>{
vardex=String(b).padStart(3,"0")
varend=a.split('.').pop()
varinput='./frames/'+a;
varoutput='./output/'+dex+'.'+end;
FS.copySync(input,output)
bal.slv({palBit:{idx:"sort-pixel"}});
exportconsttestPixel=(cpy:PixelModel,bal:PixelBit,ste:State)=>{
bal.slv({palBit:{idx:"test-pixel"}});
exportdefaultinterfacePixelBit{
idx:string;
src?:string;
val?:any;
dat?:any;
slv?:Function;
bit?:any;
lst?:any[];
importPixelBitfrom"./pixel.bit";
exportdefaultinterfacePixel{
import{Action}from"../99.core/interface/action.interface";
importPixelBitfrom"./fce/pixel.bit";
exportconstINIT_PIXEL="[Pixelaction]InitPixel";
exportclassInitPixelimplementsAction{
readonlytype=INIT_PIXEL;
constructor(publicbale:PixelBit){}
exportconstUPDATE_PIXEL="[Pixelaction]UpdatePixel";
exportclassUpdatePixelimplementsAction{
readonlytype=UPDATE_PIXEL;
constructor(publicbale:PixelBit){}
exportconstOPEN_PIXEL="[Openaction]OpenPixel";
exportclassOpenPixelimplementsAction{
readonlytype=OPEN_PIXEL;
constructor(publicbale:PixelBit){}
exportconstPROCESS_PIXEL="[Processaction]ProcessPixel";
exportclassProcessPixelimplementsAction{
readonlytype=PROCESS_PIXEL;
constructor(publicbale:PixelBit){}
exportconstCOLOR_PIXEL="[Coloraction]ColorPixel";
exportclassColorPixelimplementsAction{
readonlytype=COLOR_PIXEL;
constructor(publicbale:PixelBit){}
exportconstBUILD_PIXEL="[Buildaction]BuildPixel";
exportclassBuildPixelimplementsAction{
readonlytype=BUILD_PIXEL;
constructor(publicbale:PixelBit){}
exportconstWRITE_PIXEL="[Writeaction]WritePixel";
exportclassWritePixelimplementsAction{
readonlytype=WRITE_PIXEL;
constructor(publicbale:PixelBit){}
exportconstREAD_PIXEL="[Readaction]ReadPixel";
exportclassReadPixelimplementsAction{
readonlytype=READ_PIXEL;
constructor(publicbale:PixelBit){}
exportconstPALETTE_PIXEL="[Readaction]PalettePixel";
exportclassPalettePixelimplementsAction{
readonlytype=PALETTE_PIXEL;
constructor(publicbale:PixelBit){}
exportconstBATCH_PIXEL="[Batchaction]BatchPixel";
exportclassBatchPixelimplementsAction{
readonlytype=BATCH_PIXEL;
constructor(publicbale:PixelBit){}
exportconstFRAME_PIXEL="[Frameaction]FramePixel";
exportclassFramePixelimplementsAction{
readonlytype=FRAME_PIXEL;
constructor(publicbale:PixelBit){}
exportconstCHROMA_PIXEL="[Chromaaction]ChromaPixel";
exportclassChromaPixelimplementsAction{
readonlytype=CHROMA_PIXEL;
constructor(publicbale:PixelBit){}
exportconstSORT_PIXEL="[Chromaaction]SortPixel";
exportclassSortPixelimplementsAction{
readonlytype=SORT_PIXEL;
constructor(publicbale:PixelBit){}
exportconstTEST_PIXEL="[Testaction]TestPixel";
exportclassTestPixelimplementsAction{
readonlytype=TEST_PIXEL;
constructor(publicbale:PixelBit){}
exporttypeActions=|InitPixel|UpdatePixel
|OpenPixel
|ProcessPixel
|ColorPixel
|BuildPixel
|WritePixel
|ReadPixel
|PalettePixel
|BatchPixel
|FramePixel
|ChromaPixel
|SortPixel
|TestPixel
export{initPixel}from"./buz/pixel.buzz";
export{updatePixel}from"./buz/pixel.buzz";
export{openPixel}from"./buz/pixel.buzz";
export{processPixel}from"./buz/pixel.buzz";
export{colorPixel}from"./buz/pixel.buzz";
export{buildPixel}from"./buz/pixel.buzz";
export{writePixel}from"./buz/pixel.buzz";
export{readPixel}from"./buz/pixel.buzz";
export{palettePixel}from"./buz/pixel.buzz";
export{batchPixel}from"./buz/pixel.buzz";
export{framePixel}from"./buz/pixel.buzz";
export{chromaPixel}from"./buz/pixel.buzz";
export{sortPixel}from"./buz/pixel.buzz";
export{testPixel}from"./buz/pixel.buzz";
importPixelfrom"./fce/pixel.interface";
importPixelBitfrom"./fce/pixel.interface";
exportclassPixelModelimplementsPixel{
idx:string='400.pixel';
chroma:any;
import*asclonefrom"clone-deep";
import*asActfrom"./pixel.action";
import{PixelModel}from"./pixel.model";
import*asBuzzfrom"./pixel.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:PixelModel=newPixelModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.UPDATE_PIXEL:
returnBuzz.updatePixel(clone(model),act.bale,state);
caseAct.INIT_PIXEL:
returnBuzz.initPixel(clone(model),act.bale,state);
caseAct.SORT_PIXEL:
returnBuzz.sortPixel(clone(model),act.bale,state);
caseAct.OPEN_PIXEL:
returnBuzz.openPixel(clone(model),act.bale,state);
caseAct.PROCESS_PIXEL:
returnBuzz.processPixel(clone(model),act.bale,state);
caseAct.COLOR_PIXEL:
returnBuzz.colorPixel(clone(model),act.bale,state);
caseAct.BUILD_PIXEL:
returnBuzz.buildPixel(clone(model),act.bale,state);
caseAct.WRITE_PIXEL:
returnBuzz.writePixel(clone(model),act.bale,state);
caseAct.READ_PIXEL:
returnBuzz.readPixel(clone(model),act.bale,state);
caseAct.PALETTE_PIXEL:
returnBuzz.palettePixel(clone(model),act.bale,state);
caseAct.BATCH_PIXEL:
returnBuzz.batchPixel(clone(model),act.bale,state);
caseAct.FRAME_PIXEL:
returnBuzz.framePixel(clone(model),act.bale,state);
caseAct.CHROMA_PIXEL:
returnBuzz.chromaPixel(clone(model),act.bale,state);
caseAct.TEST_PIXEL:
returnBuzz.testPixel(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassPixelUnit{
constructor(state:State){
global.PIXEL=require("../dist/400.pixel/hunt");
global.PIXEL.ActPxl=require("../dist/400.pixel/00.pixel.unit/pixel.action");
import*asColorfrom"color";
import{ColorModel}from"../color.model";
importColorBitfrom"../fce/color.bit";
importStatefrom"../../99.core/state";
importconvert=require("color-convert");
import*asSfrom'string'
importHueBitfrom"../fce/hue.bit";
import*asActClrfrom"../../01.color.unit/color.action";
import*asActColfrom"../../97.collect.unit/collect.action";
import*asActBusfrom"../../99.bus.unit/bus.action";
import*asActVrtfrom"../../act/vurt.action"
import*asActDskfrom"../../act/disk.action"
varbit,dat;
varnear,near0
exportconstinitColor=(cpy:ColorModel,bal:ColorBit,ste:State)=>{
debugger
exportconstfetchColor=async(cpy:ColorModel,bal:ColorBit,ste:State)=>{
if(!response.ok){
thrownewError('Networkresponsewasnotok');
vardat=awaitresponse.json();
bal.slv({clrBit:{idx:"fetch-color",val:dat.length,dat:dat}});
exportconstopenColor=async(cpy:ColorModel,bal:ColorBit,ste:State)=>{
varbit=ste.hunt(ActClr.FATE_COLOR,{})
debugger
vardata={}
varmodClr=ste.value.light;
varlist=bal.dat;
list.forEach((a)=>{
varidx=a.name.toLowerCase();
data[idx]=a.hex;
data
near=require("nearest-color").from(data);
cpy.boundaryList=require("nearest-color").from(cpy.boundaryData);
cpy.colorData=data;
cpy.colorList=list
cpy.completeList=near
if(bal.slv!=null)
bal.slv({clrBit:{idx:"open-color",dat:cpy.colorData}});
exportconstcreateColor=(cpy:ColorModel,bal:ColorBit,ste:State)=>{
vardat:HueBit={idx:bal.idx,src:bal.src,bit:null,dat:null};
for(varkeyinbal.dat){
dat[key]=bal.dat[key]
vardata={}
if(bal.dat==null){
bal.dat={}
bal.dat.lst=cpy.boundaryData;
if(bal.dat!=null){
varitm=cpy.boundaryList(bal.idx)
dat['flv']=itm.name;
cpy.colorData
varitm2=near(bal.idx)
dat.src=S(itm2.name).slugify().s
dat.bit=itm2
if(bal.slv!=null)returnbal.slv({clrBit:{idx:"create-color",dat}});
exportconstupdateColor=async(cpy:ColorModel,bal:ColorBit,ste:State)=>{
bit=awaitste.hunt(ActClr.READ_COLOR,{idx:bal.idx})
dat=bit.clrBit.dat
bal.src;
varitm=dat.bit(bal.src)
varnow=cpy.boundaryList(bal.src)
debugger
itm.flavor=now.name
if(bal.slv!=null)returnbal.slv({clrBit:{idx:"update-container",dat:itm}});
exportconstreadColor=async(cpy:ColorModel,bal:ColorBit,ste:State)=>{
varslv=bal.slv;
if(bal.idx==null)bal.idx='clr00';
bit=awaitste.hunt(ActCol.READ_COLLECT,{idx:bal.idx,bit:ActClr.CREATE_COLOR})
if(bal.src!=null){
if(Array.from(bal.src)[0]!='#')bal.src='#'+bal.src;
bit=awaitste.hunt(ActClr.UPDATE_COLOR,{idx:bal.idx,src:bal.src})
varcolorDat=bit.clrBit.dat
bit=colorDat
}elsebit=bit.clcBit.dat;
if(slv!=null)slv({clrBit:{idx:"read-color",dat:bit}});
exportconstwriteColor=async(cpy:ColorModel,bal:ColorBit,ste:State)=>{
bit=awaitste.hunt(ActCol.WRITE_COLLECT,{idx:bal.idx,src:bal.src,dat:bal.dat,bit:ActClr.CREATE_COLOR})
if(bal.src!=null){
if(Array.from(bal.src)[0]!='#')bal.src='#'+bal.src;
bit=awaitste.hunt(ActClr.UPDATE_COLOR,{idx:bal.idx,src:bal.src})
varcolorDat=bit.clrBit.dat
bit=colorDat
}elsebit=bit.clcBit.dat;
if(bal.slv!=null)bal.slv({clrBit:{idx:"write-color",dat:bit}});
exportconstremoveColor=(cpy:ColorModel,bal:ColorBit,ste:State)=>{
debugger
exportconstdeleteColor=(cpy:ColorModel,bal:ColorBit,ste:State)=>{
debugger
exportconstmixColor=async(cpy:ColorModel,bal:ColorBit,ste:State)=>{
varlst=bal.dat.lst;
varval=bal.dat.val;
if(val==null)val=0.5;
dat=bit.clrBit.dat;
if(bal.slv!=null)bal.slv({clrBit:{idx:"mix-color",dat}});
exportconstfateColor=(cpy:ColorModel,bal:ColorBit,ste:State)=>{
debugger
exportconstswatchColor=async(cpy:ColorModel,bal:ColorBit,ste:State)=>{
bit=awaitste.hunt(ActClr.WRITE_COLOR,{idx:'swatch-color',dat:{lst:bal.dat.lst}})
varlist=bit.clrBit.dat.lst
vardata
vardex=list.length-1;
varoutput=[]
varnow=async()=>{
varitm=list[dex]
if(dex<=0){
bal.slv({clrBit:{idx:"swatch-color",dat:{lst:output}}});
return
varmixHex=itm.hex
bit=awaitste.hunt(ActClr.READ_COLOR,{idx:'swatch-color',src:mixHex})
varpow=bit.clrBit
output.push(pow)
dex-=1;
awaitnow()
awaitnow()
cpy.colorData=data;
exportconstpaletteColor=(cpy:ColorModel,bal:ColorBit,ste:State)=>{
debugger
import{Action}from"../99.core/interface/action.interface";
importColorBitfrom"./fce/color.bit";
exportconstINIT_COLOR="[Coloraction]InitColor";
exportclassInitColorimplementsAction{
readonlytype=INIT_COLOR;
constructor(publicbale:ColorBit){}
exportconstUPDATE_COLOR="[Coloraction]UpdateColor";
exportclassUpdateColorimplementsAction{
readonlytype=UPDATE_COLOR;
constructor(publicbale:ColorBit){}
exportconstOPEN_COLOR="[Openaction]OpenColor";
exportclassOpenColorimplementsAction{
readonlytype=OPEN_COLOR;
constructor(publicbale:ColorBit){}
exportconstREAD_COLOR="[Readaction]ReadColor";
exportclassReadColorimplementsAction{
readonlytype=READ_COLOR;
constructor(publicbale:ColorBit){}
exportconstWRITE_COLOR="[Writeaction]WriteColor";
exportclassWriteColorimplementsAction{
readonlytype=WRITE_COLOR;
constructor(publicbale:ColorBit){}
exportconstREMOVE_COLOR="[Removeaction]RemoveColor";
exportclassRemoveColorimplementsAction{
readonlytype=REMOVE_COLOR;
constructor(publicbale:ColorBit){}
exportconstDELETE_COLOR="[Deleteaction]DeleteColor";
exportclassDeleteColorimplementsAction{
readonlytype=DELETE_COLOR;
constructor(publicbale:ColorBit){}
exportconstCREATE_COLOR="[Createaction]CreateColor";
exportclassCreateColorimplementsAction{
readonlytype=CREATE_COLOR;
constructor(publicbale:ColorBit){}
exportconstMIX_COLOR="[Mixaction]MixColor";
exportclassMixColorimplementsAction{
readonlytype=MIX_COLOR;
constructor(publicbale:ColorBit){}
exportconstFATE_COLOR="[Fateaction]FateColor";
exportclassFateColorimplementsAction{
readonlytype=FATE_COLOR;
constructor(publicbale:ColorBit){}
exportconstSWATCH_COLOR="[Swatchaction]SwatchColor";
exportclassSwatchColorimplementsAction{
readonlytype=SWATCH_COLOR;
constructor(publicbale:ColorBit){}
exportconstPALETTE_COLOR="[Paletteaction]PaletteColor";
exportclassPaletteColorimplementsAction{
readonlytype=PALETTE_COLOR;
constructor(publicbale:ColorBit){}
exportconstFETCH_COLOR="[Fetchaction]FetchColor";
exportclassFetchColorimplementsAction{
readonlytype=FETCH_COLOR;
constructor(publicbale:ColorBit){}
exporttypeActions=|InitColor|UpdateColor
|OpenColor
|ReadColor
|WriteColor
|RemoveColor
|DeleteColor
|CreateColor
|MixColor
|FateColor
|SwatchColor
|PaletteColor
|FetchColor
export{initColor}from"./buz/color.buzz";
export{updateColor}from"./buz/color.buzz";
export{openColor}from"./buz/color.buzz";
export{readColor}from"./buz/color.buzz";
export{writeColor}from"./buz/color.buzz";
export{removeColor}from"./buz/color.buzz";
export{deleteColor}from"./buz/color.buzz";
export{createColor}from"./buz/color.buzz";
export{mixColor}from"./buz/color.buzz";
export{fateColor}from"./buz/color.buzz";
export{swatchColor}from"./buz/color.buzz";
export{paletteColor}from"./buz/color.buzz";
export{fetchColor}from"./buz/color.buzz";
importColorfrom"./fce/color.interface";
importColorBitfrom"./fce/color.interface";
exportclassColorModelimplementsColor{
colorData:any;
colorList:any;
boundaryList:any;
completeList:any;
boundaryTitle={
"white":{idx:"00.AL.achromatic-snow",src:'white'},
"red":{idx:"01.AB.achromatic-blood",src:'red'},
"green":{idx:"02.CV.chromatic-virid",src:'green'},
"blue":{idx:"03.CM.chromatic-marine",src:'blue'},
"yello":{idx:"04.CS.chromatic-straw",src:'yello'},
"black":{idx:"05.CI.chromatic-ink",src:'black'},
"purple":{idx:"06.CN.chromatic-nobel",src:'purple'},
"orange":{idx:"07.CA.chromatic-amber",src:'orange'},
"pink":{idx:"08.CP.chromatic-peach",src:'pink'},
"brown":{idx:"09.CC.chromatic-coffee",src:'brown'},
"glop00":{idx:"10.AA.asymmetrical-achromatic",src:'glob00'},
"glop01":{idx:"11.BA.bootlegged-achromatic",src:'glop01'},
"glop02":{idx:"12.CA.criminal-achromatic",src:'glop02'},
"glop03":{idx:"13.DA.defunct-achromatic",src:'glop03'},
"glop04":{idx:"14.EA.execrable-achromatic",src:'glop04'},
"glop05":{idx:"15.FAfallacious-achromatic",src:'glop05'},
"glop06":{idx:"16.GA.grotesque-achromatic",src:'glop06'},
"glop07":{idx:"17.HA.horrible-achromatic",src:'glop07'},
"glop08":{idx:"18.IA.irrational-achromatic",src:'glop08'},
"glop09":{idx:"19.JA.jejune-achromatic",src:'glop09'},
"glop10":{idx:"20.KA.kleptomanical-achromatic",src:'glop10'},
"glop11":{idx:"21.LA.loathsome-achromatic",src:'glop11'},
"glop12":{idx:"22.MA.mordant-achromatic",src:'glop12'},
"glop13":{idx:"23.NA.nasty-achromatic",src:'glop13'},
"glop14":{idx:"24.OA.odious-achromatic",src:'glop14'},
"glop15":{idx:"25.PA.profane-achromatic",src:'glop15'},
"glop16":{idx:"26.QA.quixotic-achromatic",src:'glop16'},
"glop17":{idx:"27.RA.rapacious-achromatic",src:'glop17'},
"glop18":{idx:"29.SA.slanderous-achromatic",src:'glop18'},
"glop19":{idx:"29.TA.tyrannical-achromatic",src:'glop19'},
"glop20":{idx:"30.UA.unborn-achromatic",src:'glop20'},
"glop21":{idx:"31.VA.vehement-achromatic",src:'glop21'},
"glop22":{idx:"32.WA.worthless-achromatic",src:'glop22'},
"glop23":{idx:"33.XA.xenophobic-achromatic",src:'glop23'},
"glop24":{idx:"34.YA.yucky-achromatic",src:'glop24'},
"glop25":{idx:"34.ZA.zeronic-achromatic",src:'glop25'}
boundaryData={
black:"#000000",
white:"#ffffff",
blue:"#0000FF",
green:"#00FF00",
yello:"#FFFF00",
red:"#FF0000",
purple:"#800080",
orange:"#FFA500",
brown:"#964B00",
pink:"#ffc0cb",
glop00:"#f5f5dc",
glop01:"#4a0404",
glop02:"#6082B6",
glop03:"#93934a",
glop04:"#32cd32",
glop05:"#c6b836",
glop06:"#8A9A5B",
glop07:"#7393B3",
glop08:"#FF00FF",
glop09:"#838383",
glop10:"#e1ad01",
glop11:"#A9A9A9",
glop12:"#375915",
glop13:"#a0bf16",
glop14:"#B2BEB5",
glop15:"#708090",
glop16:"#b8bc86",
glop17:"#899499",
glop18:"#899499",
glop19:"#818589",
glop20:"#848884",
glop21:"#71797E",
glop22:"#899499",
glop23:"#654321",
glop24:"#808080",
glop25:"#36454F"
import*asclonefrom"clone-deep";
import*asActfrom"./color.action";
import{ColorModel}from"./color.model";
import*asBuzzfrom"./color.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:ColorModel=newColorModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.UPDATE_COLOR:
returnBuzz.updateColor(clone(model),act.bale,state);
caseAct.INIT_COLOR:
returnBuzz.initColor(clone(model),act.bale,state);
caseAct.OPEN_COLOR:
returnBuzz.openColor(clone(model),act.bale,state);
caseAct.READ_COLOR:
returnBuzz.readColor(clone(model),act.bale,state);
caseAct.WRITE_COLOR:
returnBuzz.writeColor(clone(model),act.bale,state);
caseAct.REMOVE_COLOR:
returnBuzz.removeColor(clone(model),act.bale,state);
caseAct.DELETE_COLOR:
returnBuzz.deleteColor(clone(model),act.bale,state);
caseAct.CREATE_COLOR:
returnBuzz.createColor(clone(model),act.bale,state);
caseAct.MIX_COLOR:
returnBuzz.mixColor(clone(model),act.bale,state);
caseAct.FATE_COLOR:
returnBuzz.fateColor(clone(model),act.bale,state);
caseAct.SWATCH_COLOR:
returnBuzz.swatchColor(clone(model),act.bale,state);
caseAct.PALETTE_COLOR:
returnBuzz.paletteColor(clone(model),act.bale,state);
caseAct.FETCH_COLOR:
returnBuzz.fetchColor(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassColorUnit{
constructor(state:State){
exportdefaultinterfaceColorBit{
idx:string;
src?:string;
val?:number;
dat?:any;
slv?:Function;
bit?:any;
lst?:any[];
importColorBitfrom"./color.bit";
exportdefaultinterfaceColor{
exportdefaultinterfaceHueBit{
idx:string;
src?:string;
val?:number;
dat?:any;
bit?:any;
lst?:any[];
import*asActClrfrom"../../01.color.unit/color.action";
import*asActLgtfrom"../../02.light.unit/light.action";
import*asActColfrom"../../97.collect.unit/collect.action";
import*asActBusfrom"../../99.bus.unit/bus.action";
import*asActVrtfrom"../../act/vurt.action"
import*asActDskfrom"../../act/disk.action"
import*asActPvtfrom"../../act/pivot.action"
import*asclonefrom"clone-deep";
varbit,val,idx,dex,lst,dat,src;
exportconstinitLight=async(cpy:LightModel,bal:LightBit,ste:State)=>{
if(bal.dat!=null)bit=awaitste.hunt(ActBus.INIT_BUS,{idx:cpy.idx,lst:[ActLgt,ActClr],dat:bal.dat,src:bal.src})
if(bal.slv!=null)bal.slv({intBit:{idx:"init-space"}});
varChance=require('chance');
cpy.fate=newChance(9211925);
exportconstreadLight=(cpy:LightModel,bal:LightBit,ste:State)=>{
if(bal.val==null)bal.val=0
switch(bal.val){
case0:
dat=clone(cpy.boundaryData)
break
case1:
dat=clone(cpy.boundaryTitle)
break
if(bal.slv!=null)bal.slv({lgtBit:{idx:"read-light",dat}});
exportconstupdateLight=async(cpy:LightModel,bal:LightBit,ste:State)=>{
bit=awaitste.bus(ActPvt.UPDATE_PIVOT,{src:'003.light'})
if(bal.slv!=null)bal.slv({lgtBit:{idx:"udpate-light",dat:{}}});
exportconstsourceLight=(cpy:LightModel,bal:LightBit,ste:State)=>{
debugger
varpatch=(ste,type,bale)=>ste.dispatch({type,bale});
import{LightModel}from"../light.model";
importLightBitfrom"../fce/light.bit";
importStatefrom"../../99.core/state";
exportdefaultinterfaceLightBit{
idx:string;
src?:string;
val?:number;
dat?:any;
slv?:Function;
bit?:any;
lst?:any[];
importLightBitfrom"./light.bit";
exportdefaultinterfaceLight{
import{Action}from"../99.core/interface/action.interface";
importLightBitfrom"./fce/light.bit";
exportconstINIT_LIGHT="[Lightaction]InitLight";
exportclassInitLightimplementsAction{
readonlytype=INIT_LIGHT;
constructor(publicbale:LightBit){}
exportconstUPDATE_LIGHT="[Lightaction]UpdateLight";
exportclassUpdateLightimplementsAction{
readonlytype=UPDATE_LIGHT;
constructor(publicbale:LightBit){}
exportconstREAD_LIGHT="[Readaction]ReadLight";
exportclassReadLightimplementsAction{
readonlytype=READ_LIGHT;
constructor(publicbale:LightBit){}
exportconstSOURCE_LIGHT="[Sourceaction]SourceLight";
exportclassSourceLightimplementsAction{
readonlytype=SOURCE_LIGHT;
constructor(publicbale:LightBit){}
exporttypeActions=|InitLight|UpdateLight
|ReadLight
|SourceLight
export{initLight}from"./buz/light.buzz";
export{updateLight}from"./buz/light.buzz";
export{readLight}from"./buz/light.buzz";
export{sourceLight}from"./buz/light.buzz";
importLightfrom"./fce/light.interface";
importLightBitfrom"./fce/light.interface";
exportclassLightModelimplementsLight{
idx:string='003.light';
sourceLight:any;
fate:any;
boundaryTitle:any={
"white":{idx:"00.AL.achromatic-snow",src:'white'},
"red":{idx:"01.AB.achromatic-blood",src:'red'},
"green":{idx:"02.CV.chromatic-virid",src:'green'},
"blue":{idx:"03.CM.chromatic-marine",src:'blue'},
"yello":{idx:"04.CS.chromatic-straw",src:'yello'},
"black":{idx:"05.CI.chromatic-ink",src:'black'},
"purple":{idx:"06.CN.chromatic-nobel",src:'purple'},
"orange":{idx:"07.CA.chromatic-amber",src:'orange'},
"pink":{idx:"08.CP.chromatic-peach",src:'pink'},
"brown":{idx:"09.CC.chromatic-coffee",src:'brown'},
"glop00":{idx:"10.AA.asymmetrical-achromatic",src:'glob00'},
"glop01":{idx:"11.BA.bootlegged-achromatic",src:'glop01'},
"glop02":{idx:"12.CA.criminal-achromatic",src:'glop02'},
"glop03":{idx:"13.DA.defunct-achromatic",src:'glop03'},
"glop04":{idx:"14.EA.execrable-achromatic",src:'glop04'},
"glop05":{idx:"15.FAfallacious-achromatic",src:'glop05'},
"glop06":{idx:"16.GA.grotesque-achromatic",src:'glop06'},
"glop07":{idx:"17.HA.horrible-achromatic",src:'glop07'},
"glop08":{idx:"18.IA.irrational-achromatic",src:'glop08'},
"glop09":{idx:"19.JA.jejune-achromatic",src:'glop09'},
"glop10":{idx:"20.KA.kleptomanical-achromatic",src:'glop10'},
"glop11":{idx:"21.LA.loathsome-achromatic",src:'glop11'},
"glop12":{idx:"22.MA.mordant-achromatic",src:'glop12'},
"glop13":{idx:"23.NA.nasty-achromatic",src:'glop13'},
"glop14":{idx:"24.OA.odious-achromatic",src:'glop14'},
"glop15":{idx:"25.PA.profane-achromatic",src:'glop15'},
"glop16":{idx:"26.QA.quixotic-achromatic",src:'glop16'},
"glop17":{idx:"27.RA.rapacious-achromatic",src:'glop17'},
"glop18":{idx:"29.SA.slanderous-achromatic",src:'glop18'},
"glop19":{idx:"29.TA.tyrannical-achromatic",src:'glop19'},
"glop20":{idx:"30.UA.unborn-achromatic",src:'glop20'},
"glop21":{idx:"31.VA.vehement-achromatic",src:'glop21'},
"glop22":{idx:"32.WA.worthless-achromatic",src:'glop22'},
"glop23":{idx:"33.XA.xenophobic-achromatic",src:'glop23'},
"glop24":{idx:"34.YA.yucky-achromatic",src:'glop24'},
"glop25":{idx:"34.ZA.zeronic-achromatic",src:'glop25'}
boundaryData:any={
black:"#000000",
white:"#ffffff",
blue:"#0000FF",
green:"#00FF00",
yello:"#FFFF00",
red:"#FF0000",
purple:"#800080",
orange:"#FFA500",
brown:"#964B00",
pink:"#ffc0cb",
glop00:"#f5f5dc",
glop01:"#4a0404",
glop02:"#6082B6",
glop03:"#93934a",
glop05:"#c6b836",
glop06:"#8A9A5B",
glop07:"#7393B3",
glop08:"#FF00FF",
glop09:"#838383",
glop10:"#e1ad01",
glop11:"#A9A9A9",
glop12:"#375915",
glop13:"#a0bf16",
glop14:"#B2BEB5",
glop15:"#708090",
glop16:"#b8bc86",
glop17:"#899499",
glop18:"#899499",
glop19:"#818589",
glop20:"#848884",
glop21:"#71797E",
glop22:"#899499",
glop23:"#654321",
glop24:"#808080",
glop25:"#36454F"
import*asclonefrom"clone-deep";
import*asActfrom"./light.action";
import{LightModel}from"./light.model";
import*asBuzzfrom"./light.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:LightModel=newLightModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.UPDATE_LIGHT:
returnBuzz.updateLight(clone(model),act.bale,state);
caseAct.INIT_LIGHT:
returnBuzz.initLight(clone(model),act.bale,state);
caseAct.READ_LIGHT:
returnBuzz.readLight(clone(model),act.bale,state);
caseAct.SOURCE_LIGHT:
returnBuzz.sourceLight(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassLightUnit{
constructor(state:State){
import{SwatchModel}from"../swatch.model";
importSwatchBitfrom"../fce/swatch.bit";
importStatefrom"../../99.core/state";
importStripBitfrom"../fce/strip.bit";
import{ColorModel}from"../../01.color.unit/color.model";
import*asActSwcfrom"../../03.swatch.unit/swatch.action";
import*asActClrfrom"../../01.color.unit/color.action";
import*asActColfrom"../../97.collect.unit/collect.action";
import*asActBusfrom"../../99.bus.unit/bus.action";
import*asActCnsfrom"../../act/console.action";
import*asActVrtfrom"../../act/vurt.action"
import*asActDskfrom"../../act/disk.action"
import*asActPvtfrom"../../act/pivot.action"
import*asclonefrom"clone-deep";
varbit,val,idx,dex,lst,dat,src;
exportconstinitSwatch=(cpy:SwatchModel,bal:SwatchBit,ste:State)=>{
debugger
exportconstupdateSwatch=(cpy:SwatchModel,bal:SwatchBit,ste:State)=>{
exportconstcreateSwatch=async(cpy:SwatchModel,bal:SwatchBit,ste:State)=>{
debugger
varclrMod:ColorModel=ste.value.color
varnow=clrMod.colorData
varclrList=bal.dat.lst;
bal.dat.lst=null
vardat:StripBit={idx:bal.idx};
for(varkeyinbal.dat){
if(key=='id')dat['dex']=bal.dat[key]
elsedat[key]=bal.dat[key]
src=bal.dat.colorsrc
bit=awaitste.bus(ActDsk.INDEX_DISK,{src:'./data/swatch/'+src})
varlst=bit.dskBit.lst;
vardex=lst.length-1;
varoutput=[]
varconvert=require('color-convert');
varnextDir=async()=>{
bit=awaitste.bus(ActCns.UPDATE_CONSOLE,{idx:'cns00',src:"-----------swatch"+dex})
if(dex<0){
output
dat.lst=output
bal.slv({swcBit:{idx:'create-swatch',dat}});
varnow=lst[dex];
varfs=require("fs"),
PNG=require("pngjs").PNG;
vardata=fs.readFileSync('./data/swatch/'+src+'/'+now);
varpng=PNG.sync.read(data);
varx=1;
vary=1;
varidx=(png.width*y+x)<<2;
varr=png.data[idx];
varg=png.data[idx+1];
varb=png.data[idx+2];
vara=png.data[idx+3];
clrList=bal.dat.dat.lst
varid=convert.rgb.hex(r,g,b);
bit=awaitste.hunt(ActClr.WRITE_COLOR,{idx:id,src:id,dat:{lst:clrList}})
vardata=bit.clrBit.dat
output.push(data)
dex-=1
awaitnextDir()
awaitnextDir()
exportconstreadSwatch=async(cpy:SwatchModel,bal:SwatchBit,ste:State)=>{
varslv=bal.slv;
if(bal.idx==null)bal.idx='swc00';
bit=awaitste.hunt(ActCol.READ_COLLECT,{idx:bal.idx,bit:ActSwc.CREATE_SWATCH});
varitem=bit.clcBit.dat;
slv({swcBit:{idx:"read-swatch",dat:item}});
exportconstwriteSwatch=async(cpy:SwatchModel,bal:SwatchBit,ste:State)=>{
debugger
varslv=bal.slv;
if(bal.idx==null)bal.idx='swc00';
bit=awaitste.hunt(ActCol.WRITE_COLLECT,{idx:bal.idx,src:bal.src,dat:bal.dat,bit:ActSwc.CREATE_SWATCH});
varitem=bit.clcBit.dat;
if(bit.clcBit.val==1)awaitste.hunt(ActSwc.UPDATE_SWATCH,{idx:bal.idx,dat:bal.dat});
if(slv!=null)slv({swcBit:{idx:"write-swatch",dat:item}});
exportconstremoveSwatch=async(cpy:SwatchModel,bal:SwatchBit,ste:State)=>{
bit=awaitste.hunt(ActCol.REMOVE_COLLECT,{idx:bal.idx,src:bal.src,dat:bal.dat,bit:ActSwc.DELETE_SWATCH})
if(bal.slv!=null)bal.slv({swcBit:{idx:"remove-swatch",dat:bit.clcBit}});
exportconstdeleteSwatch=(cpy:SwatchModel,bal:SwatchBit,ste:State)=>{
debugger
exportdefaultinterfaceStripBit{
idx:string;
src?:string;
val?:number;
dat?:any;
lst?:any[]
exportdefaultinterfaceSwatchBit{
idx:string;
src?:string;
val?:number;
dat?:any;
slv?:Function;
bit?:any;
lst?:any[];
importSwatchBitfrom"./swatch.bit";
exportdefaultinterfaceSwatch{
import{Action}from"../99.core/interface/action.interface";
importSwatchBitfrom"./fce/swatch.bit";
exportconstINIT_SWATCH="[Swatchaction]InitSwatch";
exportclassInitSwatchimplementsAction{
readonlytype=INIT_SWATCH;
constructor(publicbale:SwatchBit){}
exportconstUPDATE_SWATCH="[Swatchaction]UpdateSwatch";
exportclassUpdateSwatchimplementsAction{
readonlytype=UPDATE_SWATCH;
constructor(publicbale:SwatchBit){}
exportconstREAD_SWATCH="[Readaction]ReadSwatch";
exportclassReadSwatchimplementsAction{
readonlytype=READ_SWATCH;
constructor(publicbale:SwatchBit){}
exportconstWRITE_SWATCH="[Writeaction]WriteSwatch";
exportclassWriteSwatchimplementsAction{
readonlytype=WRITE_SWATCH;
constructor(publicbale:SwatchBit){}
exportconstREMOVE_SWATCH="[Removeaction]RemoveSwatch";
exportclassRemoveSwatchimplementsAction{
readonlytype=REMOVE_SWATCH;
constructor(publicbale:SwatchBit){}
exportconstDELETE_SWATCH="[Deleteaction]DeleteSwatch";
exportclassDeleteSwatchimplementsAction{
readonlytype=DELETE_SWATCH;
constructor(publicbale:SwatchBit){}
exportconstCREATE_SWATCH="[Createaction]CreateSwatch";
exportclassCreateSwatchimplementsAction{
readonlytype=CREATE_SWATCH;
constructor(publicbale:SwatchBit){}
exporttypeActions=|InitSwatch|UpdateSwatch
|ReadSwatch
|WriteSwatch
|RemoveSwatch
|DeleteSwatch
|CreateSwatch
export{initSwatch}from"./buz/swatch.buzz";
export{updateSwatch}from"./buz/swatch.buzz";
export{readSwatch}from"./buz/swatch.buzz";
export{writeSwatch}from"./buz/swatch.buzz";
export{removeSwatch}from"./buz/swatch.buzz";
export{deleteSwatch}from"./buz/swatch.buzz";
export{createSwatch}from"./buz/swatch.buzz";
importSwatchfrom"./fce/swatch.interface";
importSwatchBitfrom"./fce/swatch.interface";
exportclassSwatchModelimplementsSwatch{
import*asclonefrom"clone-deep";
import*asActfrom"./swatch.action";
import{SwatchModel}from"./swatch.model";
import*asBuzzfrom"./swatch.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:SwatchModel=newSwatchModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.UPDATE_SWATCH:
returnBuzz.updateSwatch(clone(model),act.bale,state);
caseAct.INIT_SWATCH:
returnBuzz.initSwatch(clone(model),act.bale,state);
caseAct.READ_SWATCH:
returnBuzz.readSwatch(clone(model),act.bale,state);
caseAct.WRITE_SWATCH:
returnBuzz.writeSwatch(clone(model),act.bale,state);
caseAct.REMOVE_SWATCH:
returnBuzz.removeSwatch(clone(model),act.bale,state);
caseAct.DELETE_SWATCH:
returnBuzz.deleteSwatch(clone(model),act.bale,state);
caseAct.CREATE_SWATCH:
returnBuzz.createSwatch(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassSwatchUnit{
constructor(state:State){
import{PaletteModel}from"../palette.model";
importPaletteBitfrom"../fce/palette.bit";
importStatefrom"../../99.core/state";
import*asActPxlfrom"../../00.pixel.unit/pixel.action";
import*asActPalfrom"../../04.palette.unit/palette.action";
import*asActColfrom"../../97.collect.unit/collect.action";
import*asActBusfrom"../../99.bus.unit/bus.action";
import*asActVrtfrom"../../act/vurt.action"
import*asActDskfrom"../../act/disk.action"
import*asActPvtfrom"../../act/pivot.action";
import*asActClrfrom"../../act/color.action"
import*asActLgtfrom"../../act/light.action"
import*asSfrom'string'
varbit,val,idx,dex,lst,dat,src;
exportconstinitPalette=(cpy:PaletteModel,bal:PaletteBit,ste:State)=>{
debugger
exportconstupdatePalette=async(cpy:PaletteModel,bal:PaletteBit,ste:State)=>{
bit=awaitste.bus(ActDsk.INDEX_DISK,{src:bal.idx})
varlstMain=bit.dskBit.lst;
vardex=lstMain.length-1;
varoutput=[]
varnext=async()=>{
if(dex<0){
output
idx=bal.idx+'/index.json'
bit=awaitste.bus(ActDsk.WRITE_DISK,{src:idx,dat:JSON.stringify(output)})
bal.slv({canBit:{idx:"update-palette",src:idx}});
return
varitm=lstMain[dex]
if(itm==null){
debugger
output
idx=bal.src+'/index.json'
bit=awaitste.bus(ActDsk.WRITE_DISK,{src:idx,dat:JSON.stringify(output)})
bal.slv({canBit:{idx:"update-palette",src:idx}});
return
if(itm=='index.json'){
dex-=1
next()
return
varname=itm.split('.')[0]
bit=awaitste.hunt(ActPxl.READ_PIXEL,{idx:name,src:bal.src,val:1})
lst=[]
output.push(bit.pxlBit.dat)
dex-=1
if((dex+1)%3==0){
varmsg=dex+'/'+lst.length;
awaitnext()
awaitnext()
exportconstreadPalette=async(cpy:PaletteModel,bal:PaletteBit,ste:State)=>{
if(bal.idx==null)bal.idx='can00';
bit=awaitste.hunt(ActCol.READ_COLLECT,{idx:bal.idx,bit:ActPal.CREATE_PALETTE})
exportconstwritePalette=async(cpy:PaletteModel,bal:PaletteBit,ste:State)=>{
bit=awaitste.hunt(ActCol.WRITE_COLLECT,{idx:bal.idx,src:bal.src,dat:bal.dat,bit:ActPal.CREATE_PALETTE})
ste.hunt(ActPal.UPDATE_PALETTE,{idx:bal.idx})
if(bal.slv!=null)bal.slv({canBit:{idx:"write-container",dat:bit.clcBit.dat}});
exportconstremovePalette=(cpy:PaletteModel,bal:PaletteBit,ste:State)=>{
debugger
exportconstdeletePalette=(cpy:PaletteModel,bal:PaletteBit,ste:State)=>{
debugger
exportconstcreatePalette=async(cpy:PaletteModel,bal:PaletteBit,ste:State)=>{
idx=bal.src+'/index.json'
bit=awaitste.bus(ActDsk.READ_DISK,{src:idx})
lst=JSON.parse(bit.dskBit.dat)
constresult=[];
for(leti=0;i<lst.length;i++){
if((i+1)%10==0){
result.push(lst[i]);
varoutput=[]
vardex=result.length-1;
varval=0;
varnext=async()=>{
if(dex<0){
output
if(bal.slv!=null)bal.slv({palBit:{idx:"create-palette",dat}});
return
vara=result[dex]
varS=require('string')
varnom=S(a.name).slugify().s
varha=a.value.substring(1);
src=bal.src+'/'+ha+'.'+nom+'.png'
val+=1;
bit=awaitste.bus(ActDsk.SWATCH_DISK,{idx:a.value.substring(1),src})
dex-=1;
if((dex+1)%2==0){
varmsg=dex+'/'+result.length;
next()
next()
exportconstlistPalette=async(cpy:PaletteModel,bal:PaletteBit,ste:State)=>{
bit=awaitste.bus(ActDsk.INDEX_DISK,{src:'./palette'})
lst=bit.dskBit.lst;
lst=lst.filter(a=>a!=".git")
lst=lst.filter(a=>a!="README.md")
lst=lst.filter(a=>a!=".gitattributes")
setTimeout(()=>{
if(bal.slv!=null)bal.slv({palBit:{idx:"list-palette",lst}});
},3);
exportconstbuildPalette=async(cpy:PaletteModel,bal:PaletteBit,ste:State)=>{
bit=awaitste.hunt(ActPxl.READ_PIXEL,{idx:bal.idx,src:bal.src})
lst=[]
vardat={}
vardatLst=[]
bit.pxlBit.lst.forEach((a,b)=>{
idx=S(a.name).slugify().s
if(dat[idx]!=null)return
dat[idx]=a
datLst.push(dat[idx])
varsrcItm='./palette/'+bal.dat+'/index.json';
vardatItm=datLst
datItm.push({name:'chromakeygreen',value:'#00FF00',rgb:{r:0,g:255,b:0},distance:0}
varFS=require('fs-extra')
FS.ensureFileSync(srcItm)
FS.writeJsonSync(srcItm,datItm)
datLst.forEach(async(a,b)=>{
varidx=S(a.name).slugify().s
vardir='./palette/'+bal.dat+"/"+idx+".png";
varvalue=a.value
bit=awaitste.bus(ActDsk.SWATCH_DISK,{idx:value,src:dir});
bal.slv({palBit:{idx:"build-palette",lst:datLst}})
exportdefaultinterfacePaletteBit{
idx:string;
src?:string;
val?:number;
dat?:any;
slv?:Function;
bit?:any;
lst?:any[];
importPaletteBitfrom"./palette.bit";
exportdefaultinterfacePalette{
import{Action}from"../99.core/interface/action.interface";
importPaletteBitfrom"./fce/palette.bit";
exportconstINIT_PALETTE="[Paletteaction]InitPalette";
exportclassInitPaletteimplementsAction{
readonlytype=INIT_PALETTE;
constructor(publicbale:PaletteBit){}
exportconstUPDATE_PALETTE="[Paletteaction]UpdatePalette";
exportclassUpdatePaletteimplementsAction{
readonlytype=UPDATE_PALETTE;
constructor(publicbale:PaletteBit){}
exportconstREAD_PALETTE="[Readaction]ReadPalette";
exportclassReadPaletteimplementsAction{
readonlytype=READ_PALETTE;
constructor(publicbale:PaletteBit){}
exportconstREMOVE_PALETTE="[Removeaction]RemovePalette";
exportclassRemovePaletteimplementsAction{
readonlytype=REMOVE_PALETTE;
constructor(publicbale:PaletteBit){}
exportconstDELETE_PALETTE="[Deleteaction]DeletePalette";
exportclassDeletePaletteimplementsAction{
readonlytype=DELETE_PALETTE;
constructor(publicbale:PaletteBit){}
exportconstCREATE_PALETTE="[Createaction]CreatePalette";
exportclassCreatePaletteimplementsAction{
readonlytype=CREATE_PALETTE;
constructor(publicbale:PaletteBit){}
exportconstWRITE_PALETTE="[Writeaction]WritePalette";
exportclassWritePaletteimplementsAction{
readonlytype=WRITE_PALETTE;
constructor(publicbale:PaletteBit){}
exportconstLIST_PALETTE="[Listaction]ListPalette";
exportclassListPaletteimplementsAction{
readonlytype=LIST_PALETTE;
constructor(publicbale:PaletteBit){}
exportconstBUILD_PALETTE="[Buildaction]BuildPalette";
exportclassBuildPaletteimplementsAction{
readonlytype=BUILD_PALETTE;
constructor(publicbale:PaletteBit){}
exporttypeActions=|InitPalette|UpdatePalette
|ReadPalette
|RemovePalette
|DeletePalette
|CreatePalette
|WritePalette
|ListPalette
|BuildPalette
export{initPalette}from"./buz/palette.buzz";
export{updatePalette}from"./buz/palette.buzz";
export{readPalette}from"./buz/palette.buzz";
export{removePalette}from"./buz/palette.buzz";
export{deletePalette}from"./buz/palette.buzz";
export{createPalette}from"./buz/palette.buzz";
export{writePalette}from"./buz/palette.buzz";
export{listPalette}from"./buz/palette.buzz";
export{buildPalette}from"./buz/palette.buzz";
importPalettefrom"./fce/palette.interface";
importPaletteBitfrom"./fce/palette.interface";
exportclassPaletteModelimplementsPalette{
import*asclonefrom"clone-deep";
import*asActfrom"./palette.action";
import{PaletteModel}from"./palette.model";
import*asBuzzfrom"./palette.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:PaletteModel=newPaletteModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.UPDATE_PALETTE:
returnBuzz.updatePalette(clone(model),act.bale,state);
caseAct.INIT_PALETTE:
returnBuzz.initPalette(clone(model),act.bale,state);
caseAct.READ_PALETTE:
returnBuzz.readPalette(clone(model),act.bale,state);
caseAct.REMOVE_PALETTE:
returnBuzz.removePalette(clone(model),act.bale,state);
caseAct.DELETE_PALETTE:
returnBuzz.deletePalette(clone(model),act.bale,state);
caseAct.CREATE_PALETTE:
returnBuzz.createPalette(clone(model),act.bale,state);
caseAct.WRITE_PALETTE:
returnBuzz.writePalette(clone(model),act.bale,state);
caseAct.LIST_PALETTE:
returnBuzz.listPalette(clone(model),act.bale,state);
caseAct.BUILD_PALETTE:
returnBuzz.buildPalette(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassPaletteUnit{
constructor(state:State){
import*asActColfrom'../../97.collect.unit/collect.action';
varbit,lst,dat,idx,val,src,dex;
exportconstinitCollect=(cpy:CollectModel,bal:CollectBit,ste:State)=>{
exportconstupdateCollect=(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
exportconstfetchCollect=(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
if(bal.val==null)bal.val=1;
if(bal.bit==null)
bal.slv({clcBit:{idx:'fetch-collect-err',src:'no-bit'}});
vartype=bal.bit.split('').slice(-1).pop().toLowerCase();
varcabBit:CaboodleBit=cpy.caboodleBitList[cpy.caboodleBits[type]];
if(bal.val==1)bit=cabBit.bitList[0];
elsebit=cabBit;
if(bal.slv!=null)bal.slv({clcBit:{idx:'fetch-collect',dat:bit}});
exportconstreadCollect=async(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
if(bal.bit==null)
bal.slv({clcBit:{idx:'read-collect-err',src:'no-bit'}});
vartype=bal.bit.split('').slice(-1).pop().toLowerCase();
if(cpy.caboodleBits[type]==null)createCollect(cpy,{idx:type},ste);
varcabBit:CaboodleBit=cpy.caboodleBitList[cpy.caboodleBits[type]];
if(cabBit.bits[bal.idx]==null){
bit=awaitste.hunt(ActCol.WRITE_COLLECT,{
idx:bal.idx,
src:bal.src,
bit:bal.bit,
});
}else{
dat=cabBit.bitList[cabBit.bits[bal.idx]];
if(bal.slv!=null)bal.slv({clcBit:{idx:'read-collect',dat}});
exportconstwriteCollect=async(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
dat=null;
vartype=bal.bit.split('').slice(-1).pop().toLowerCase();
if(cpy.caboodleBits[type]==null)createCollect(cpy,{idx:type},ste);
if(bal.bit==null)
bal.slv({rskBit:{idx:'write-collect-err',src:'no-bit'}});
varcabBit:CaboodleBit=cpy.caboodleBitList[cpy.caboodleBits[type]];
bal.idx;
val=0;
if(cabBit.bits[bal.idx]==null){
bit=awaitste.hunt(bal.bit,{idx:bal.idx,src:bal.src,dat:bal.dat});
varobjDat=bit[Object.keys(bit)[0]];
dat=objDat.dat;
if(dat==null)dat={};
dat.dex=cabBit.bitList.length;
cabBit.bitList.push(dat);
varidx=bal.idx;
if(idx==null)idx=dat.idx;
if(idx==null)thrownewError('writecollecthasnoidx');
cabBit.bits[idx]=dat.dex;
}else{
varcabDat=cabBit.bitList[cabBit.bits[bal.idx]];
bal.dat;
val=1;
for(varkeyinbal.dat){
if(cabDat==null)cabDat={};
cabDat[key]=bal.dat[key];
cabBit.bitList[cabBit.bits[bal.idx]]=cabDat;
dat=cabDat;
if(dat==null&&bal.slv!=null)
bal.slv({rskBit:{idx:'write-collect-err',src:'no-dat'}});
if(bal.slv!=null)bal.slv({clcBit:{idx:'write-collect',val,dat}});
exportconstcreateCollect=(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
varcabBit:CaboodleBit={idx:bal.idx,dex:0,bits:{},bitList:[]};
cabBit.dex=cpy.caboodleBitList.length;
cpy.caboodleBitList.push(cabBit);
cpy.caboodleBits[cabBit.idx]=cabBit.dex;
if(bal.slv!=null)
bal.slv({clcBit:{idx:'create-collect',dat:cabBit}});
exportconstremoveCollect=async(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
vartype=bal.bit.split('').slice(-1).pop().toLowerCase();
if(cpy.caboodleBits[type]==null)
returnbal.slv({rskBit:{idx:'remove-collect-not-present'}});
varcabBit:CaboodleBit=cpy.caboodleBitList[cpy.caboodleBits[type]];
if(cabBit.bits[bal.idx]==null)
returnbal.slv({rskBit:{idx:'remove-collect-idx-not-present'}});
bit=awaitste.hunt(bal.bit,{idx:bal.idx,src:bal.src,dat:bal.dat});
varobjDat=bit[Object.keys(bit)[0]];
dat=objDat.dat;
dex=dat.dex;
for(vari=dex;i<cabBit.bitList.length-1;i++){
varupdate=cabBit.bitList[i];
update.dex-=1;
for(varkeyindat){
dat[key]=null;
deletecabBit.bits[bal.idx];
varitm=cabBit.bitList.splice(dex,1);
cabBit.dex-=1;
if(bal.slv!=null)
bal.slv({clcBit:{idx:'remove-collect',dat:itm[0]}});
exportconstputCollect=(cpy:CollectModel,bal:CollectBit,ste:State)=>{
cpy.caboodleBits[bal.idx]=bal.val;
cpy.caboodleBitList[bal.val]=bal.dat;
if(bal.slv!=null)
bal.slv({clcBit:{idx:'put-collect',dat:bal.dat}});
exportconstgetCollect=(cpy:CollectModel,bal:CollectBit,ste:State)=>{
val=cpy.caboodleBits[bal.idx];
dat=cpy.caboodleBitList[val];
if(bal.slv!=null)bal.slv({clcBit:{idx:'get-collect',val,dat}});
exportconstmodelCollect=(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
if(bal.slv!=null)bal.slv({clcBit:{idx:'model-collect',dat:cpy}});
exportconstdeleteCollect=(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
exportconstemptyCollect=(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
exportconstdotCollect=(cpy:CollectModel,bal:CollectBit,ste:State)=>{
vargel=bal.dat;
varout=[];
bal.src.split('\n').forEach((a,b)=>{
vardoTCompiled=doT.template(a);
varoutLine=doTCompiled(gel);
out.push(outLine);
});
if(bal.slv!=null)
bal.slv({clcBit:{idx:'dot-vurt',lst:out,src:out.join('\n')}});
exportconstformatCollect=(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
lst=bal.src.split(':');
varidx=lst[0];
varout=[];
idx=S(idx).collapseWhitespace().s;
varopt=lst[1].split(',');
opt.forEach((a,b)=>{
varnow=S(a).collapseWhitespace().s;
if(a.length<1)return;
out.push(now);
});
dat=[idx,out];
bal.slv({clcBit:{idx:'format-collect',dat}});
exportconstlistCollect=(cpy:CollectModel,bal:CollectBit,ste:State)=>{
vartype=bal.bit.split('').slice(-1).pop().toLowerCase();
if(cpy.caboodleBits[type]==null)createCollect(cpy,{idx:type},ste);
varcabBit:CaboodleBit=cpy.caboodleBitList[cpy.caboodleBits[type]];
lst=[];
cabBit.bitList.forEach((a)=>{
if(a.idx!=null)lst.push(a.idx);
if(a.id!=null)lst.push(a.id);
});
bal.slv({clcBit:{idx:'list-collect',lst}});
exportconsthashCollect=(cpy:CollectModel,bal:CollectBit,ste:State)=>{
if(bal.src==null)bal.src='';
lst=bal.src.split('\n');
dat={};
lst.forEach((a)=>{
a=S(a).collapseWhitespace().s;
if(a.length<3)return;
varhold=a.split(':');
vardom=hold[0];
varsub=hold[1];
varnow=sub.split(',');
now.forEach((b,c)=>{
now[c]=S(b).collapseWhitespace().s;
});
dat[dom]=now;
});
bal.slv({clcBit:{idx:'hash-collect',dat}});
import{CollectModel}from'../collect.model';
importCollectBitfrom'../fce/collect.bit';
importStatefrom'../../99.core/state';
importCaboodleBitfrom'../fce/caboodle.bit';
import*asSfrom'string';
import*asdoTfrom'dot';
import{Action}from"../99.core/interface/action.interface";
importCollectBitfrom"./fce/collect.bit";
exportconstINIT_COLLECT="[Collectaction]InitCollect";
exportclassInitCollectimplementsAction{
readonlytype=INIT_COLLECT;
constructor(publicbale:CollectBit){}
exportconstUPDATE_COLLECT="[Collectaction]UpdateCollect";
exportclassUpdateCollectimplementsAction{
readonlytype=UPDATE_COLLECT;
constructor(publicbale:CollectBit){}
exportconstFETCH_COLLECT="[Collectaction]FetchCollect";
exportclassFetchCollectimplementsAction{
readonlytype=FETCH_COLLECT;
constructor(publicbale:CollectBit){}
exportconstREAD_COLLECT="[Readaction]ReadCollect";
exportclassReadCollectimplementsAction{
readonlytype=READ_COLLECT;
constructor(publicbale:CollectBit){}
exportconstWRITE_COLLECT="[Writeaction]WriteCollect";
exportclassWriteCollectimplementsAction{
readonlytype=WRITE_COLLECT;
constructor(publicbale:CollectBit){}
exportconstCREATE_COLLECT="[Createaction]CreateCollect";
exportclassCreateCollectimplementsAction{
readonlytype=CREATE_COLLECT;
constructor(publicbale:CollectBit){}
exportconstREMOVE_COLLECT="[Createaction]RemoveCollect";
exportclassRemoveCollectimplementsAction{
readonlytype=REMOVE_COLLECT;
constructor(publicbale:CollectBit){}
exportconstDELETE_COLLECT="[Createaction]DeleteCollect";
exportclassDeleteCollectimplementsAction{
readonlytype=DELETE_COLLECT;
constructor(publicbale:CollectBit){}
exportconstEMPTY_COLLECT="[Emptyaction]EmptyCollect";
exportclassEmptyCollectimplementsAction{
readonlytype=EMPTY_COLLECT;
constructor(publicbale:CollectBit){}
exportconstMODEL_COLLECT="[Emptyaction]ModelCollect";
exportclassModelCollectimplementsAction{
readonlytype=MODEL_COLLECT;
constructor(publicbale:CollectBit){}
exportconstPUT_COLLECT="[Emptyaction]PutCollect";
exportclassPutCollectimplementsAction{
readonlytype=PUT_COLLECT;
constructor(publicbale:CollectBit){}
exportconstGET_COLLECT="[Emptyaction]GetCollect";
exportclassGetCollectimplementsAction{
readonlytype=GET_COLLECT;
constructor(publicbale:CollectBit){}
exportconstFORMAT_COLLECT="[Formataction]FormatCollect";
exportclassFormatCollectimplementsAction{
readonlytype=FORMAT_COLLECT;
constructor(publicbale:CollectBit){}
exportconstDOT_COLLECT="[Formataction]DotCollect";
exportclassDotCollectimplementsAction{
readonlytype=DOT_COLLECT;
constructor(publicbale:CollectBit){}
exportconstLIST_COLLECT="[Listaction]ListCollect";
exportclassListCollectimplementsAction{
readonlytype=LIST_COLLECT;
constructor(publicbale:CollectBit){}
exportconstHASH_COLLECT="[Hashaction]HashCollect";
exportclassHashCollectimplementsAction{
readonlytype=HASH_COLLECT;
constructor(publicbale:CollectBit){}
exporttypeActions=|InitCollect|UpdateCollect
|ReadCollect
|WriteCollect
|CreateCollect
|EmptyCollect
|FetchCollect
|DeleteCollect
|RemoveCollect
|ModelCollect
|GetCollect
|PutCollect
|FormatCollect
|DotCollect
|ListCollect
|HashCollect
export{initCollect}from"./buz/collect.buzz";
export{updateCollect}from"./buz/collect.buzz";
export{readCollect}from"./buz/collect.buzz";
export{writeCollect}from"./buz/collect.buzz";
export{createCollect}from"./buz/collect.buzz";
export{emptyCollect}from"./buz/collect.buzz";
export{fetchCollect}from"./buz/collect.buzz";
export{deleteCollect}from"./buz/collect.buzz";
export{removeCollect}from"./buz/collect.buzz";
export{modelCollect}from"./buz/collect.buzz";
export{putCollect}from"./buz/collect.buzz";
export{getCollect}from"./buz/collect.buzz";
export{formatCollect}from"./buz/collect.buzz";
export{dotCollect}from"./buz/collect.buzz";
export{listCollect}from"./buz/collect.buzz";
export{hashCollect}from"./buz/collect.buzz";
importCaboodleBitfrom"./fce/caboodle.bit";
importCollectfrom"./fce/collect.interface";
importCollectBitfrom"./fce/collect.interface";
exportclassCollectModelimplementsCollect{
idx:string='23.11.14';
caboodleBitList:CaboodleBit[]=[];
caboodleBits:any={};
import*asclonefrom"clone-deep";
import*asActfrom"./collect.action";
import{CollectModel}from"./collect.model";
import*asBuzzfrom"./collect.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:CollectModel=newCollectModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.UPDATE_COLLECT:
returnBuzz.updateCollect(clone(model),act.bale,state);
caseAct.INIT_COLLECT:
returnBuzz.initCollect(clone(model),act.bale,state);
caseAct.READ_COLLECT:
returnBuzz.readCollect(clone(model),act.bale,state);
caseAct.WRITE_COLLECT:
returnBuzz.writeCollect(clone(model),act.bale,state);
caseAct.CREATE_COLLECT:
returnBuzz.createCollect(clone(model),act.bale,state);
caseAct.DELETE_COLLECT:
returnBuzz.deleteCollect(clone(model),act.bale,state);
caseAct.REMOVE_COLLECT:
returnBuzz.removeCollect(clone(model),act.bale,state);
caseAct.EMPTY_COLLECT:
returnBuzz.emptyCollect(clone(model),act.bale,state);
caseAct.FETCH_COLLECT:
returnBuzz.fetchCollect(clone(model),act.bale,state);
caseAct.MODEL_COLLECT:
returnBuzz.modelCollect(clone(model),act.bale,state);
caseAct.GET_COLLECT:
returnBuzz.getCollect(clone(model),act.bale,state);
caseAct.PUT_COLLECT:
returnBuzz.putCollect(clone(model),act.bale,state);
caseAct.FORMAT_COLLECT:
returnBuzz.formatCollect(clone(model),act.bale,state);
caseAct.DOT_COLLECT:
returnBuzz.dotCollect(clone(model),act.bale,state);
caseAct.LIST_COLLECT:
returnBuzz.listCollect(clone(model),act.bale,state);
caseAct.HASH_COLLECT:
returnBuzz.hashCollect(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassCollectUnit{
constructor(state:State){
exportdefaultinterfaceCaboodleBit{
idx:string;
dex:number;
bitList:any[];
bits:any;
exportdefaultinterfaceCollectBit{
idx?:string;
src?:string;
val?:number;
dex?:number;
dat?:any;
bit?:any;
slv?:Function;
importCollectBitfrom"./collect.bit";
importCaboodleBitfrom"./caboodle.bit";
exportdefaultinterfaceCollect{
idx:string;
caboodleBitList:CaboodleBit[];
caboodleBits:any;
import{Action}from"../99.core/interface/action.interface";
importBusBitfrom"./fce/bus.bit";
exportconstINIT_BUS="[Busaction]InitBus";
exportclassInitBusimplementsAction{
readonlytype=INIT_BUS;
constructor(publicbale:BusBit){}
exportconstOPEN_BUS="[Busaction]OpenBus";
exportclassOpenBusimplementsAction{
readonlytype=OPEN_BUS;
constructor(publicbale:BusBit){}
exportconstCONNECT_BUS="[Busaction]ConnectBus";
exportclassConnectBusimplementsAction{
readonlytype=CONNECT_BUS;
constructor(publicbale:BusBit){}
exportconstMESSAGE_BUS="[Busaction]MessageBus";
exportclassMessageBusimplementsAction{
readonlytype=MESSAGE_BUS;
constructor(publicbale:BusBit){}
exportconstUPDATE_BUS="[Busaction]UpdateBus";
exportclassUpdateBusimplementsAction{
readonlytype=UPDATE_BUS;
constructor(publicbale:BusBit){}
exportconstCREATE_BUS="[Busaction]CreateBus";
exportclassCreateBusimplementsAction{
readonlytype=CREATE_BUS;
constructor(publicbale:BusBit){}
exporttypeActions=|InitBus|OpenBus|UpdateBus|ConnectBus|MessageBus|CreateBus;
export{initBus}from"./buz/bus.buzz";
export{openBus}from"./buz/bus.buzz";
export{updateBus}from"./buz/bus.buzz";
export{connectBus}from"./buz/bus.buzz";
export{messageBus}from"./buz/bus.buzz";
export{createBus}from"./buz/bus.buzz";
importBusfrom"./fce/bus.interface";
importBusBitfrom"./fce/bus.interface";
exportclassBusModelimplementsBus{
MQTT:any;
actList:any;
client:any;
bus:Function;
responseSuffix:string='-response'
promises:any={}
import*asclonefrom"clone-deep";
import*asActfrom"./bus.action";
import{BusModel}from"./bus.model";
import*asBuzzfrom"./bus.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:BusModel=newBusModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.UPDATE_BUS:
returnBuzz.updateBus(clone(model),act.bale,state);
caseAct.OPEN_BUS:
returnBuzz.openBus(clone(model),act.bale,state);
caseAct.CONNECT_BUS:
returnBuzz.connectBus(clone(model),act.bale,state);
caseAct.CREATE_BUS:
returnBuzz.createBus(clone(model),act.bale,state);
caseAct.MESSAGE_BUS:
returnBuzz.connectBus(clone(model),act.bale,state);
caseAct.INIT_BUS:
returnBuzz.initBus(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassBusUnit{
constructor(state:State){
import*asActBusfrom"../../99.bus.unit/bus.action";
import*asActColfrom"../../97.collect.unit/collect.action";
import{BusModel}from"../bus.model";
importBusBitfrom"../fce/bus.bit";
importStatefrom"../../99.core/state";
importSfrom"string";
import*asclonefrom"clone-deep";
varlst,idx,bit,src,dat,dex;
exportconstinitBus=(cpy:BusModel,bal:BusBit,ste:State)=>{
cpy.actList=[]
if(bal==null)bal={idx:null}
if(bal.lst==null)bal.lst=[]
if((bal.src!=null)&&(bal.src.constructor==Array))lst=bal.src;
bal.lst.forEach((a)=>{
for(varkeyina){
cpy.actList.push(a[key])
ste.bus=(idx,dat,bit)=>updateBus(cpy,{idx,dat,bit},ste)
if(bal.dat!=null){
cpy.MQTT=bal.dat;
else{
if(lst==null){
if(bal.src!=null)cpy.host=bal.src
cpy.client=cpy.MQTT.connect(cpy.host);
cpy.client.on('message',(tpc,msg)=>{messageBus(cpy,{idx:tpc,src:msg},ste)})
cpy.client.on('connect',()=>{
openBus(cpy,{idx:'init-bus',lst:cpy.actList},ste)
if(bal.slv!=null)bal.slv({intBit:{idx:"init-bus"}})
}else{
varcomplete=(lst)=>{
lst.shift()
if(lst.length!=0)return
if(bal.slv!=null)bal.slv({intBit:{idx:"init-bus"}})
lst.forEach(async(a)=>{
bit=awaitste.hunt(ActCol.WRITE_COLLECT,{idx:a.idx,src:a.src,bit:ActBus.CREATE_BUS})
varclient=bit.clcBit.dat;
client.on('message',(tpc,msg)=>{messageBus(cpy,{idx:tpc,src:msg,bit:a.idx},ste)})
client.on('connect',()=>{
openBus(cpy,{idx:'init-bus',lst:cpy.actList,bit:a.idx},ste)
complete(lst)
exportconstcreateBus=(cpy:BusModel,bal:BusBit,ste:State)=>{
varclient=cpy.MQTT.connect(bal.src);
if(bal.slv!=null)bal.slv({busBit:{idx:"create-bus",dat:client}});
exportconstopenBus=async(cpy:BusModel,bal:BusBit,ste:State)=>{
varout=[]
bal.lst.forEach((a)=>{
if(a==null)return
if(a.includes==null)return
if(a.includes('[')&&a.includes(']')==false)return
out.push(a)
varclient=cpy.client;
if(bal.bit!=null){
bit=awaitste.hunt(ActCol.READ_COLLECT,{idx:bal.bit,bit:ActBus.CREATE_BUS})
client=bit.clcBit.dat
out.forEach((a)=>{
client.subscribe(a,(err)=>{
if(!err){
exportconstconnectBus=(cpy:BusModel,bal:BusBit,ste:State)=>{
varlst=[]
exportconstmessageBus=async(cpy:BusModel,bal:BusBit,ste:State)=>{
if(bal.src!=null)dat=bal.src.toString()
idx=bal.idx
dat=JSON.parse(dat)
varclient=cpy.client;
if(bal.bit!=null){
bit=awaitste.hunt(ActCol.READ_COLLECT,{idx:bal.bit,bit:ActBus.CREATE_BUS})
client=bit.clcBit.dat
if(idx.includes(cpy.responseSuffix)==true){
varresponseIDX=bal.idx;
varobj=cpy.promises[responseIDX];
if(obj.slv!=null)obj.slv(dat);
client.unsubscribe(responseIDX,(err)=>{
if(!err){
}else{
varbit=awaitste.hunt(idx,dat)
varcloneBit=clone(bit)
for(varkeyincloneBit){
varitm=cloneBit[key]
if(itm.dat!=null){
if(itm.dat.bit!=null)itm.dat.bit=null
cloneBit
client.publish(bal.idx+cpy.responseSuffix,JSON.stringify(cloneBit))
exportconstupdateBus=async(cpy:BusModel,bal:BusBit,ste:State)=>{
varclient=cpy.client;
if(bal.bit!=null){
bit=awaitste.hunt(ActCol.READ_COLLECT,{idx:bal.bit,bit:ActBus.CREATE_BUS})
client=bit.clcBit.dat
if((client==null)&&(bal.bit==null)){
bit=awaitste.hunt(ActCol.FETCH_COLLECT,{bit:ActBus.CREATE_BUS})
client=bit.clcBit.dat
varresponseIDX=bal.idx+cpy.responseSuffix;
varslv;
constpromo=newPromise((rslv,rjct)=>(slv=rslv));
varobj={slv:(val0)=>slv(val0)};
cpy.promises[responseIDX]=obj
client.subscribe(responseIDX,(err)=>{
if(!err){
client.publish(bal.idx,JSON.stringify(bal.dat))
returnpromo;
varpatch=(ste,type,bale)=>ste.dispatch({type,bale});
exportdefaultinterfaceBusBit{
idx:string;
val?:number;
lst?:any;
src?:any;
bit?:string;
slv?:Function;
dat?:any;
importBusBitfrom"./bus.bit";
exportdefaultinterfaceBus{
exportinterfaceAction<T=any>{
type:string;
bale?:T;
exportdefaultinterfaceModel{}
import{BehaviorSubject}from"rx-lite";
import{Subject}from"rx-lite";
import{Action}from"./interface/action.interface";
importUnitModelfrom"../BEE";
import*asEffectfrom"../BEE";
exportdefaultclassStateextendsBehaviorSubject<any>{
publichunt:any;
publicvalue:any;
publicpivot:any;
publicbus:any;
privatedispatcher:Subject=newSubject();
constructor(init:UnitModel=newUnitModel()){
super(init);
this.dispatcher
.scan((state,action)=>this.reducedApp(state,action),init)
.subscribe((state)=>{
super.onNext(state);
});
reducedApp(nextState:any,key:any){
for(varkinEffect.reducer)Effect.reducer[k](nextState[k],key,this);
returnnextState;
dispatch(value:Action){
varresult=this.dispatcher.onNext(value);
returnresult;
pat(value:Action){
this.dispatch(value);
next(value:any){
this.dispatcher.onNext(value);
exportconstINIT_CANVAS="[Canvasaction]InitCanvas";
exportconstUPDATE_CANVAS="[Canvasaction]UpdateCanvas";
exportconstREAD_CANVAS="[Readaction]ReadCanvas";
exportconstWRITE_CANVAS="[Writeaction]WriteCanvas";
exportconstDELETE_CANVAS="[Deleteaction]DeleteCanvas";
exportconstREMOVE_CANVAS="[Removeaction]RemoveCanvas";
exportconstCREATE_CANVAS="[Createaction]CreateCanvas";
exportconstNEST_CANVAS="[Nestaction]NestCanvas";
exportconstINIT_CHOICE="[Choiceaction]InitChoice";
exportconstUPDATE_CHOICE="[Choiceaction]UpdateChoice";
exportconstOPEN_CHOICE="[Openaction]OpenChoice";
exportconstKEY_CHOICE="[Keyaction]KeyChoice";
exportconstTOWER_CHOICE="[Toweraction]TowerChoice";
exportconstINIT_COLOR="[Coloraction]InitColor";
exportconstUPDATE_COLOR="[Coloraction]UpdateColor";
exportconstOPEN_COLOR="[Openaction]OpenColor";
exportconstREAD_COLOR="[Readaction]ReadColor";
exportconstINIT_CONSOLE="[Consoleaction]InitConsole";
exportconstUPDATE_CONSOLE="[Consoleaction]UpdateConsole";
exportconstREAD_CONSOLE="[Readaction]ReadConsole";
exportconstWRITE_CONSOLE="[Writeaction]WriteConsole";
exportconstREMOVE_CONSOLE="[Removeaction]RemoveConsole";
exportconstDELETE_CONSOLE="[Deleteaction]DeleteConsole";
exportconstCREATE_CONSOLE="[Createaction]CreateConsole";
exportconstINIT_DISK='[Diskaction]InitDisk'
exportconstUPDATE_DISK='[Diskaction]UpdateDisk'
exportconstREAD_DISK='[Diskaction]ReadDisk'
exportconstWRITE_DISK='[Diskaction]WriteDisk'
exportconstINDEX_DISK='[Indexaction]IndexDisk'
exportconstLOAD_LIST_DISK='[Load_listaction]Load_listDisk'
exportconstCOPY_DISK='[Copyaction]CopyDisk'
exportconstFRAME_DISK='[Frameaction]FrameDisk'
exportconstBATCH_DISK='[Batchaction]BatchDisk'
exportconstTRASH_DISK='[Trashaction]TrashDisk'
exportconstENSURE_DISK='[Ensureaction]EnsureDisk'
exportconstDELETE_DISK='[Deleteaction]DeleteDisk'
exportconstEXIST_DISK="[Existaction]ExistDisk";
exportconstSWATCH_DISK="[Swatchaction]SwatchDisk";
exportconstCOLOR_DISK="[Coloraction]ColorDisk";
import{Action}from"../99.core/interface/action.interface";
exportconstINIT_GRAPHIC="[Graphicaction]InitGraphic";
exportconstUPDATE_GRAPHIC="[Graphicaction]UpdateGraphic";
exportconstREAD_GRAPHIC="[Readaction]ReadGraphic";
exportconstWRITE_GRAPHIC="[Writeaction]WriteGraphic";
exportconstCREATE_GRAPHIC="[Createaction]CreateGraphic";
exportconstINIT_GRID="[Gridaction]InitGrid";
exportconstUPDATE_GRID="[Gridaction]UpdateGrid";
exportconstINIT_HEXAGON="[Hexagonaction]InitHexagon";
exportconstUPDATE_HEXAGON="[Hexagonaction]UpdateHexagon";
exportconstREAD_HEXAGON="[Readaction]ReadHexagon";
exportconstWRITE_HEXAGON="[Writeaction]WriteHexagon";
exportconstCREATE_HEXAGON="[Createaction]CreateHexagon";
exportconstINIT_INPUT="[Inputaction]InitInput";
exportconstUPDATE_INPUT="[Inputaction]UpdateInput";
exportconstOPEN_INPUT="[Openaction]OpenInput";
exportconstINIT_LIGHT="[Lightaction]InitLight";
exportconstUPDATE_LIGHT="[Lightaction]UpdateLight";
exportconstREAD_LIGHT="[Readaction]ReadLight";
import{Action}from"../99.core/interface/action.interface";
exportconstINIT_PIVOT="[Pivotaction]InitPivot";
exportconstUPDATE_PIVOT="[Pivotaction]UpdatePivot";
exportconstOPEN_PIVOT="[Openaction]OpenPivot";
exportconstRUN_PIVOT="[Runaction]RunPivot";
exportconstEDIT_PIVOT="[Editaction]EditPivot";
exportconstPATCH_PIVOT="[Patchaction]PatchPivot";
exportconstCOUNT_PIVOT="[Patchaction]CountPivot";
exportconstLIST_PIVOT="[Patchaction]ListPivot";
exportconstCREATE_PIVOT="[Patchaction]CreatePivot";
exportconstCONTAINS_PIVOT="[Patchaction]ContainsPivot";
exportconstBUNDLE_PIVOT="[Patchaction]BundlePivot";
exportconstINIT_RENPY="[Renpyaction]InitRenpy";
exportconstUPDATE_RENPY="[Renpyaction]UpdateRenpy";
exportconstOPEN_RENPY="[Renpyaction]OpenRenpy";
exportconstINIT_SHINY="[Shinyaction]InitShiny";
exportconstUPDATE_SHINY="[Shinyaction]UpdateShiny";
exportconstOPEN_SHINY="[Shinyaction]OpenShiny";
exportconstINIT_SPACE="[Spaceaction]InitSpace";
exportconstUPDATE_SPACE="[Spaceaction]UpdateSpace";
exportconstREADY_SPACE="[Readyaction]ReadySpace";
exportconstINIT_TERMINAL="[Terminalaction]InitTerminal";
exportconstOPEN_TERMINAL="[Terminalaction]OpenTerminal";
exportconstFOCUS_TERMINAL="[Terminalaction]FocusTerminal";
exportconstWRITE_TERMINAL="[Terminalaction]WriteTerminal";
exportconstUPDATE_TERMINAL="[Terminalaction]UpdateTerminal";
exportconstCLEAR_TERMINAL="[Terminalaction]ClearTerminal";
exportconstINPUT_TERMINAL="[Terminalaction]InputTerminal";
exportconstTABLE_TERMINAL="[Terminalaction]TableTerminal";
exportconstCLOSE_TERMINAL="[Terminalaction]CloseTerminal";
exportconstROOT_TERMINAL="[Terminalaction]RootTerminal";
exportconstCONTENT_TERMINAL="[Terminalaction]ContentTerminal";
exportconstADD_PORT="[Terminalaction]AddPort";
exportconstINIT_VISAGE="[Visageaction]InitVisage";
exportconstUPDATE_VISAGE="[Visageaction]UpdateVisage";
exportconstFULLSCREEN_VISAGE="[Fullscreenaction]FullscreenVisage";
exportconstREAD_VISAGE="[Readaction]ReadVisage";
exportconstWRITE_VISAGE="[Writeaction]WriteVisage";
exportconstCREATE_VISAGE="[Createaction]CreateVisage";
exportconstSIZE_VISAGE="[Sizeaction]SizeVisage";
exportconstRENDER_VISAGE="[Renderaction]RenderVisage";
exportconstINIT_VURT="[Vurtaction]InitVurt";
exportconstDELAY_VURT="[Vurtaction]DelayVurt";
exportconstTEST_CLOUD_VURT="[Vurtaction]TestCloudVurt";
exportconstFETCH_VURT="[Vurtaction]FetchVurt";
exportconstUPDATE_VURT="[Vurtaction]UpdateVurt";
exportconstREPLACE_VURT="[Vurtaction]ReplaceVurt";
exportconstUNIT_VURT="[Vurtaction]UnitVurt";
exportconstCOUNT_VURT="[Vurtaction]CountVurt";
exportconstLIST_PIVOT_VURT="[Vurtaction]ListPivotVurt";
exportconstLIST_UNIT_VURT="[Vurtaction]ListUnitVurt";
exportconstCONTAINS_VURT="[Containsaction]ContainsVurt";
exportconstBUNDLE_VURT="[Bundleaction]BundleVurt";
exportconstVALUE_VURT="[Valueaction]ValueVurt";
importModelfrom"./99.core/interface/model.interface";
importPixelUnitfrom"./00.pixel.unit/pixel.unit";
importColorUnitfrom"./01.color.unit/color.unit";
importLightUnitfrom"./02.light.unit/light.unit";
importSwatchUnitfrom"./03.swatch.unit/swatch.unit";
importPaletteUnitfrom"./04.palette.unit/palette.unit";
importCollectUnitfrom"./97.collect.unit/collect.unit";
importBusUnitfrom"./99.bus.unit/bus.unit";
importPixelfrom"./00.pixel.unit/fce/pixel.interface";
import{PixelModel}from"./00.pixel.unit/pixel.model";
importColorfrom"./01.color.unit/fce/color.interface";
import{ColorModel}from"./01.color.unit/color.model";
importLightfrom"./02.light.unit/fce/light.interface";
import{LightModel}from"./02.light.unit/light.model";
importSwatchfrom"./03.swatch.unit/fce/swatch.interface";
import{SwatchModel}from"./03.swatch.unit/swatch.model";
importPalettefrom"./04.palette.unit/fce/palette.interface";
import{PaletteModel}from"./04.palette.unit/palette.model";
importCollectfrom"./97.collect.unit/fce/collect.interface";
import{CollectModel}from"./97.collect.unit/collect.model";
importBusfrom"./99.bus.unit/fce/bus.interface";
import{BusModel}from"./99.bus.unit/bus.model";
exportconstlist:Array<any>=[PixelUnit,ColorUnit,LightUnit,SwatchUnit,PaletteUnit,CollectUnit,BusUnit];
import*asreduceFromPixelfrom"./00.pixel.unit/pixel.reduce";
import*asreduceFromColorfrom"./01.color.unit/color.reduce";
import*asreduceFromLightfrom"./02.light.unit/light.reduce";
import*asreduceFromSwatchfrom"./03.swatch.unit/swatch.reduce";
import*asreduceFromPalettefrom"./04.palette.unit/palette.reduce";
import*asreduceFromCollectfrom"./97.collect.unit/collect.reduce";
import*asreduceFromBusfrom"./99.bus.unit/bus.reduce";
exportconstreducer:any={
pixel:reduceFromPixel.reducer,
color:reduceFromColor.reducer,
light:reduceFromLight.reducer,
swatch:reduceFromSwatch.reducer,
palette:reduceFromPalette.reducer,
collect:reduceFromCollect.reducer,
bus:reduceFromBus.reducer,
exportdefaultclassUnitDataimplementsModel{
pixel:Pixel=newPixelModel();
color:Color=newColorModel();
light:Light=newLightModel();
swatch:Swatch=newSwatchModel();
palette:Palette=newPaletteModel();
collect:Collect=newCollectModel();
bus:Bus=newBusModel();
varsim={
hunt:null,
state:null
sim.hunt=(typ,obj)=>{returnhost(obj,typ)}
varhost=(obj,typ)=>{
init();
varslv;
constpromo=newPromise((rslv,rjct)=>(slv=rslv));
if(obj==null)obj={};
if(obj.slv==null)obj.slv=(val0)=>slv(val0);
sim.state.dispatch({type:typ,bale:obj});
returnpromo;
varinit=()=>{
if(sim.state!=null)return;
sim.state=newState();
sim.state.pivot=sim;
sim.state.hunt=sim.hunt
for(varkinImport.list)newImport.list[k](sim.state);
import*asImportfrom"./BEE";
importStatefrom"./99.core/state";
module.exports=sim;
exportconstVERTICAL="vertical";
exportconstHORIZONTAL="horizontal";
exportconstBLACK:string="black";
exportconstRED:string="red";
exportconstGREEN:string="green";
exportconstYELLOW:string="yellow";
exportconstMAGENTA:string="magenta";
exportconstCYAN:string="cyan";
exportconstWHITE:string="white";
exportconstBLUE:string="blue";
"usestrict";
exports.__esModule=true;
exports.CYAN=exports.MAGENTA=exports.YELLOW=exports.GREEN=exports.RED=void0;
exports.RED="\x1b[31m%s\x1b[0m";
exports.GREEN="\x1b[32m%s\x1b[0m";
exports.YELLOW="\x1b[33m%s\x1b[0m";
exports.MAGENTA="\x1b[34m%s\x1b[0m";
exports.CYAN="\x1b[36m%s\x1b[0m";
exportconstRED:string="\x1b[31m%s\x1b[0m";
exportconstGREEN:string="\x1b[32m%s\x1b[0m";
exportconstYELLOW:string="\x1b[33m%s\x1b[0m";
exportconstMAGENTA:string="\x1b[34m%s\x1b[0m";
exportconstCYAN:string="\x1b[36m%s\x1b[0m";
"usestrict";
exports.__esModule=true;
exports.WISE_NORTH_EAST=exports.WISE_NORTH=exports.WISE_NORTH_WEST=exports.WISE_WEST=exports.WISE_SOUTH_WEST=exports.WISE_SOUTH=exports.WISE_SOUTH_EAST=exports.WISE_EAST=exports.NORTH_EAST=exports.NORTH=exports.NORTH_WEST=exports.WEST=exports.SOUTH_WEST=exports.SOUTH=exports.SOUTH_EAST=exports.EAST=void0;
exports.EAST="E";
exports.SOUTH_EAST="SE";
exports.SOUTH="S";
exports.SOUTH_WEST="SW";
exports.WEST="W";
exports.NORTH_WEST="NW";
exports.NORTH="N";
exports.NORTH_EAST="NE";
exports.WISE_EAST="WiseE";
exports.WISE_SOUTH_EAST="WiseSE";
exports.WISE_SOUTH="WiseS";
exports.WISE_SOUTH_WEST="WiseSW";
exports.WISE_WEST="WiseW";
exports.WISE_NORTH_WEST="WiseNW";
exports.WISE_NORTH="WiseN";
exports.WISE_NORTH_EAST="WiseNE";
exportconstEAST="E";
exportconstSOUTH_EAST="SE";
exportconstSOUTH="S";
exportconstSOUTH_WEST="SW";
exportconstWEST="W";
exportconstNORTH_WEST="NW";
exportconstNORTH="N";
exportconstNORTH_EAST="NE";
exportconstWISE_EAST="WiseE";
exportconstWISE_SOUTH_EAST="WiseSE";
exportconstWISE_SOUTH="WiseS";
exportconstWISE_SOUTH_WEST="WiseSW";
exportconstWISE_WEST="WiseW";
exportconstWISE_NORTH_WEST="WiseNW";
exportconstWISE_NORTH="WiseN";
exportconstWISE_NORTH_EAST="WiseNE";
exportconstPLAT:string="plat";
exportconstAMBT:string="ambt";
exportconstAVAS:string="avas";
"usestrict";
exports.__esModule=true;
exports.CIRCLE=exports.ROUNDED_RECTANGLE=exports.RECTANGLE=void0;
exports.RECTANGLE="rectangle";
exports.ROUNDED_RECTANGLE="rounded-rectangle";
exports.CIRCLE="circle";
exportconstRECTANGLE:string="rectangle";
exportconstROUNDED_RECTANGLE:string="rounded-rectangle";
exportconstCIRCLE:string="circle";
exporttypePosition<Type>={
x:number;
y:number;
}&Type
exporttypeGridFill=Position<{
xSpan:number;
ySpan:number;
exportconstTOP_FULL_IDX='top-fill';
exportconstMID_FULL_IDX='mid-fill';
exportconstBOT_FULL_IDX='bot-fill';
exportconstTOP_FULL_BIT:GridFill={x:0,y:0,xSpan:12,ySpan:4};
exportconstMID_FULL_BIT:GridFill={x:0,y:4,xSpan:12,ySpan:5};
exportconstBOT_FULL_BIT:GridFill={x:0,y:8,xSpan:12,ySpan:4};
"usestrict";
exports.__esModule=true;
exports.HEXMAP=exports.FOCUS=void0;
exports.FOCUS="focus";
exports.HEXMAP="hexmap";
exportconstFOCUS:string="focus";
exportconstHEXMAP:string="hexmap";
"usestrict";
exports.__esModule=true;
exports.PASTURE=exports.FANG_SWAMP=exports.GEORGIA=exports.GALLBLADDER=void0;
exports.GALLBLADDER="00000.gallbladder";
exports.GEORGIA="00001.georgia";
exports.FANG_SWAMP="00002.fang-swamp";
exports.PASTURE="00003.pasture";
exportconstPLAT:string="plat";
exportconstAMBT:string="ambt";
exportconstAVAS:string="avas";
"usestrict";
exports.__esModule=true;
exports.MAGENTA=exports.YELLOW=exports.BLUE=exports.GREEN=exports.RED=exports.CYAN=exports.CLEAN=exports.MENU_SINGLE=exports.TIMELINE=exports.SPACE=void0;
exports.SPACE="space";
exports.TIMELINE="timeline";
exports.MENU_SINGLE="menu_single";
exports.CLEAN="clean";
exports.CYAN="cyan";
exports.RED="red";
exports.GREEN="green";
exports.BLUE="blue";
exports.YELLOW="yellow";
exports.MAGENTA="magenta";
exportconstSPACE:string="space";
exportconstTIMELINE:string="timeline";
exportconstMENU_SINGLE:string="menu_single";
exportconstCLEAN:string="clean";
exportconstCYAN:string="cyan";
exportconstRED:string="red";
exportconstGREEN:string="green";
exportconstBLUE:string="blue";
exportconstYELLOW:string="yellow";
exportconstMAGENTA:string="magenta";
"usestrict";
exports.__esModule=true;
exports.LOOP=exports.VIDEO=exports.HEXAGON=exports.SPRITE=exports.TEXT=exports.GRAPHIC=exports.CONTAINER=exports.SURFACE=exports.VISAGE=void0;
exports.VISAGE="visage";
exports.SURFACE="surface";
exports.CONTAINER="container";
exports.GRAPHIC="graphic";
exports.TEXT="text";
exports.SPRITE="sprite";
exports.HEXAGON="hexagon";
exports.VIDEO="video";
exports.LOOP="loop";
exportconstVISAGE:string="visage";
exportconstSURFACE:string="surface";
exportconstCONTAINER:string="container";
exportconstGRAPHIC:string="graphic";
exportconstTEXT:string="text";
exportconstSPRITE:string="sprite";
exportconstHEXAGON:string="hexagon";
exportconstVIDEO:string="video";
exportconstLOOP:string="loop";
exportconstGEOJSON="geojson";
exportconstRECTANGLE="rectangle";
exportconstTRIANGLE="triangle";
exportconstHEXAGON="hexagon";
exportconstPARALLELOGRAM="parallelogram";
exportconstFOCUS="focus";
exportconstHEXMAP="hexmap";
exportconstCLOCK:string="clock";
"usestrict";
exports.__esModule=true;
exports.MOUNT_WIDTH=exports.MOUNT_HEIGHT=exports.MOUNT_PART=exports.MOUNT_FULL=exports.SCREEN=void0;
exports.SCREEN="screen-visage";
exports.MOUNT_FULL="mount-visage-full";
exports.MOUNT_PART="mount-visage-part";
exports.MOUNT_HEIGHT="mount-visage-height";
exports.MOUNT_WIDTH="mount-visage-width";
exportconstSCREEN:string="screen-visage";
exportconstMOUNT_FULL:string="mount-visage-full";
exportconstMOUNT_PART:string="mount-visage-part";
exportconstMOUNT_HEIGHT:string="mount-visage-height";
exportconstMOUNT_WIDTH:string="mount-visage-width";
import{LibraryModel}from"../library.model";
importLibraryBitfrom"../fce/library.bit";
importStatefrom"../../99.core/state";
import*asActMnufrom"../../98.menu.unit/menu.action";
import*asActBusfrom"../../99.bus.unit/bus.action";
import*asActLibfrom"../library.action";
import*asActVrtfrom"../../act/vurt.action";
import*asActDskfrom"../../act/disk.action";
import*asActPvtfrom"../../act/pivot.action";
import{glob}from"fs";
varbit,val,idx,dex,lst,dat;
exportconstinitLibrary=async(cpy:LibraryModel,bal:LibraryBit,ste:State)=>{
patch(ste,ActMnu.INIT_MENU,bal);
if(bal.slv!=null)bal.slv({intBit:{idx:"init-control"}});
exportconsttestLibrary=async(cpy:LibraryModel,bal:LibraryBit,ste:State)=>{
bal.slv({libBit:{idx:"test-library"}});
exportconstupdateLibrary=async(cpy:LibraryModel,bal:LibraryBit,ste:State)=>{
varlstMsg=[];
bit=awaitste.bus(ActPvt.SHIP_PIVOT,{src:'995.library'})
lstMsg=lstMsg.concat(bit.pvtBit.lst)
idx="../../011.sower/995.library/";
bit=awaitste.bus(ActDsk.COPY_DISK,{src:'./work/995.library/',idx});
lstMsg=lstMsg.concat(bit.pvtBit)
bal.slv({libBit:{idx:"update-library",lst:lstMsg}});
exportconstcountLibrary=async(cpy:LibraryModel,bal:LibraryBit,ste:State)=>{
varWalk=require("@root/walk");
varpath=require("path");
varFS=require('fs-extra')
varoutput=[]
vardirect={}
functionwalkFunc(err,pathname,dirent){
if(err){
console.warn("fsstaterrorfor%s:%s",pathname,err.message);
returnPromise.resolve();
if(dirent.isDirectory()&&dirent.name=='data'){returnPromise.resolve(false)}
if(dirent.isDirectory()&&dirent.name=='dist'){returnPromise.resolve(false)}
if(dirent.isDirectory()&&dirent.name=='node_modules'){returnPromise.resolve(false)}
if(dirent.isDirectory()&&dirent.name=='public'){returnPromise.resolve(false)}
if(dirent.isDirectory()&&dirent.name=='modules'){returnPromise.resolve(false)}
if(dirent.isDirectory()&&dirent.name=='.'){returnPromise.resolve(false)}
if(dirent.isDirectory()&&dirent.name.startsWith(".")){
returnPromise.resolve(false);
if(dirent.isFile()&&dirent.name.startsWith(".")==false){
varfile=path.join(path.dirname(pathname),dirent.name);
output.push(file)
if(direct[path.dirname(pathname)]==null)direct[path.dirname(pathname)]=''
returnPromise.resolve();
awaitWalk.walk('./',walkFunc);
output
constallowedExtensions=newSet(['.ts','.js','.mjs','.cjs']);
constpaths=output.filter(filePath=>{
returnallowedExtensions.has(extension);
});
paths
varout=[]
paths.forEach((a)=>{
varlst=FS.readFileSync(a).toString().split('\n');
out=out.concat(lst)
varscore=[]
out.forEach((a)=>{
if(a.length<5)return
a=a.replaceAll('','')
if(a.length<=3)return
score.push(a)
direct
score
FS.writeFileSync('./data/complete.txt',score.join('\n'))
varobj={
'.git',
'.vscode',
'node_modules',
'package.json',
'package-lock.json',
'yarn-lock.json',
'count.output.json',
'dist',
'data',
'public',
'modules'
'.json','.zip','.rar','.png','.jpg','.jpeg','.gif','.bmp','.mp3','.wma','.wav','.mp4','.flv','.mov','.avi','.wmv','.rmvb','.ogg','.avi','.ppt','.pptx','.doc','.docx','.xls','.xlsx','.psd','.ttf','.fon','.exe','.msi',
'ascii',
'utf8',
'utf-8',
'unicode'
ignoreEmptyLine:false,
constcount=require('count-code-line');
count(obj);
const{DateTime}=require("luxon");
constdt=DateTime.local();
varnow=dt.toLocaleString(DateTime.DATETIME_FULL);
varS=require('string')
now=now.replace(':','-')
now=S(now).slugify().s;
vardat=FS.readJsonSync('./count.output.json')
varline=dat.lines+':'+now
varlist=FS.readFileSync('./data/line-log.txt').toString().split('\n')
varpast=list[0];
varlast=Number(past.split(':')[0])
if(last!=dat.lines){
list.unshift(line)
list
FS.writeFileSync('./data/line-log.txt',list.join('\n'))
bal.slv({libBit:{idx:"count-library",val:dat.lines}});
varpatch=(ste,type,bale)=>ste.dispatch({type,bale});
exportdefaultinterfaceLibraryBit{
idx:string;
src?:string;
val?:number;
dat?:any;
slv?:Function;
importLibraryBitfrom"./library.bit";
exportdefaultinterfaceLibrary{
import{Action}from"../99.core/interface/action.interface";
importLibraryBitfrom"./fce/library.bit";
exportconstINIT_LIBRARY="[Libraryaction]InitLibrary";
exportclassInitLibraryimplementsAction{
readonlytype=INIT_LIBRARY;
constructor(publicbale:LibraryBit){}
exportconstUPDATE_LIBRARY="[Libraryaction]UpdateLibrary";
exportclassUpdateLibraryimplementsAction{
readonlytype=UPDATE_LIBRARY;
constructor(publicbale:LibraryBit){}
exportconstTEST_LIBRARY="[Libraryaction]TestLibrary";
exportclassTestLibraryimplementsAction{
readonlytype=TEST_LIBRARY;
constructor(publicbale:LibraryBit){}
exportconstCOUNT_LIBRARY="[Countaction]CountLibrary";
exportclassCountLibraryimplementsAction{
readonlytype=COUNT_LIBRARY;
constructor(publicbale:LibraryBit){}
exporttypeActions=|InitLibrary|UpdateLibrary|TestLibrary
|CountLibrary
export{initLibrary}from"./buz/library.buzz";
export{updateLibrary}from"./buz/library.buzz";
export{testLibrary}from"./buz/library.buzz";
export{countLibrary}from"./buz/library.buzz";
importLibraryfrom"./fce/library.interface";
importLibraryBitfrom"./fce/library.interface";
exportclassLibraryModelimplementsLibrary{
idx:string='995.library';
import*asclonefrom"clone-deep";
import*asActfrom"./library.action";
import{LibraryModel}from"./library.model";
import*asBuzzfrom"./library.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:LibraryModel=newLibraryModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.UPDATE_LIBRARY:
returnBuzz.updateLibrary(clone(model),act.bale,state);
caseAct.TEST_LIBRARY:
returnBuzz.testLibrary(clone(model),act.bale,state);
caseAct.INIT_LIBRARY:
returnBuzz.initLibrary(clone(model),act.bale,state);
caseAct.COUNT_LIBRARY:
returnBuzz.countLibrary(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassLibraryUnit{
constructor(state:State){
global.LIBRARY=require("../dist/995.library/hunt");
global.LIBRARY.ActLib=require("../dist/995.library/00.library.unit/library.action");
import*asActPutfrom"../../84.input.unit/input.action";
import*asActChcfrom"../../85.choice.unit/choice.action";
import*asActCvsfrom"../../82.canvas.unit/canvas.action";
import*asActTxtfrom"../../90.text.unit/text.action";
import*asActGrdfrom"../../81.grid.unit/grid.action";
import*asActCnsfrom"../../83.console.unit/console.action";
import*asActMnufrom"../../98.menu.unit/menu.action";
import*asActBusfrom"../../99.bus.unit/bus.action";
import*asActTrmfrom"../terminal.action";
varbit,val,idx,dex,lst,dat;
letfirstLoad=false;
exportconstinitTerminal=async(cpy:TerminalModel,bal:TerminalBit,ste:State)=>{
if(firstLoad==true)return
firstLoad=true
if(bal.dat!=null)bit=awaitste.hunt(ActBus.INIT_BUS,{idx:cpy.idx,lst:[ActTrm,ActChc,ActTxt,ActCvs,ActPut,ActGrd,ActCns],dat:bal.dat,src:bal.src})
bit=awaitste.hunt(ActTrm.OPEN_TERMINAL,{})
if(bal.val==1)patch(ste,ActMnu.INIT_MENU,bal);
if(bal.slv!=null)bal.slv({intBit:{idx:"init-terminal"}});
exportconstupdateTerminal=async(cpy:TerminalModel,bal:TerminalBit,ste:State)=>{
varlstMsg=[];
bal.slv({trmBit:{idx:"update-terminal",lst:lstMsg}});
exportconstopenTerminal=async(cpy:TerminalModel,bal:TerminalBit,ste:State)=>{
letblessed=cpy.blessed=require('blessed')
letcontrib=cpy.contrib=require('blessed-contrib');
letscreen=cpy.screen=cpy.blessed.screen();
cpy.screen.render()
if(bal.slv!=null)bal.slv({trmBit:{idx:"open-terminal"}});
exportconstcloseTerminal=(cpy:TerminalModel,bal:TerminalBit,ste:State)=>{
if(cpy.screen!=null)cpy.screen.destroy()
cpy.blessed=null
cpy.contrib=null
cpy.screen=null
if(bal.slv!=null)bal.slv({trmBit:{idx:"close-terminal"}});
exportconstrunTerminal=async(cpy:TerminalModel,bal:TerminalBit,ste:State)=>{
exportconsteditTerminal=(cpy:TerminalModel,bal:TerminalBit,ste:State)=>{
exportconstprintTerminal=(cpy:TerminalModel,bal:TerminalBit,ste:State)=>{
if(bal.slv!=null)bal.slv({trmBit:{idx:"write-terminal"}});
exportconstoptionTerminal=(cpy:TerminalModel,bal:TerminalBit,ste:State)=>{
if(bal.slv!=null)bal.slv({trmBit:{idx:"option-terminal"}});
exportconstinputTerminal=async(cpy:TerminalModel,bal:TerminalBit,ste:State)=>{
bal.slv({trmBit:{idx:"input-terminal"}});
exportconstclearTerminal=async(cpy:TerminalModel,bal:TerminalBit,ste:State)=>{
cpy.blessed.program().clear()
bal.slv({trmBit:{idx:"clear-terminal"}});
exportconstlayoutTerminal=(cpy:TerminalModel,bal:TerminalBit,ste:State)=>{
letbit;
switch(bal.src){
caseGrid.BOT_FULL_IDX:
bit=Grid.BOT_FULL_BIT
break
caseGrid.MID_FULL_IDX:
bit=Grid.MID_FULL_BIT
break
caseGrid.TOP_FULL_IDX:
bit=Grid.TOP_FULL_BIT
break
bal.slv({trmBit:{idx:"layout-terminal",dat:bit}});
varpatch=(ste,type,bale)=>ste.dispatch({type,bale});
import{TerminalModel}from"../terminal.model";
importTerminalBitfrom"../fce/terminal.bit";
importStatefrom"../../99.core/state";
import*asGridfrom'../../val/grid';
import*asColorfrom'../../val/console-color';
exportdefaultinterfaceControlBit{
idx:string;
src?:string;
lst?:any[];
val?:number;
dat?:any;
slv?:Function;
importTerminalBitfrom"./terminal.bit";
exportdefaultinterfaceTerminal{
import{Action}from"../99.core/interface/action.interface";
importTerminalBitfrom"./fce/terminal.bit";
exportconstINIT_TERMINAL="[Terminalaction]InitTerminal";
exportclassInitTerminalimplementsAction{
readonlytype=INIT_TERMINAL;
constructor(publicbale:TerminalBit){}
exportconstUPDATE_TERMINAL="[Terminalaction]UpdateTerminal";
exportclassUpdateTerminalimplementsAction{
readonlytype=UPDATE_TERMINAL;
constructor(publicbale:TerminalBit){}
exportconstRUN_TERMINAL="[Runaction]RunTerminal";
exportclassRunTerminalimplementsAction{
readonlytype=RUN_TERMINAL;
constructor(publicbale:TerminalBit){}
exportconstEDIT_TERMINAL="[Editaction]EditTerminal";
exportclassEditTerminalimplementsAction{
readonlytype=EDIT_TERMINAL;
constructor(publicbale:TerminalBit){}
exportconstPRINT_TERMINAL="[Printaction]PrintTerminal";
exportclassPrintTerminalimplementsAction{
readonlytype=PRINT_TERMINAL;
constructor(publicbale:TerminalBit){}
exportconstCLOSE_TERMINAL="[Closeaction]CloseTerminal";
exportclassCloseTerminalimplementsAction{
readonlytype=CLOSE_TERMINAL;
constructor(publicbale:TerminalBit){}
exportconstOPTION_TERMINAL="[Optionaction]OptionTerminal";
exportclassOptionTerminalimplementsAction{
readonlytype=OPTION_TERMINAL;
constructor(publicbale:TerminalBit){}
exportconstINPUT_TERMINAL="[Inputaction]InputTerminal";
exportclassInputTerminalimplementsAction{
readonlytype=INPUT_TERMINAL;
constructor(publicbale:TerminalBit){}
exportconstLAYOUT_TERMINAL="[Layoutaction]LayoutTerminal";
exportclassLayoutTerminalimplementsAction{
readonlytype=LAYOUT_TERMINAL;
constructor(publicbale:TerminalBit){}
exportconstOPEN_TERMINAL="[Layoutaction]OpenTerminal";
exportclassOpenTerminalimplementsAction{
readonlytype=OPEN_TERMINAL;
constructor(publicbale:TerminalBit){}
exportconstCLEAR_TERMINAL="[Layoutaction]ClearTerminal";
exportclassClearTerminalimplementsAction{
readonlytype=CLEAR_TERMINAL;
constructor(publicbale:TerminalBit){}
exporttypeActions=|InitTerminal|UpdateTerminal
|RunTerminal
|EditTerminal
|PrintTerminal
|CloseTerminal
|OptionTerminal
|InputTerminal
|LayoutTerminal
|OpenTerminal
|ClearTerminal
export{initTerminal}from"./buz/terminal.buzz";
export{openTerminal}from"./buz/terminal.buzz";
export{updateTerminal}from"./buz/terminal.buzz";
export{runTerminal}from"./buz/terminal.buzz";
export{editTerminal}from"./buz/terminal.buzz";
export{printTerminal}from"./buz/terminal.buzz";
export{closeTerminal}from"./buz/terminal.buzz";
export{optionTerminal}from"./buz/terminal.buzz";
export{inputTerminal}from"./buz/terminal.buzz";
export{layoutTerminal}from"./buz/terminal.buzz";
export{clearTerminal}from"./buz/terminal.buzz";
importTerminalfrom"./fce/terminal.interface";
importTerminalBitfrom"./fce/terminal.interface";
exportclassTerminalModelimplementsTerminal{
idx:string='998.terminal';
term:any;
rootIDX:any;
rootDAT:any;
blessed:any;
contrib:any;
screen:any
cols:number=12;
rows:number=12;
import*asclonefrom"clone-deep";
import*asActfrom"./terminal.action";
import{TerminalModel}from"./terminal.model";
import*asBuzzfrom"./terminal.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:TerminalModel=newTerminalModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.UPDATE_TERMINAL:
returnBuzz.updateTerminal(clone(model),act.bale,state);
caseAct.INIT_TERMINAL:
returnBuzz.initTerminal(clone(model),act.bale,state);
caseAct.RUN_TERMINAL:
returnBuzz.runTerminal(clone(model),act.bale,state);
caseAct.EDIT_TERMINAL:
returnBuzz.editTerminal(clone(model),act.bale,state);
caseAct.PRINT_TERMINAL:
returnBuzz.printTerminal(clone(model),act.bale,state);
caseAct.CLOSE_TERMINAL:
returnBuzz.closeTerminal(clone(model),act.bale,state);
caseAct.OPTION_TERMINAL:
returnBuzz.optionTerminal(clone(model),act.bale,state);
caseAct.OPEN_TERMINAL:
returnBuzz.openTerminal(clone(model),act.bale,state);
caseAct.INPUT_TERMINAL:
returnBuzz.inputTerminal(clone(model),act.bale,state);
caseAct.LAYOUT_TERMINAL:
returnBuzz.layoutTerminal(clone(model),act.bale,state);
caseAct.CLEAR_TERMINAL:
returnBuzz.clearTerminal(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassTerminalUnit{
constructor(state:State){
exportconstinitGrid=(cpy:GridModel,bal:GridBit,ste:State)=>{
debugger
exportconstupdateGrid=(cpy:GridModel,bal:GridBit,ste:State)=>{
lettermMod:TerminalModel=ste.value.terminal;
letmargin=0;
letcols=termMod.cols;
letrows=termMod.rows;
varcolNow=bal.x;
varrowNow=bal.y;
letcolSpan=bal.xSpan;
letrowSpan=bal.ySpan;
letspacing=0;
letcellWidth=((100-margin*2)/cols);
letcellHeight=((100-margin*2)/rows);
lettop:any=rowNow*cellHeight+margin;
letleft:any=colNow*cellWidth+margin;
top=top+'%';
left=left+'%';
letwidth=(cellWidth*colSpan-spacing)+'%';
letheight=(cellHeight*rowSpan-spacing)+'%';
letbit:NetBit={left,top,width,height}
if(bal.slv!=null)bal.slv({grdBit:{idx:"update-grid",dat:bit}});
import{GridModel}from"../grid.model";
importGridBitfrom"../fce/grid.bit";
importStatefrom"../../99.core/state";
import{TerminalModel}from"../../80.terminal.unit/terminal.model";
importNetBitfrom"../fce/net.bit";
importNetBitfrom"./net.bit";
exportdefaultinterfaceGridBit{
idx:string;
src?:string;
lst?:any[];
val?:number;
dat?:any;
slv?:Function;
x?:number;
y?:number;
xSpan?:number;
ySpan?:number;
importGridBitfrom"./grid.bit";
exportdefaultinterfaceGrid{
exportdefaultinterfaceNetBit{
left:number;
top:number;
width:string;
height:string;
import{Action}from"../99.core/interface/action.interface";
importGridBitfrom"./fce/grid.bit";
exportconstINIT_GRID="[Gridaction]InitGrid";
exportclassInitGridimplementsAction{
readonlytype=INIT_GRID;
constructor(publicbale:GridBit){}
exportconstUPDATE_GRID="[Gridaction]UpdateGrid";
exportclassUpdateGridimplementsAction{
readonlytype=UPDATE_GRID;
constructor(publicbale:GridBit){}
exporttypeActions=|InitGrid|UpdateGrid;
export{initGrid}from"./buz/grid.buzz";
export{updateGrid}from"./buz/grid.buzz";
importGridfrom"./fce/grid.interface";
importGridBitfrom"./fce/grid.interface";
exportclassGridModelimplementsGrid{
import*asclonefrom"clone-deep";
import*asActfrom"./grid.action";
import{GridModel}from"./grid.model";
import*asBuzzfrom"./grid.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:GridModel=newGridModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.UPDATE_GRID:
returnBuzz.updateGrid(clone(model),act.bale,state);
caseAct.INIT_GRID:
returnBuzz.initGrid(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassGridUnit{
constructor(state:State){
import*asActColfrom"../../97.collect.unit/collect.action";
import*asActCvsfrom"../../82.canvas.unit/canvas.action";
import*asActTxtfrom"../../90.text.unit/text.action";
varlst,bit,dat;
exportconstinitCanvas=(cpy:CanvasModel,bal:CanvasBit,ste:State)=>{
debugger
exportconsthexmapCanvas=(cpy:CanvasModel,bal:CanvasBit,ste:State)=>{
bal.slv({cvsBit:{idx:"hexmap-canvas",dat}});
exportconstupdateCanvas=async(cpy:CanvasModel,bal:CanvasBit,ste:State)=>{
bit=awaitste.hunt(ActCvs.READ_CANVAS,{idx:bal.idx})
letdat:FrameBit=bit.cvsBit.dat
letcanvas=dat.bit;
letctx=canvas.ctx;
dat.txtLst.forEach((a)=>{
ste.hunt(ActTxt.UPDATE_TEXT,{idx:a})
if(bal.slv!=null)bal.slv({cvsBit:{idx:"update-canvas",dat}});
exportconstcreateCanvas=async(cpy:CanvasModel,bal:CanvasBit,ste:State)=>{
lettermMod:TerminalModel=ste.value.terminal;
letcontrib=ste.value.terminal.contrib
vardat:FrameBit={idx:'hmm'}
if(dat.clr==null)dat.clr=COLOR.YELLOW
for(varkeyinbal.dat){
dat[key]=bal.dat[key]
dat.canLst=[];
dat.gphLst=[];
dat.txtLst=[];
dat.sprLst=[];
dat.hexLst=[];
letnet:NetBit=dat.net;
dat.bit=contrib.canvas({
left:net.left,
top:net.top,
bg:dat.clr,
width:net.width,
height:net.height
});
for(varkeyinbal.dat){dat[key]=bal.dat[key]}
letterminal:TerminalModel=ste.value.terminal;
letscreen=terminal.screen
screen.append(dat.bit)
screen.render()
if(bal.slv!=null)bal.slv({cvsBit:{idx:"create-canvas",dat}});
exportconstreadCanvas=async(cpy:CanvasModel,bal:CanvasBit,ste:State)=>{
varslv=bal.slv;
if(bal.idx==null)bal.idx='can00';
bit=awaitste.hunt(ActCol.READ_COLLECT,{idx:bal.idx,bit:ActCvs.CREATE_CANVAS})
if(slv!=null)slv({cvsBit:{idx:"read-canvas",dat:bit.clcBit.dat}});
exportconstwriteCanvas=async(cpy:CanvasModel,bal:CanvasBit,ste:State)=>{
bit=awaitste.hunt(ActCol.WRITE_COLLECT,{idx:bal.idx,src:bal.src,dat:bal.dat,bit:ActCvs.CREATE_CANVAS})
ste.hunt(ActCvs.UPDATE_CANVAS,{idx:bal.idx})
if(bal.slv!=null)bal.slv({cvsBit:{idx:"write-canvas",dat:bit.clcBit.dat}});
exportconstdeleteCanvas=async(cpy:CanvasModel,bal:CanvasBit,ste:State)=>{
exportconstremoveCanvas=async(cpy:CanvasModel,bal:CanvasBit,ste:State)=>{
bit=awaitste.hunt(ActCol.REMOVE_COLLECT,{idx:bal.idx,src:bal.src,dat:bal.dat,bit:ActCvs.DELETE_CANVAS})
if(bal.slv!=null)bal.slv({cvsBit:{idx:"remove-canvas",dat:bit.clcBit}});
exportconstnestCanvas=async(cpy:CanvasModel,bal:CanvasBit,ste:State)=>{
bit=awaitste.hunt(ActCvs.READ_CANVAS,{idx:bal.src})
vardat:FrameBit=bit.cvsBit.dat;
switch(bal.dat.typ){
caseSHADE.CONTAINER:
dat.canLst.push(bal.dat.idx)
break
caseSHADE.GRAPHIC:
dat.gphLst.push(bal.dat.idx)
break
caseSHADE.SPRITE:
dat.sprLst.push(bal.dat.idx)
break
caseSHADE.TEXT:
dat.txtLst.push(bal.dat.idx)
break
caseSHADE.HEXAGON:
dat.hexLst.push(bal.dat.idx)
break
bit=awaitste.hunt(ActCvs.WRITE_CANVAS,{idx:bal.src,dat})
if(bal.slv!=null)bal.slv({cvsBit:{idx:'nest-canvas'}});
import{CanvasModel}from"../canvas.model";
importCanvasBitfrom"../fce/canvas.bit";
importStatefrom"../../99.core/state";
importFrameBitfrom"../fce/frame.bit";
import{TerminalModel}from"../../80.terminal.unit/terminal.model";
import*asCOLORfrom'../../val/console-color'
import{GridFill}from"../../val/grid";
import*asGRIDfrom'../../val/grid'
import*asSHADEfrom'../../val/shade'
importNetBitfrom"../../81.grid.unit/fce/net.bit"
import*asHoneycombfrom"honeycomb-grid";
import{Action}from"../99.core/interface/action.interface";
importCanvasBitfrom"./fce/canvas.bit";
exportconstINIT_CANVAS="[Canvasaction]InitCanvas";
exportclassInitCanvasimplementsAction{
readonlytype=INIT_CANVAS;
constructor(publicbale:CanvasBit){}
exportconstUPDATE_CANVAS="[Canvasaction]UpdateCanvas";
exportclassUpdateCanvasimplementsAction{
readonlytype=UPDATE_CANVAS;
constructor(publicbale:CanvasBit){}
exportconstHEXMAP_CANVAS="[Canvasaction]HexmapCanvas";
exportclassHexmapCanvasimplementsAction{
readonlytype=HEXMAP_CANVAS;
constructor(publicbale:CanvasBit){}
exportconstREAD_CANVAS="[Readaction]ReadCanvas";
exportclassReadCanvasimplementsAction{
readonlytype=READ_CANVAS;
constructor(publicbale:CanvasBit){}
exportconstWRITE_CANVAS="[Writeaction]WriteCanvas";
exportclassWriteCanvasimplementsAction{
readonlytype=WRITE_CANVAS;
constructor(publicbale:CanvasBit){}
exportconstDELETE_CANVAS="[Deleteaction]DeleteCanvas";
exportclassDeleteCanvasimplementsAction{
readonlytype=DELETE_CANVAS;
constructor(publicbale:CanvasBit){}
exportconstREMOVE_CANVAS="[Removeaction]RemoveCanvas";
exportclassRemoveCanvasimplementsAction{
readonlytype=REMOVE_CANVAS;
constructor(publicbale:CanvasBit){}
exportconstCREATE_CANVAS="[Createaction]CreateCanvas";
exportclassCreateCanvasimplementsAction{
readonlytype=CREATE_CANVAS;
constructor(publicbale:CanvasBit){}
exportconstNEST_CANVAS="[Nestaction]NestCanvas";
exportclassNestCanvasimplementsAction{
readonlytype=NEST_CANVAS;
constructor(publicbale:CanvasBit){}
exporttypeActions=|InitCanvas|UpdateCanvas
|ReadCanvas
|WriteCanvas
|DeleteCanvas
|RemoveCanvas
|CreateCanvas
|NestCanvas
|HexmapCanvas
export{initCanvas}from"./buz/canvas.buzz";
export{updateCanvas}from"./buz/canvas.buzz";
export{readCanvas}from"./buz/canvas.buzz";
export{writeCanvas}from"./buz/canvas.buzz";
export{deleteCanvas}from"./buz/canvas.buzz";
export{removeCanvas}from"./buz/canvas.buzz";
export{createCanvas}from"./buz/canvas.buzz";
export{nestCanvas}from"./buz/canvas.buzz";
export{hexmapCanvas}from"./buz/canvas.buzz";
importCanvasfrom"./fce/canvas.interface";
importCanvasBitfrom"./fce/canvas.interface";
exportclassCanvasModelimplementsCanvas{
import*asclonefrom"clone-deep";
import*asActfrom"./canvas.action";
import{CanvasModel}from"./canvas.model";
import*asBuzzfrom"./canvas.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:CanvasModel=newCanvasModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.UPDATE_CANVAS:
returnBuzz.updateCanvas(clone(model),act.bale,state);
caseAct.INIT_CANVAS:
returnBuzz.initCanvas(clone(model),act.bale,state);
caseAct.READ_CANVAS:
returnBuzz.readCanvas(clone(model),act.bale,state);
caseAct.WRITE_CANVAS:
returnBuzz.writeCanvas(clone(model),act.bale,state);
caseAct.DELETE_CANVAS:
returnBuzz.deleteCanvas(clone(model),act.bale,state);
caseAct.REMOVE_CANVAS:
returnBuzz.removeCanvas(clone(model),act.bale,state);
caseAct.CREATE_CANVAS:
returnBuzz.createCanvas(clone(model),act.bale,state);
caseAct.NEST_CANVAS:
returnBuzz.nestCanvas(clone(model),act.bale,state);
caseAct.HEXMAP_CANVAS:
returnBuzz.hexmapCanvas(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassCanvasUnit{
constructor(state:State){
importNetBitfrom"../../81.grid.unit/fce/net.bit";
exportdefaultinterfaceCanvasBit{
idx:string;
src?:string;
lst?:any[];
val?:number;
dat?:any;
slv?:Function;
net?:NetBit
importCanvasBitfrom"./canvas.bit";
exportdefaultinterfaceCanvas{
importNetBitfrom"../../81.grid.unit/fce/net.bit";
exportdefaultinterfaceFrameBit{
idx:string;
src?:string;
typ?:string;
clr?:string;
width?:number;
height?:number;
dex?:number;
parent?:any;
fill?:string;
canLst?:string[];
gphLst?:string[];
txtLst?:string[];
sprLst?:string[];
hexLst?:string[];
bit?:any;
net?:NetBit;
varbit;
import*asActCnsfrom"../console.action";
import*asActColfrom"../../97.collect.unit/collect.action";
exportconstinitConsole=(cpy:ConsoleModel,bal:ConsoleBit,ste:State)=>{
debugger
exportconstupdateConsole=async(cpy:ConsoleModel,bal:ConsoleBit,ste:State)=>{
bit=awaitste.hunt(ActCns.READ_CONSOLE,{idx:bal.idx})
letdat:TermBit=bit.cnsBit.dat
letconsole=dat.bit;
if(bal.src==null)bal.src=''
dat.bit
bal.src
dat.bit.log(bal.src)
if(bal.slv!=null)bal.slv({cnsBit:{idx:"update-console"}});
exportconstcreateConsole=(cpy:ConsoleModel,bal:ConsoleBit,ste:State)=>{
lettermMod:TerminalModel=ste.value.terminal;
letcontrib=ste.value.terminal.contrib
vardat:TermBit={idx:'hmm',bit:null,clr:null,net:null}
if(dat.clr==null)dat.clr=COLOR.GREEN
for(varkeyinbal.dat){dat[key]=bal.dat[key]}
dat.bit=contrib.log(
fg:dat.clr,
selectedFg:dat.clr,
label:'ServerLog',
left:dat.net.left,
top:dat.net.top,
width:dat.net.width,
height:dat.net.height
letterminal:TerminalModel=ste.value.terminal;
letscreen=terminal.screen;
screen.append(dat.bit)
screen.render()
if(bal.slv!=null)bal.slv({cnsBit:{idx:"create-console",dat}});
exportconstreadConsole=async(cpy:ConsoleModel,bal:ConsoleBit,ste:State)=>{
varslv=bal.slv;
if(bal.idx==null)bal.idx='can00';
bit=awaitste.hunt(ActCol.READ_COLLECT,{idx:bal.idx,bit:ActCns.CREATE_CONSOLE})
if(slv!=null)slv({cnsBit:{idx:"read-console",dat:bit.clcBit.dat}});
exportconstwriteConsole=async(cpy:ConsoleModel,bal:ConsoleBit,ste:State)=>{
bit=awaitste.hunt(ActCol.WRITE_COLLECT,{idx:bal.idx,src:bal.src,dat:bal.dat,bit:ActCns.CREATE_CONSOLE})
ste.hunt(ActCns.UPDATE_CONSOLE,{idx:bal.idx,src:bal.src})
if(bal.slv!=null)bal.slv({cnsBit:{idx:"write-console",dat:bit.clcBit.dat}});
exportconstremoveConsole=(cpy:ConsoleModel,bal:ConsoleBit,ste:State)=>{
debugger
exportconstdeleteConsole=(cpy:ConsoleModel,bal:ConsoleBit,ste:State)=>{
debugger
import{ConsoleModel}from"../console.model";
importConsoleBitfrom"../fce/console.bit";
importStatefrom"../../99.core/state";
importTermBitfrom"../fce/term.bit";
import{TerminalModel}from"../../80.terminal.unit/terminal.model";
import*asCOLORfrom'../../val/console-color'
import{Action}from"../99.core/interface/action.interface";
importConsoleBitfrom"./fce/console.bit";
exportconstINIT_CONSOLE="[Consoleaction]InitConsole";
exportclassInitConsoleimplementsAction{
readonlytype=INIT_CONSOLE;
constructor(publicbale:ConsoleBit){}
exportconstUPDATE_CONSOLE="[Consoleaction]UpdateConsole";
exportclassUpdateConsoleimplementsAction{
readonlytype=UPDATE_CONSOLE;
constructor(publicbale:ConsoleBit){}
exportconstREAD_CONSOLE="[Readaction]ReadConsole";
exportclassReadConsoleimplementsAction{
readonlytype=READ_CONSOLE;
constructor(publicbale:ConsoleBit){}
exportconstWRITE_CONSOLE="[Writeaction]WriteConsole";
exportclassWriteConsoleimplementsAction{
readonlytype=WRITE_CONSOLE;
constructor(publicbale:ConsoleBit){}
exportconstREMOVE_CONSOLE="[Removeaction]RemoveConsole";
exportclassRemoveConsoleimplementsAction{
readonlytype=REMOVE_CONSOLE;
constructor(publicbale:ConsoleBit){}
exportconstDELETE_CONSOLE="[Deleteaction]DeleteConsole";
exportclassDeleteConsoleimplementsAction{
readonlytype=DELETE_CONSOLE;
constructor(publicbale:ConsoleBit){}
exportconstCREATE_CONSOLE="[Createaction]CreateConsole";
exportclassCreateConsoleimplementsAction{
readonlytype=CREATE_CONSOLE;
constructor(publicbale:ConsoleBit){}
exporttypeActions=|InitConsole|UpdateConsole
|ReadConsole
|WriteConsole
|RemoveConsole
|DeleteConsole
|CreateConsole
export{initConsole}from"./buz/console.buzz";
export{updateConsole}from"./buz/console.buzz";
export{readConsole}from"./buz/console.buzz";
export{writeConsole}from"./buz/console.buzz";
export{removeConsole}from"./buz/console.buzz";
export{deleteConsole}from"./buz/console.buzz";
export{createConsole}from"./buz/console.buzz";
importConsolefrom"./fce/console.interface";
importConsoleBitfrom"./fce/console.interface";
exportclassConsoleModelimplementsConsole{
import*asclonefrom"clone-deep";
import*asActfrom"./console.action";
import{ConsoleModel}from"./console.model";
import*asBuzzfrom"./console.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:ConsoleModel=newConsoleModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.UPDATE_CONSOLE:
returnBuzz.updateConsole(clone(model),act.bale,state);
caseAct.INIT_CONSOLE:
returnBuzz.initConsole(clone(model),act.bale,state);
caseAct.READ_CONSOLE:
returnBuzz.readConsole(clone(model),act.bale,state);
caseAct.WRITE_CONSOLE:
returnBuzz.writeConsole(clone(model),act.bale,state);
caseAct.REMOVE_CONSOLE:
returnBuzz.removeConsole(clone(model),act.bale,state);
caseAct.DELETE_CONSOLE:
returnBuzz.deleteConsole(clone(model),act.bale,state);
caseAct.CREATE_CONSOLE:
returnBuzz.createConsole(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassConsoleUnit{
constructor(state:State){
importTermBitfrom"./term.bit";
exportdefaultinterfaceConsoleBit{
idx:string;
src?:string;
lst?:any[];
val?:number;
dat?:any;
slv?:Function;
net:any;
trm?:TermBit
importConsoleBitfrom"./console.bit";
exportdefaultinterfaceConsole{
exportdefaultinterfaceTermBit{
idx:string;
clr:string;
bit:any;
net:any;
import{InputModel}from"../input.model";
importInputBitfrom"../fce/input.bit";
importStatefrom"../../99.core/state";
importNetBitfrom"../../81.grid.unit/fce/net.bit";
import*asAlignfrom'../../val/align'
import*asColorfrom'../../val/console-color';
exportconstinitInput=(cpy:InputModel,bal:InputBit,ste:State)=>{
debugger
exportconstupdateInput=(cpy:InputModel,bal:InputBit,ste:State)=>{
exportconstopenInput=(cpy:InputModel,bal:InputBit,ste:State)=>{
letblessed=ste.value.terminal.blessed;
letscreen=ste.value.terminal.screen
vardat={idx:'input-bit',clr0:Color.GREEN,clr1:Color.CYAN}
for(varkeyinbal.dat){dat[key]=bal.dat[key]}
letnet:NetBit=bal.net;
if(bal.txt==null)bal.txt='inputbelow'
vartitle=blessed.textbox({
parent:screen,
name:'input',
keys:true,
left:net.left,
top:1,
width:net.width,
height:2,
content:'rename',
border:{type:'line'},
label:bal.txt,
style:{
});
varinput=blessed.textbox({
parent:screen,
name:'input',
input:true,
keys:true,
left:net.left,
top:net.top,
width:net.width,
height:net.height,
inputOnFocus:true,
style:{
bg:dat.clr1,
focus:{
bg:'red'
hover:{
bg:'red'
});
input.focus();
input.on("submit",(src)=>{
if(bal.slv!=null)bal.slv({putBit:{idx:"open-input",src}});
exportdefaultinterfaceInputBit{
idx:string;
src?:string;
lst?:any[];
val?:number;
txt?:string;
dat?:any;
net?:any;
slv?:Function;
importInputBitfrom"./input.bit";
exportdefaultinterfaceInput{
import{Action}from"../99.core/interface/action.interface";
importInputBitfrom"./fce/input.bit";
exportconstINIT_INPUT="[Inputaction]InitInput";
exportclassInitInputimplementsAction{
readonlytype=INIT_INPUT;
constructor(publicbale:InputBit){}
exportconstUPDATE_INPUT="[Inputaction]UpdateInput";
exportclassUpdateInputimplementsAction{
readonlytype=UPDATE_INPUT;
constructor(publicbale:InputBit){}
exportconstOPEN_INPUT="[Openaction]OpenInput";
exportclassOpenInputimplementsAction{
readonlytype=OPEN_INPUT;
constructor(publicbale:InputBit){}
exporttypeActions=|InitInput|UpdateInput
|OpenInput
export{initInput}from"./buz/input.buzz";
export{updateInput}from"./buz/input.buzz";
export{openInput}from"./buz/input.buzz";
importInputfrom"./fce/input.interface";
importInputBitfrom"./fce/input.interface";
exportclassInputModelimplementsInput{
import*asclonefrom"clone-deep";
import*asActfrom"./input.action";
import{InputModel}from"./input.model";
import*asBuzzfrom"./input.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:InputModel=newInputModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.UPDATE_INPUT:
returnBuzz.updateInput(clone(model),act.bale,state);
caseAct.INIT_INPUT:
returnBuzz.initInput(clone(model),act.bale,state);
caseAct.OPEN_INPUT:
returnBuzz.openInput(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassInputUnit{
constructor(state:State){
import{ChoiceModel}from"../choice.model";
importChoiceBitfrom"../fce/choice.bit";
importStatefrom"../../99.core/state";
importNetBitfrom"../../81.grid.unit/fce/net.bit";
import*asAlignfrom'../../val/align'
import*asColorfrom'../../val/console-color';
exportconstinitChoice=(cpy:ChoiceModel,bal:ChoiceBit,ste:State)=>{
debugger
exportconstupdateChoice=(cpy:ChoiceModel,bal:ChoiceBit,ste:State)=>{
exportconstopenChoice=(cpy:ChoiceModel,bal:ChoiceBit,ste:State)=>{
letblessed=ste.value.terminal.blessed;
letscreen=ste.value.terminal.screen;
vardat={idx:'choice-bit',clr0:Color.GREEN,clr1:Color.CYAN}
for(varkeyinbal.dat){dat[key]=bal.dat[key]}
letnet:NetBit=bal.net;
varform=blessed.form({
parent:screen,
keys:true,
left:net.left,
top:net.top,
width:net.width,
height:net.height,
bg:dat.clr0,
content:''
});
if(bal.lst==null)bal.lst=[];
varoutput=[];
bal.lst.forEach((a,b)=>{
letbtn=blessed.button({
parent:form,
mouse:true,
keys:true,
shrink:true,
padding:{
left:10,
right:1
left:0,
top:b,
height:1,
width:'100%',
name:a,
content:a,
style:{
bg:dat.clr1,
focus:{
bg:'red'
hover:{
bg:'red'
});
btn.on('press',function(){
form.submit();
});
output.push(btn)
screen.key('left',()=>form.focusPrevious())
screen.key('right',()=>form.focusNext())
output[0].focus();
screen.render();
form.on('submit',asyncfunction(data){
letselected=form._selected;
if(selected==null){
output
selected=output[0];
selected.content
letsrc=selected.content;
letval=selected.index-1;
screen.render();
if(bal.slv!=null)bal.slv({chcBit:{idx:"open-choice",src,val}});
});
exportconstkeyChoice=(cpy:ChoiceModel,bal:ChoiceBit,ste:State)=>{
letblessed=ste.value.terminal.blessed;
letscreen=ste.value.terminal.screen;
letnet:NetBit=bal.net;
letmenubar=blessed.listbar({
parent:screen,
keys:true,
left:net.left,
top:net.top,
width:net.width,
height:net.height,
style:{item:{fg:"yellow"},selected:{fg:"yellow"}},
commands:{
Login:{
keys:["l","L"],
callback:()=>{
debugger
"ToggleAutotrading":{
keys:["a","A"],
callback:()=>{
debugger
"MakeaTrade":{
keys:["t","T"],
callback:()=>{
debugger
Help:{
keys:["h","H"],
callback:()=>{
debugger
Logout:{
keys:["o","O"],
callback:()=>{debugger}
Exit:{
keys:["C-c","escape"],
callback:()=>process.exit(0)
});
screen.render();
if(bal.slv!=null)bal.slv({scnBit:{idx:"key-choice"}});
exportconsttowerChoice=(cpy:ChoiceModel,bal:ChoiceBit,ste:State)=>{
import{Action}from"../99.core/interface/action.interface";
importChoiceBitfrom"./fce/choice.bit";
exportconstINIT_CHOICE="[Choiceaction]InitChoice";
exportclassInitChoiceimplementsAction{
readonlytype=INIT_CHOICE;
constructor(publicbale:ChoiceBit){}
exportconstUPDATE_CHOICE="[Choiceaction]UpdateChoice";
exportclassUpdateChoiceimplementsAction{
readonlytype=UPDATE_CHOICE;
constructor(publicbale:ChoiceBit){}
exportconstOPEN_CHOICE="[Openaction]OpenChoice";
exportclassOpenChoiceimplementsAction{
readonlytype=OPEN_CHOICE;
constructor(publicbale:ChoiceBit){}
exportconstKEY_CHOICE="[Keyaction]KeyChoice";
exportclassKeyChoiceimplementsAction{
readonlytype=KEY_CHOICE;
constructor(publicbale:ChoiceBit){}
exportconstTOWER_CHOICE="[Toweraction]TowerChoice";
exportclassTowerChoiceimplementsAction{
readonlytype=TOWER_CHOICE;
constructor(publicbale:ChoiceBit){}
exporttypeActions=|InitChoice|UpdateChoice
|OpenChoice
|KeyChoice
|TowerChoice
export{initChoice}from"./buz/choice.buzz";
export{updateChoice}from"./buz/choice.buzz";
export{openChoice}from"./buz/choice.buzz";
export{keyChoice}from"./buz/choice.buzz";
export{towerChoice}from"./buz/choice.buzz";
importChoicefrom"./fce/choice.interface";
importChoiceBitfrom"./fce/choice.interface";
exportclassChoiceModelimplementsChoice{
import*asclonefrom"clone-deep";
import*asActfrom"./choice.action";
import{ChoiceModel}from"./choice.model";
import*asBuzzfrom"./choice.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:ChoiceModel=newChoiceModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.UPDATE_CHOICE:
returnBuzz.updateChoice(clone(model),act.bale,state);
caseAct.INIT_CHOICE:
returnBuzz.initChoice(clone(model),act.bale,state);
caseAct.OPEN_CHOICE:
returnBuzz.openChoice(clone(model),act.bale,state);
caseAct.KEY_CHOICE:
returnBuzz.keyChoice(clone(model),act.bale,state);
caseAct.TOWER_CHOICE:
returnBuzz.towerChoice(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassChoiceUnit{
constructor(state:State){
importNetBitfrom"../../81.grid.unit/fce/net.bit";
exportdefaultinterfaceChoiceBit{
idx:string;
src?:string;
clr?:string;
lst?:any[];
val?:number;
dat?:any;
slv?:Function;
net?:NetBit
importChoiceBitfrom"./choice.bit";
exportdefaultinterfaceChoice{
exportconstinitContainer=(cpy:ContainerModel,bal:ContainerBit,ste:State)=>{
debugger
exportconstupdateContainer=(cpy:ContainerModel,bal:ContainerBit,ste:State)=>{
import{ContainerModel}from"../container.model";
importContainerBitfrom"../fce/container.bit";
importStatefrom"../../99.core/state";
import{Action}from"../99.core/interface/action.interface";
importContainerBitfrom"./fce/container.bit";
exportconstINIT_CONTAINER="[Containeraction]InitContainer";
exportclassInitContainerimplementsAction{
readonlytype=INIT_CONTAINER;
constructor(publicbale:ContainerBit){}
exportconstUPDATE_CONTAINER="[Containeraction]UpdateContainer";
exportclassUpdateContainerimplementsAction{
readonlytype=UPDATE_CONTAINER;
constructor(publicbale:ContainerBit){}
exporttypeActions=|InitContainer|UpdateContainer;
export{initContainer}from"./buz/container.buzz";
export{updateContainer}from"./buz/container.buzz";
importContainerfrom"./fce/container.interface";
importContainerBitfrom"./fce/container.interface";
exportclassContainerModelimplementsContainer{
import*asclonefrom"clone-deep";
import*asActfrom"./container.action";
import{ContainerModel}from"./container.model";
import*asBuzzfrom"./container.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:ContainerModel=newContainerModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.UPDATE_CONTAINER:
returnBuzz.updateContainer(clone(model),act.bale,state);
caseAct.INIT_CONTAINER:
returnBuzz.initContainer(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassContainerUnit{
constructor(state:State){
exportdefaultinterfaceContainerBit{
idx:string;
importContainerBitfrom"./container.bit";
exportdefaultinterfaceContainer{
exportconstinitGraphic=(cpy:GraphicModel,bal:GraphicBit,ste:State)=>{
debugger
exportconstupdateGraphic=(cpy:GraphicModel,bal:GraphicBit,ste:State)=>{
import{GraphicModel}from"../graphic.model";
importGraphicBitfrom"../fce/graphic.bit";
importStatefrom"../../99.core/state";
exportdefaultinterfaceGraphicBit{
idx:string;
importGraphicBitfrom"./graphic.bit";
exportdefaultinterfaceGraphic{
import{Action}from"../99.core/interface/action.interface";
importGraphicBitfrom"./fce/graphic.bit";
exportconstINIT_GRAPHIC="[Graphicaction]InitGraphic";
exportclassInitGraphicimplementsAction{
readonlytype=INIT_GRAPHIC;
constructor(publicbale:GraphicBit){}
exportconstUPDATE_GRAPHIC="[Graphicaction]UpdateGraphic";
exportclassUpdateGraphicimplementsAction{
readonlytype=UPDATE_GRAPHIC;
constructor(publicbale:GraphicBit){}
exporttypeActions=|InitGraphic|UpdateGraphic;
export{initGraphic}from"./buz/graphic.buzz";
export{updateGraphic}from"./buz/graphic.buzz";
importGraphicfrom"./fce/graphic.interface";
importGraphicBitfrom"./fce/graphic.interface";
exportclassGraphicModelimplementsGraphic{
import*asclonefrom"clone-deep";
import*asActfrom"./graphic.action";
import{GraphicModel}from"./graphic.model";
import*asBuzzfrom"./graphic.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:GraphicModel=newGraphicModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.UPDATE_GRAPHIC:
returnBuzz.updateGraphic(clone(model),act.bale,state);
caseAct.INIT_GRAPHIC:
returnBuzz.initGraphic(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassGraphicUnit{
constructor(state:State){
import*asActCvsfrom"../../82.canvas.unit/canvas.action";
varlst,bit,dat;
exportconstinitHexagon=(cpy:HexagonModel,bal:HexagonBit,ste:State)=>{
debugger
exportconstupdateHexagon=async(cpy:HexagonModel,bal:HexagonBit,ste:State)=>{
lethexmap=bal.bit
bit=awaitste.hunt(ActCvs.READ_CANVAS,{idx:bal.idx})
letdat:FrameBit=bit.cvsBit.dat
letcanvas=dat.bit;
exportconstcreateHexagon=(cpy:HexagonModel,bal:HexagonBit,ste:State)=>{
debugger
exportconstreadHexagon=(cpy:HexagonModel,bal:HexagonBit,ste:State)=>{
debugger
exportconstwriteHexagon=(cpy:HexagonModel,bal:HexagonBit,ste:State)=>{
debugger
exportconstremoveHexagon=(cpy:HexagonModel,bal:HexagonBit,ste:State)=>{
debugger
exportconstdeleteHexagon=(cpy:HexagonModel,bal:HexagonBit,ste:State)=>{
debugger
import{HexagonModel}from"../hexagon.model";
importHexagonBitfrom"../fce/hexagon.bit";
importStatefrom"../../99.core/state";
importFrameBitfrom"../../82.canvas.unit/fce/frame.bit";
import*asHoneycombfrom"honeycomb-grid";
exportdefaultinterfaceHexagonBit{
idx:string;
bit:any;
importHexagonBitfrom"./hexagon.bit";
exportdefaultinterfaceHexagon{
import{Action}from"../99.core/interface/action.interface";
importHexagonBitfrom"./fce/hexagon.bit";
exportconstINIT_HEXAGON="[Hexagonaction]InitHexagon";
exportclassInitHexagonimplementsAction{
readonlytype=INIT_HEXAGON;
constructor(publicbale:HexagonBit){}
exportconstUPDATE_HEXAGON="[Hexagonaction]UpdateHexagon";
exportclassUpdateHexagonimplementsAction{
readonlytype=UPDATE_HEXAGON;
constructor(publicbale:HexagonBit){}
exportconstREAD_HEXAGON="[Readaction]ReadHexagon";
exportclassReadHexagonimplementsAction{
readonlytype=READ_HEXAGON;
constructor(publicbale:HexagonBit){}
exportconstWRITE_HEXAGON="[Writeaction]WriteHexagon";
exportclassWriteHexagonimplementsAction{
readonlytype=WRITE_HEXAGON;
constructor(publicbale:HexagonBit){}
exportconstREMOVE_HEXAGON="[Removeaction]RemoveHexagon";
exportclassRemoveHexagonimplementsAction{
readonlytype=REMOVE_HEXAGON;
constructor(publicbale:HexagonBit){}
exportconstDELETE_HEXAGON="[Deleteaction]DeleteHexagon";
exportclassDeleteHexagonimplementsAction{
readonlytype=DELETE_HEXAGON;
constructor(publicbale:HexagonBit){}
exportconstCREATE_HEXAGON="[Createaction]CreateHexagon";
exportclassCreateHexagonimplementsAction{
readonlytype=CREATE_HEXAGON;
constructor(publicbale:HexagonBit){}
exporttypeActions=|InitHexagon|UpdateHexagon
|ReadHexagon
|WriteHexagon
|RemoveHexagon
|DeleteHexagon
|CreateHexagon
export{initHexagon}from"./buz/hexagon.buzz";
export{updateHexagon}from"./buz/hexagon.buzz";
export{readHexagon}from"./buz/hexagon.buzz";
export{writeHexagon}from"./buz/hexagon.buzz";
export{removeHexagon}from"./buz/hexagon.buzz";
export{deleteHexagon}from"./buz/hexagon.buzz";
export{createHexagon}from"./buz/hexagon.buzz";
importHexagonfrom"./fce/hexagon.interface";
importHexagonBitfrom"./fce/hexagon.interface";
exportclassHexagonModelimplementsHexagon{
import*asclonefrom"clone-deep";
import*asActfrom"./hexagon.action";
import{HexagonModel}from"./hexagon.model";
import*asBuzzfrom"./hexagon.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:HexagonModel=newHexagonModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.UPDATE_HEXAGON:
returnBuzz.updateHexagon(clone(model),act.bale,state);
caseAct.INIT_HEXAGON:
returnBuzz.initHexagon(clone(model),act.bale,state);
caseAct.READ_HEXAGON:
returnBuzz.readHexagon(clone(model),act.bale,state);
caseAct.WRITE_HEXAGON:
returnBuzz.writeHexagon(clone(model),act.bale,state);
caseAct.REMOVE_HEXAGON:
returnBuzz.removeHexagon(clone(model),act.bale,state);
caseAct.DELETE_HEXAGON:
returnBuzz.deleteHexagon(clone(model),act.bale,state);
caseAct.CREATE_HEXAGON:
returnBuzz.createHexagon(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassHexagonUnit{
constructor(state:State){
exportconstinitSprite=(cpy:SpriteModel,bal:SpriteBit,ste:State)=>{
debugger
exportconstupdateSprite=(cpy:SpriteModel,bal:SpriteBit,ste:State)=>{
import{SpriteModel}from"../sprite.model";
importSpriteBitfrom"../fce/sprite.bit";
importStatefrom"../../99.core/state";
exportdefaultinterfaceSpriteBit{
idx:string;
importSpriteBitfrom"./sprite.bit";
exportdefaultinterfaceSprite{
import{Action}from"../99.core/interface/action.interface";
importSpriteBitfrom"./fce/sprite.bit";
exportconstINIT_SPRITE="[Spriteaction]InitSprite";
exportclassInitSpriteimplementsAction{
readonlytype=INIT_SPRITE;
constructor(publicbale:SpriteBit){}
exportconstUPDATE_SPRITE="[Spriteaction]UpdateSprite";
exportclassUpdateSpriteimplementsAction{
readonlytype=UPDATE_SPRITE;
constructor(publicbale:SpriteBit){}
exporttypeActions=|InitSprite|UpdateSprite;
export{initSprite}from"./buz/sprite.buzz";
export{updateSprite}from"./buz/sprite.buzz";
importSpritefrom"./fce/sprite.interface";
importSpriteBitfrom"./fce/sprite.interface";
exportclassSpriteModelimplementsSprite{
import*asclonefrom"clone-deep";
import*asActfrom"./sprite.action";
import{SpriteModel}from"./sprite.model";
import*asBuzzfrom"./sprite.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:SpriteModel=newSpriteModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.UPDATE_SPRITE:
returnBuzz.updateSprite(clone(model),act.bale,state);
caseAct.INIT_SPRITE:
returnBuzz.initSprite(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassSpriteUnit{
constructor(state:State){
import*asActCvsfrom"../../82.canvas.unit/canvas.action";
import*asActTxtfrom"../../90.text.unit/text.action";
import*asActColfrom"../../97.collect.unit/collect.action";
varlst,bit,dat;
exportconstinitText=(cpy:TextModel,bal:TextBit,ste:State)=>{
exportconstupdateText=async(cpy:TextModel,bal:TextBit,ste:State)=>{
bit=awaitste.hunt(ActTxt.READ_TEXT,{idx:bal.idx})
lettxtDat:LineBit=bit.txtBit.dat
bit=awaitste.hunt(ActCvs.READ_CANVAS,{idx:txtDat.src})
dat=bit.cvsBit.dat
letcanvas=dat.bit;
varctx;
if(canvas.ctx)ctx=canvas.ctx;
ctx.strokeStyle=[255,0,0];
ctx.font=txtDat.fnt;
ctx.fillStyle=txtDat.clr;
ctx.fillText(txtDat.txt,txtDat.x,txtDat.y)
letterminal:TerminalModel=ste.value.terminal;
letscreen=terminal.screen
screen.render()
if(bal.slv!=null)returnbal.slv({txtBit:{idx:"update-text",dat:txtDat}});
exportconstcreateText=async(cpy:TextModel,bal:TextBit,ste:State)=>{
vardat:LineBit={idx:bal.idx,src:bal.src,typ:SHADE.TEXT};
if(bal.dat!=null&&bal.dat.src!=null)dat.src=bal.dat.src;
for(varkeyinbal.dat){
dat[key]=bal.dat[key]
if(dat.txt==null)dat.txt='createtext';
if(dat.x==null)dat.x=0;
if(dat.y==null)dat.y=0;
if(dat.fnt==null)dat.fnt="60ptCalibri";
if(dat.wrp==null)dat.wrp=300;
if(dat.a==null)dat.a=1;
if(dat.clr==null)dat.clr=COLOR.WHITE;
dat
if(dat.src!=null)bit=awaitste.hunt(ActCvs.NEST_CANVAS,{src:dat.src,dat})
if(bal.slv!=null)returnbal.slv({txtBit:{idx:"create-text",dat}});
exportconstwriteText=async(cpy:TextModel,bal:TextBit,ste:State)=>{
varslv=bal.slv;
if(bal.idx==null)bal.idx='txt00';
bit=awaitste.hunt(ActCol.WRITE_COLLECT,{idx:bal.idx,src:bal.src,bit:ActTxt.CREATE_TEXT,dat:bal.dat})
vartxtBit:LineBit=bit.clcBit.dat
ste.hunt(ActCvs.UPDATE_CANVAS,{idx:txtBit.src})
if(slv!=null)slv({txtBit:{idx:"read-text",dat:bit.clcBit.dat}});
exportconstreadText=async(cpy:TextModel,bal:TextBit,ste:State)=>{
bit=awaitste.hunt(ActCol.READ_COLLECT,{idx:bal.idx,src:bal.src,dat:bal.dat,bit:ActTxt.CREATE_TEXT})
if(bal.slv!=null)bal.slv({txtBit:{idx:"write-text",dat:bit.clcBit.dat}});
exportconstremoveText=async(cpy:TextModel,bal:TextBit,ste:State)=>{
bit=awaitste.hunt(ActCol.REMOVE_COLLECT,{idx:bal.idx,src:bal.src,dat:bal.dat,bit:ActTxt.CREATE_TEXT})
if(bal.slv!=null)bal.slv({txtBit:{idx:"remove-text",dat:bit.clcBit}});
exportconstdeleteText=(cpy:TextModel,bal:TextBit,ste:State)=>{
debugger
import{TextModel}from"../text.model";
importTextBitfrom"../fce/text.bit";
importStatefrom"../../99.core/state";
importLineBitfrom"../fce/line.bit"
import*asSHADEfrom'../../val/shade'
import*asCOLORfrom'../../val/console-color'
import{TerminalModel}from"../../80.terminal.unit/terminal.model";
exportdefaultinterfaceLineBit{
idx:string;
src?:string;
typ?:string;
can?:string;
dat?:any;
txt?:string;
clr?:string;
fnt?:string;
wrp?:number;
sze?:number;
w?:number;
h?:number;
x?:number;
y?:number;
a?:number;
exportdefaultinterfaceTextBit{
idx:string;
src?:string;
lst?:any[];
val?:number;
dat?:any;
slv?:Function;
importTextBitfrom"./text.bit";
exportdefaultinterfaceText{
import{Action}from"../99.core/interface/action.interface";
importTextBitfrom"./fce/text.bit";
exportconstINIT_TEXT="[Textaction]InitText";
exportclassInitTextimplementsAction{
readonlytype=INIT_TEXT;
constructor(publicbale:TextBit){}
exportconstUPDATE_TEXT="[Textaction]UpdateText";
exportclassUpdateTextimplementsAction{
readonlytype=UPDATE_TEXT;
constructor(publicbale:TextBit){}
exportconstWRITE_TEXT="[Writeaction]WriteText";
exportclassWriteTextimplementsAction{
readonlytype=WRITE_TEXT;
constructor(publicbale:TextBit){}
exportconstREAD_TEXT="[Readaction]ReadText";
exportclassReadTextimplementsAction{
readonlytype=READ_TEXT;
constructor(publicbale:TextBit){}
exportconstREMOVE_TEXT="[Removeaction]RemoveText";
exportclassRemoveTextimplementsAction{
readonlytype=REMOVE_TEXT;
constructor(publicbale:TextBit){}
exportconstDELETE_TEXT="[Deleteaction]DeleteText";
exportclassDeleteTextimplementsAction{
readonlytype=DELETE_TEXT;
constructor(publicbale:TextBit){}
exportconstCREATE_TEXT="[Createaction]CreateText";
exportclassCreateTextimplementsAction{
readonlytype=CREATE_TEXT;
constructor(publicbale:TextBit){}
exporttypeActions=|InitText|UpdateText
|WriteText
|ReadText
|RemoveText
|DeleteText
|CreateText
export{initText}from"./buz/text.buzz";
export{updateText}from"./buz/text.buzz";
export{writeText}from"./buz/text.buzz";
export{readText}from"./buz/text.buzz";
export{removeText}from"./buz/text.buzz";
export{deleteText}from"./buz/text.buzz";
export{createText}from"./buz/text.buzz";
importTextfrom"./fce/text.interface";
importTextBitfrom"./fce/text.interface";
exportclassTextModelimplementsText{
import*asclonefrom"clone-deep";
import*asActfrom"./text.action";
import{TextModel}from"./text.model";
import*asBuzzfrom"./text.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:TextModel=newTextModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.UPDATE_TEXT:
returnBuzz.updateText(clone(model),act.bale,state);
caseAct.INIT_TEXT:
returnBuzz.initText(clone(model),act.bale,state);
caseAct.WRITE_TEXT:
returnBuzz.writeText(clone(model),act.bale,state);
caseAct.READ_TEXT:
returnBuzz.readText(clone(model),act.bale,state);
caseAct.REMOVE_TEXT:
returnBuzz.removeText(clone(model),act.bale,state);
caseAct.DELETE_TEXT:
returnBuzz.deleteText(clone(model),act.bale,state);
caseAct.CREATE_TEXT:
returnBuzz.createText(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassTextUnit{
constructor(state:State){
import*asActColfrom'../../97.collect.unit/collect.action';
varbit,lst,dat,idx,val,src,dex;
exportconstinitCollect=(cpy:CollectModel,bal:CollectBit,ste:State)=>{
exportconstupdateCollect=(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
exportconstfetchCollect=(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
if(bal.val==null)bal.val=1;
if(bal.bit==null)
bal.slv({clcBit:{idx:'fetch-collect-err',src:'no-bit'}});
vartype=bal.bit.split('').slice(-1).pop().toLowerCase();
varcabBit:CaboodleBit=cpy.caboodleBitList[cpy.caboodleBits[type]];
if(bal.val==1)bit=cabBit.bitList[0];
elsebit=cabBit;
if(bal.slv!=null)bal.slv({clcBit:{idx:'fetch-collect',dat:bit}});
exportconstreadCollect=async(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
if(bal.bit==null)
bal.slv({clcBit:{idx:'read-collect-err',src:'no-bit'}});
vartype=bal.bit.split('').slice(-1).pop().toLowerCase();
if(cpy.caboodleBits[type]==null)createCollect(cpy,{idx:type},ste);
varcabBit:CaboodleBit=cpy.caboodleBitList[cpy.caboodleBits[type]];
if(cabBit.bits[bal.idx]==null){
bit=awaitste.hunt(ActCol.WRITE_COLLECT,{
idx:bal.idx,
src:bal.src,
bit:bal.bit,
});
}else{
dat=cabBit.bitList[cabBit.bits[bal.idx]];
if(bal.slv!=null)bal.slv({clcBit:{idx:'read-collect',dat}});
exportconstwriteCollect=async(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
dat=null;
vartype=bal.bit.split('').slice(-1).pop().toLowerCase();
if(cpy.caboodleBits[type]==null)createCollect(cpy,{idx:type},ste);
if(bal.bit==null)
bal.slv({rskBit:{idx:'write-collect-err',src:'no-bit'}});
varcabBit:CaboodleBit=cpy.caboodleBitList[cpy.caboodleBits[type]];
bal.idx;
val=0;
if(cabBit.bits[bal.idx]==null){
bit=awaitste.hunt(bal.bit,{idx:bal.idx,src:bal.src,dat:bal.dat});
varobjDat=bit[Object.keys(bit)[0]];
dat=objDat.dat;
if(dat==null)dat={};
dat.dex=cabBit.bitList.length;
cabBit.bitList.push(dat);
varidx=bal.idx;
if(idx==null)idx=dat.idx;
if(idx==null)thrownewError('writecollecthasnoidx');
cabBit.bits[idx]=dat.dex;
}else{
varcabDat=cabBit.bitList[cabBit.bits[bal.idx]];
bal.dat;
val=1;
for(varkeyinbal.dat){
if(cabDat==null)cabDat={};
cabDat[key]=bal.dat[key];
cabBit.bitList[cabBit.bits[bal.idx]]=cabDat;
dat=cabDat;
if(dat==null&&bal.slv!=null)
bal.slv({rskBit:{idx:'write-collect-err',src:'no-dat'}});
if(bal.slv!=null)bal.slv({clcBit:{idx:'write-collect',val,dat}});
exportconstcreateCollect=(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
varcabBit:CaboodleBit={idx:bal.idx,dex:0,bits:{},bitList:[]};
cabBit.dex=cpy.caboodleBitList.length;
cpy.caboodleBitList.push(cabBit);
cpy.caboodleBits[cabBit.idx]=cabBit.dex;
if(bal.slv!=null)
bal.slv({clcBit:{idx:'create-collect',dat:cabBit}});
exportconstremoveCollect=async(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
vartype=bal.bit.split('').slice(-1).pop().toLowerCase();
if(cpy.caboodleBits[type]==null)
returnbal.slv({rskBit:{idx:'remove-collect-not-present'}});
varcabBit:CaboodleBit=cpy.caboodleBitList[cpy.caboodleBits[type]];
if(cabBit.bits[bal.idx]==null)
returnbal.slv({rskBit:{idx:'remove-collect-idx-not-present'}});
bit=awaitste.hunt(bal.bit,{idx:bal.idx,src:bal.src,dat:bal.dat});
varobjDat=bit[Object.keys(bit)[0]];
dat=objDat.dat;
dex=dat.dex;
for(vari=dex;i<cabBit.bitList.length-1;i++){
varupdate=cabBit.bitList[i];
update.dex-=1;
for(varkeyindat){
dat[key]=null;
deletecabBit.bits[bal.idx];
varitm=cabBit.bitList.splice(dex,1);
cabBit.dex-=1;
if(bal.slv!=null)
bal.slv({clcBit:{idx:'remove-collect',dat:itm[0]}});
exportconstputCollect=(cpy:CollectModel,bal:CollectBit,ste:State)=>{
cpy.caboodleBits[bal.idx]=bal.val;
cpy.caboodleBitList[bal.val]=bal.dat;
if(bal.slv!=null)
bal.slv({clcBit:{idx:'put-collect',dat:bal.dat}});
exportconstgetCollect=(cpy:CollectModel,bal:CollectBit,ste:State)=>{
val=cpy.caboodleBits[bal.idx];
dat=cpy.caboodleBitList[val];
if(bal.slv!=null)bal.slv({clcBit:{idx:'get-collect',val,dat}});
exportconstmodelCollect=(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
if(bal.slv!=null)bal.slv({clcBit:{idx:'model-collect',dat:cpy}});
exportconstdeleteCollect=(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
exportconstemptyCollect=(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
exportconstdotCollect=(cpy:CollectModel,bal:CollectBit,ste:State)=>{
vargel=bal.dat;
varout=[];
bal.src.split('\n').forEach((a,b)=>{
vardoTCompiled=doT.template(a);
varoutLine=doTCompiled(gel);
out.push(outLine);
});
if(bal.slv!=null)
bal.slv({clcBit:{idx:'dot-vurt',lst:out,src:out.join('\n')}});
exportconstformatCollect=(
cpy:CollectModel,
bal:CollectBit,
ste:State,
)=>{
lst=bal.src.split(':');
varidx=lst[0];
varout=[];
idx=S(idx).collapseWhitespace().s;
varopt=lst[1].split(',');
opt.forEach((a,b)=>{
varnow=S(a).collapseWhitespace().s;
if(a.length<1)return;
out.push(now);
});
dat=[idx,out];
bal.slv({clcBit:{idx:'format-collect',dat}});
exportconstlistCollect=(cpy:CollectModel,bal:CollectBit,ste:State)=>{
vartype=bal.bit.split('').slice(-1).pop().toLowerCase();
if(cpy.caboodleBits[type]==null)createCollect(cpy,{idx:type},ste);
varcabBit:CaboodleBit=cpy.caboodleBitList[cpy.caboodleBits[type]];
lst=[];
cabBit.bitList.forEach((a)=>{
if(a.idx!=null)lst.push(a.idx);
if(a.id!=null)lst.push(a.id);
});
bal.slv({clcBit:{idx:'list-collect',lst}});
exportconstselectCollect=(cpy:CollectModel,bal:CollectBit,ste:State)=>{
varChance=require('chance');
varchance=newChance();
dat=chance.pickone(bal.lst)
bal.slv({clcBit:{idx:'select-collect',dat}});
exportconsthashCollect=(cpy:CollectModel,bal:CollectBit,ste:State)=>{
if(bal.src==null)bal.src='';
lst=bal.src.split('\n');
dat={};
lst.forEach((a)=>{
a=S(a).collapseWhitespace().s;
if(a.length<3)return;
if(a[0]=='-')return
varhold=a.split(':');
vardom=hold[0];
varsub=hold[1];
varnow=sub.split(',');
now.forEach((b,c)=>{
now[c]=S(b).collapseWhitespace().s;
});
dat[dom]=now;
});
bal.slv({clcBit:{idx:'hash-collect',dat}});
import{CollectModel}from'../collect.model';
importCollectBitfrom'../fce/collect.bit';
importStatefrom'../../99.core/state';
importCaboodleBitfrom'../fce/caboodle.bit';
import*asSfrom'string';
import*asdoTfrom'dot';
import{Action}from"../99.core/interface/action.interface";
importCollectBitfrom"./fce/collect.bit";
exportconstINIT_COLLECT="[Collectaction]InitCollect";
exportclassInitCollectimplementsAction{
readonlytype=INIT_COLLECT;
constructor(publicbale:CollectBit){}
exportconstUPDATE_COLLECT="[Collectaction]UpdateCollect";
exportclassUpdateCollectimplementsAction{
readonlytype=UPDATE_COLLECT;
constructor(publicbale:CollectBit){}
exportconstFETCH_COLLECT="[Collectaction]FetchCollect";
exportclassFetchCollectimplementsAction{
readonlytype=FETCH_COLLECT;
constructor(publicbale:CollectBit){}
exportconstREAD_COLLECT="[Readaction]ReadCollect";
exportclassReadCollectimplementsAction{
readonlytype=READ_COLLECT;
constructor(publicbale:CollectBit){}
exportconstWRITE_COLLECT="[Writeaction]WriteCollect";
exportclassWriteCollectimplementsAction{
readonlytype=WRITE_COLLECT;
constructor(publicbale:CollectBit){}
exportconstCREATE_COLLECT="[Createaction]CreateCollect";
exportclassCreateCollectimplementsAction{
readonlytype=CREATE_COLLECT;
constructor(publicbale:CollectBit){}
exportconstREMOVE_COLLECT="[Createaction]RemoveCollect";
exportclassRemoveCollectimplementsAction{
readonlytype=REMOVE_COLLECT;
constructor(publicbale:CollectBit){}
exportconstDELETE_COLLECT="[Createaction]DeleteCollect";
exportclassDeleteCollectimplementsAction{
readonlytype=DELETE_COLLECT;
constructor(publicbale:CollectBit){}
exportconstEMPTY_COLLECT="[Emptyaction]EmptyCollect";
exportclassEmptyCollectimplementsAction{
readonlytype=EMPTY_COLLECT;
constructor(publicbale:CollectBit){}
exportconstMODEL_COLLECT="[Emptyaction]ModelCollect";
exportclassModelCollectimplementsAction{
readonlytype=MODEL_COLLECT;
constructor(publicbale:CollectBit){}
exportconstPUT_COLLECT="[Emptyaction]PutCollect";
exportclassPutCollectimplementsAction{
readonlytype=PUT_COLLECT;
constructor(publicbale:CollectBit){}
exportconstGET_COLLECT="[Emptyaction]GetCollect";
exportclassGetCollectimplementsAction{
readonlytype=GET_COLLECT;
constructor(publicbale:CollectBit){}
exportconstFORMAT_COLLECT="[Formataction]FormatCollect";
exportclassFormatCollectimplementsAction{
readonlytype=FORMAT_COLLECT;
constructor(publicbale:CollectBit){}
exportconstDOT_COLLECT="[Formataction]DotCollect";
exportclassDotCollectimplementsAction{
readonlytype=DOT_COLLECT;
constructor(publicbale:CollectBit){}
exportconstLIST_COLLECT="[Listaction]ListCollect";
exportclassListCollectimplementsAction{
readonlytype=LIST_COLLECT;
constructor(publicbale:CollectBit){}
exportconstHASH_COLLECT="[Hashaction]HashCollect";
exportclassHashCollectimplementsAction{
readonlytype=HASH_COLLECT;
constructor(publicbale:CollectBit){}
exportconstSELECT_COLLECT="[Hashaction]SelectCollect";
exportclassSelectCollectimplementsAction{
readonlytype=SELECT_COLLECT;
constructor(publicbale:CollectBit){}
exporttypeActions=|InitCollect|UpdateCollect
|ReadCollect
|WriteCollect
|CreateCollect
|EmptyCollect
|FetchCollect
|DeleteCollect
|RemoveCollect
|ModelCollect
|GetCollect
|PutCollect
|FormatCollect
|DotCollect
|ListCollect
|HashCollect
|SelectCollect
export{initCollect}from"./buz/collect.buzz";
export{updateCollect}from"./buz/collect.buzz";
export{readCollect}from"./buz/collect.buzz";
export{writeCollect}from"./buz/collect.buzz";
export{createCollect}from"./buz/collect.buzz";
export{emptyCollect}from"./buz/collect.buzz";
export{fetchCollect}from"./buz/collect.buzz";
export{deleteCollect}from"./buz/collect.buzz";
export{removeCollect}from"./buz/collect.buzz";
export{modelCollect}from"./buz/collect.buzz";
export{putCollect}from"./buz/collect.buzz";
export{getCollect}from"./buz/collect.buzz";
export{formatCollect}from"./buz/collect.buzz";
export{dotCollect}from"./buz/collect.buzz";
export{listCollect}from"./buz/collect.buzz";
export{hashCollect}from"./buz/collect.buzz";
export{selectCollect}from"./buz/collect.buzz";
importCaboodleBitfrom"./fce/caboodle.bit";
importCollectfrom"./fce/collect.interface";
importCollectBitfrom"./fce/collect.interface";
exportclassCollectModelimplementsCollect{
idx:string='23.11.14';
caboodleBitList:CaboodleBit[]=[];
caboodleBits:any={};
import*asclonefrom"clone-deep";
import*asActfrom"./collect.action";
import{CollectModel}from"./collect.model";
import*asBuzzfrom"./collect.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:CollectModel=newCollectModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.UPDATE_COLLECT:
returnBuzz.updateCollect(clone(model),act.bale,state);
caseAct.INIT_COLLECT:
returnBuzz.initCollect(clone(model),act.bale,state);
caseAct.READ_COLLECT:
returnBuzz.readCollect(clone(model),act.bale,state);
caseAct.WRITE_COLLECT:
returnBuzz.writeCollect(clone(model),act.bale,state);
caseAct.CREATE_COLLECT:
returnBuzz.createCollect(clone(model),act.bale,state);
caseAct.DELETE_COLLECT:
returnBuzz.deleteCollect(clone(model),act.bale,state);
caseAct.REMOVE_COLLECT:
returnBuzz.removeCollect(clone(model),act.bale,state);
caseAct.EMPTY_COLLECT:
returnBuzz.emptyCollect(clone(model),act.bale,state);
caseAct.FETCH_COLLECT:
returnBuzz.fetchCollect(clone(model),act.bale,state);
caseAct.MODEL_COLLECT:
returnBuzz.modelCollect(clone(model),act.bale,state);
caseAct.GET_COLLECT:
returnBuzz.getCollect(clone(model),act.bale,state);
caseAct.PUT_COLLECT:
returnBuzz.putCollect(clone(model),act.bale,state);
caseAct.FORMAT_COLLECT:
returnBuzz.formatCollect(clone(model),act.bale,state);
caseAct.DOT_COLLECT:
returnBuzz.dotCollect(clone(model),act.bale,state);
caseAct.LIST_COLLECT:
returnBuzz.listCollect(clone(model),act.bale,state);
caseAct.HASH_COLLECT:
returnBuzz.hashCollect(clone(model),act.bale,state);
caseAct.SELECT_COLLECT:
returnBuzz.selectCollect(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassCollectUnit{
constructor(state:State){
exportdefaultinterfaceCaboodleBit{
idx:string;
dex:number;
bitList:any[];
bits:any;
exportdefaultinterfaceCollectBit{
idx?:string;
src?:string;
val?:number;
dex?:number;
dat?:any;
bit?:any;
slv?:Function;
lst?:any;
importCollectBitfrom"./collect.bit";
importCaboodleBitfrom"./caboodle.bit";
exportdefaultinterfaceCollect{
idx:string;
caboodleBitList:CaboodleBit[];
caboodleBits:any;
import*asActMnufrom"../menu.action";
import*asActLibfrom"../../00.library.unit/library.action";
import*asActClcfrom"../../97.collect.unit/collect.action";
import*asActPutfrom"../../84.input.unit/input.action";
import*asActTrmfrom"../../80.terminal.unit/terminal.action";
import*asActChcfrom"../../85.choice.unit/choice.action";
import*asActGrdfrom"../../81.grid.unit/grid.action";
import*asActCvsfrom"../../82.canvas.unit/canvas.action";
import*asActCnsfrom"../../83.console.unit/console.action";
import{MenuModel}from"../menu.model";
importMenuBitfrom"../fce/menu.bit";
importStatefrom"../../99.core/state";
import*asGridfrom'../../val/grid';
import*asAlignfrom'../../val/align'
import*asColorfrom'../../val/console-color';
import*asSHAPEfrom'../../val/shape'
import*asFOCUSfrom"../../val/focus";
import{list}from"995.library/BEE";
varbit,lst,dex,idx,dat,src,val;
exportconstinitMenu=async(cpy:MenuModel,bal:MenuBit,ste:State)=>{
if(bal==null)bal={idx:null}
bit=awaitste.hunt(ActTrm.INIT_TERMINAL,{});
bit=awaitste.hunt(ActTrm.CLEAR_TERMINAL,{})
bit=awaitste.hunt(ActGrd.UPDATE_GRID,{x:4,y:0,xSpan:1,ySpan:12})
bit=awaitste.hunt(ActCvs.WRITE_CANVAS,{idx:'cvs1',dat:{clr:Color.CYAN,net:bit.grdBit.dat},})
bit=awaitste.hunt(ActGrd.UPDATE_GRID,{x:4,y:0,xSpan:8,ySpan:12})
bit=awaitste.hunt(ActCns.WRITE_CONSOLE,{idx:'cns00',src:"",dat:{net:bit.grdBit.dat,src:"alligaor0"}})
bit=awaitste.hunt(ActCns.UPDATE_CONSOLE,{idx:'cns00',src:"-----------"})
bit=awaitste.hunt(ActCns.UPDATE_CONSOLE,{idx:'cns00',src:"LibraryPIVOTV0"})
bit=awaitste.hunt(ActCns.UPDATE_CONSOLE,{idx:'cns00',src:"-----------"})
varFS=require('fs-extra')
vardat=FS.readJsonSync('./count.output.json')
varlines=dat.lines
bit=awaitste.hunt(ActCns.UPDATE_CONSOLE,{idx:'cns00',src:"linecount"})
bit=awaitste.hunt(ActMnu.PRINT_MENU,{lines})
bit=awaitste.hunt(ActCns.UPDATE_CONSOLE,{idx:'cns00',src:"------------"})
updateMenu(cpy,bal,ste);
exportconstupdateMenu=async(cpy:MenuModel,bal:MenuBit,ste:State)=>{
lst=[ActMnu.CONTROL_MENU,ActMnu.TIME_MENU,ActMnu.SPACE_MENU,ActMnu.PIXEL_MENU,ActLib.COUNT_LIBRARY]
bit=awaitste.hunt(ActGrd.UPDATE_GRID,{x:0,y:4,xSpan:4,ySpan:12})
bit=awaitste.hunt(ActChc.OPEN_CHOICE,{dat:{clr0:Color.BLACK,clr1:Color.YELLOW},src:Align.VERTICAL,lst,net:bit.grdBit.dat})
src=bit.chcBit.src;
switch(src){
caseActLib.COUNT_LIBRARY:
varcountBit=awaitste.hunt(ActLib.COUNT_LIBRARY,{})
setTimeout(async()=>{
bit=awaitste.hunt(ActTrm.CLEAR_TERMINAL,{})
bit=awaitste.hunt(ActMnu.PRINT_MENU,countBit)
updateMenu(cpy,bal,ste);
},11)
break;
caseActMnu.CONTROL_MENU:
bit=awaitste.hunt(ActMnu.CONTROL_MENU,{})
break;
caseActMnu.SPACE_MENU:
bit=awaitste.hunt(ActMnu.SPACE_MENU,{})
break;
caseActMnu.TIME_MENU:
bit=awaitste.hunt(ActMnu.TIME_MENU,{})
break;
caseActMnu.PIXEL_MENU:
bit=awaitste.hunt(ActMnu.PIXEL_MENU,{})
break;
caseActLib.UPDATE_LIBRARY:
ste.hunt(ActCns.UPDATE_CONSOLE,{idx:'cns00',src:"UpdateLibraryPivot"})
bit=awaitste.hunt(ActLib.UPDATE_LIBRARY,{})
bit=awaitste.hunt(ActMnu.PRINT_MENU,bit)
break;
caseActMnu.GITHUB_MENU:
bit=awaitste.hunt(ActMnu.GITHUB_MENU,{})
bit=awaitste.hunt(ActMnu.PRINT_MENU,bit)
bit=awaitste.hunt(ActMnu.UPDATE_MENU)
break;
default:
bit=awaitste.hunt(ActTrm.CLOSE_TERMINAL,{})
break;
setTimeout(()=>{
updateMenu(cpy,bal,ste);
},1111)
exportconsttestMenu=async(cpy:MenuModel,bal:MenuBit,ste:State)=>{
exportconstcloseMenu=async(cpy:MenuModel,bal:MenuBit,ste:State)=>{
awaitste.hunt(ActTrm.CLOSE_TERMINAL,{})
exportconstcreateMenu=(cpy:MenuModel,bal:MenuBit,ste:State)=>{
debugger
exportconstprintMenu=async(cpy:MenuModel,bal:MenuBit,ste:State)=>{
dat=bal;
if(dat==null)returnbal.slv({mnuBit:{idx:"print-menu",dat}});
varitm=JSON.stringify(dat);
lst=itm.split(",");
lst.forEach((a)=>ste.hunt(ActCns.UPDATE_CONSOLE,{idx:"cns00",src:a}));
ste.hunt(ActCns.UPDATE_CONSOLE,{idx:"cns00",src:"------------"});
bal.slv({mnuBit:{idx:"print-menu",dat:itm}});
varpatch=(ste,type,bale)=>ste.dispatch({type,bale});
import{MenuModel}from"../menu.model";
importMenuBitfrom"../fce/menu.bit";
importStatefrom"../../99.core/state";
constpath=require('path');
varexec=require('child_process').exec;
import*asGridfrom'../../val/grid';
import*asAlignfrom'../../val/align'
import*asColorfrom'../../val/console-color';
import*asSHAPEfrom'../../val/shape'
import*asFOCUSfrom"../../val/focus";
import*asActMnufrom"../menu.action";
import*asActCtlfrom"../../act/control.action";
import*asActTrmfrom"../../80.terminal.unit/terminal.action";
import*asActChcfrom"../../85.choice.unit/choice.action";
import*asActPutfrom"../../84.input.unit/input.action";
import*asActGrdfrom"../../81.grid.unit/grid.action";
import*asActCvsfrom"../../82.canvas.unit/canvas.action";
import*asActCnsfrom"../../83.console.unit/console.action";
varbit,lst,dex,idx,dat,src;
varCONTROL;
exportconstcontrolMenu=async(cpy:MenuModel,bal:MenuBit,ste:State)=>{
await(async()=>{
try{
awaitnewPromise<void>((resolve,reject)=>exec('tsc-b000.control',err=>err?reject(err):resolve()));
if(CONTROL==null)CONTROL=require(path.resolve('./dist/000.control/hunt'));
bit=awaitste.hunt(ActMnu.PRINT_MENU,{src:"compiledcontrol"});
}catch(err){
console.error(`execerror:${err}`);
throwerr;
})();
lst=[ActCtl.TEST_CONTROL,ActMnu.UPDATE_MENU]
bit=awaitste.hunt(ActGrd.UPDATE_GRID,{x:0,y:4,xSpan:4,ySpan:12})
bit=awaitste.hunt(ActChc.OPEN_CHOICE,{dat:{clr0:Color.BLACK,clr1:Color.YELLOW},src:Align.VERTICAL,lst,net:bit.grdBit.dat})
src=bit.chcBit.src;
switch(src){
caseActCtl.TEST_CONTROL:
bit=awaitCONTROL.hunt(ActCtl.TEST_CONTROL,{})
bit=awaitste.hunt(ActMnu.PRINT_MENU,bit)
break;
caseActMnu.UPDATE_MENU:
bit=awaitste.hunt(ActMnu.UPDATE_MENU,{})
bit=awaitste.hunt(ActMnu.PRINT_MENU,bit)
break;
default:
bit=awaitste.hunt(ActTrm.CLOSE_TERMINAL,{})
break;
setTimeout(async()=>{
bit=awaitste.hunt(ActMnu.CONTROL_MENU,{})
},333)
varpatch=(ste,type,bale)=>ste.dispatch({type,bale});
import*asActMnufrom"../menu.action";
constpath=require('path');
varexec=require('child_process').exec;
import*asActPxlfrom"../../act/pixel.action";
import{MenuModel}from"../menu.model";
importMenuBitfrom"../fce/menu.bit";
importStatefrom"../../99.core/state";
import*asGridfrom'../../val/grid';
import*asAlignfrom'../../val/align'
import*asColorfrom'../../val/console-color';
import*asSHAPEfrom'../../val/shape'
import*asFOCUSfrom"../../val/focus";
import*asActTrmfrom"../../act/terminal.action";
import*asActChcfrom"../../act/choice.action";111
import*asActGrdfrom"../../act/grid.action";
import*asActCvsfrom"../../act/canvas.action";
import*asActCnsfrom"../../act/console.action";
varbit,lst,dex,idx,dat,src;
varPIXEL;
exportconstpixelMenu=async(cpy:MenuModel,bal:MenuBit,ste:State)=>{
await(async()=>{
try{
awaitnewPromise<void>((resolve,reject)=>exec('tsc-b400.pixel',err=>err?reject(err):resolve()));
if(PIXEL==null)PIXEL=require(path.resolve('./dist/400.pixel/hunt'));
bit=awaitste.hunt(ActMnu.PRINT_MENU,{src:"compiledpixel"});
}catch(err){
console.error(`execerror:${err}`);
throwerr;
})();
lst=[ActPxl.TEST_PIXEL,ActPxl.WRITE_PIXEL,ActMnu.UPDATE_MENU]
bit=awaitste.hunt(ActGrd.UPDATE_GRID,{x:0,y:4,xSpan:4,ySpan:12})
bit=awaitste.hunt(ActChc.OPEN_CHOICE,{dat:{clr0:Color.BLACK,clr1:Color.YELLOW},src:Align.VERTICAL,lst,net:bit.grdBit.dat})
src=bit.chcBit.src;
switch(src){
caseActPxl.WRITE_PIXEL:
bit=awaitPIXEL.hunt(ActPxl.WRITE_PIXEL,{})
bit=awaitste.hunt(ActMnu.PRINT_MENU,bit)
break;
caseActPxl.TEST_PIXEL:
bit=awaitPIXEL.hunt(ActPxl.TEST_PIXEL,{})
bit=awaitste.hunt(ActMnu.PRINT_MENU,bit)
break;
caseActMnu.UPDATE_MENU:
bit=awaitste.hunt(ActMnu.UPDATE_MENU,{})
bit=awaitste.hunt(ActMnu.PRINT_MENU,bit)
break;
default:
bit=awaitste.bus(ActTrm.CLOSE_TERMINAL,{})
break;
varpatch=(ste,type,bale)=>ste.dispatch({type,bale});
constpath=require('path');
import{MenuModel}from"../menu.model";
importMenuBitfrom"../fce/menu.bit";
importStatefrom"../../99.core/state";
import*asActSpcfrom"../../act/space.action";
import*asGridfrom'../../val/grid';
import*asAlignfrom'../../val/align'
import*asColorfrom'../../val/console-color';
import*asSHAPEfrom'../../val/shape'
import*asFOCUSfrom"../../val/focus";
import*asActMnufrom"../menu.action";
import*asActTrmfrom"../../80.terminal.unit/terminal.action";
import*asActChcfrom"../../85.choice.unit/choice.action";
import*asActPutfrom"../../84.input.unit/input.action";
import*asActGrdfrom"../../81.grid.unit/grid.action";
import*asActCvsfrom"../../82.canvas.unit/canvas.action";
import*asActCnsfrom"../../83.console.unit/console.action";
varbit,lst,dex,idx,dat,src;
varSPACE;
exportconstspaceMenu=async(cpy:MenuModel,bal:MenuBit,ste:State)=>{
varexec=require('child_process').exec;
await(async()=>{
try{
awaitnewPromise<void>((resolve,reject)=>exec('tsc-b002.space',err=>err?reject(err):resolve()));
if(SPACE==null)SPACE=require(path.resolve('./dist/002.space/hunt'));
bit=awaitste.hunt(ActMnu.PRINT_MENU,{src:"compiledcontrol"});
}catch(err){
console.error(`execerror:${err}`);
throwerr;
})();
lst=[ActSpc.TEST_SPACE,ActMnu.UPDATE_MENU]
bit=awaitste.hunt(ActGrd.UPDATE_GRID,{x:0,y:4,xSpan:4,ySpan:12})
bit=awaitste.hunt(ActChc.OPEN_CHOICE,{dat:{clr0:Color.BLACK,clr1:Color.YELLOW},src:Align.VERTICAL,lst,net:bit.grdBit.dat})
src=bit.chcBit.src;
switch(src){
caseActSpc.TEST_SPACE:
bit=awaitSPACE.hunt(ActSpc.TEST_SPACE,{})
bit=awaitste.hunt(ActMnu.PRINT_MENU,bit)
break;
caseActMnu.UPDATE_MENU:
bit=awaitste.hunt(ActMnu.UPDATE_MENU,{})
bit=awaitste.hunt(ActMnu.PRINT_MENU,bit)
break;
default:
bit=awaitste.hunt(ActTrm.CLOSE_TERMINAL,{})
break;
setTimeout(async()=>{
bit=awaitste.hunt(ActMnu.SPACE_MENU,{})
},333)
varpatch=(ste,type,bale)=>ste.dispatch({type,bale});
constpath=require('path');
import{MenuModel}from"../menu.model";
importMenuBitfrom"../fce/menu.bit";
importStatefrom"../../99.core/state";
import*asActTmefrom"../../act/time.action";
import*asGridfrom'../../val/grid';
import*asAlignfrom'../../val/align'
import*asColorfrom'../../val/console-color';
import*asSHAPEfrom'../../val/shape'
import*asFOCUSfrom"../../val/focus";
import*asActMnufrom"../menu.action";
import*asActTrmfrom"../../80.terminal.unit/terminal.action";
import*asActChcfrom"../../85.choice.unit/choice.action";
import*asActPutfrom"../../84.input.unit/input.action";
import*asActGrdfrom"../../81.grid.unit/grid.action";
import*asActCvsfrom"../../82.canvas.unit/canvas.action";
import*asActCnsfrom"../../83.console.unit/console.action";
varbit,lst,dex,idx,dat,src;
varTIME;
exportconsttimeMenu=async(cpy:MenuModel,bal:MenuBit,ste:State)=>{
varexec=require('child_process').exec;
await(async()=>{
try{
awaitnewPromise<void>((resolve,reject)=>exec('tsc-b001.time',err=>err?reject(err):resolve()));
if(TIME==null)TIME=require(path.resolve('./dist/001.time/hunt'));
bit=awaitste.hunt(ActMnu.PRINT_MENU,{src:"compiledtime"});
}catch(err){
console.error(`execerror:${err}`);
throwerr;
})();
lst=[ActTme.TEST_TIME,ActMnu.UPDATE_MENU]
bit=awaitste.hunt(ActGrd.UPDATE_GRID,{x:0,y:4,xSpan:4,ySpan:12})
bit=awaitste.hunt(ActChc.OPEN_CHOICE,{dat:{clr0:Color.BLACK,clr1:Color.YELLOW},src:Align.VERTICAL,lst,net:bit.grdBit.dat})
src=bit.chcBit.src;
switch(src){
caseActTme.TEST_TIME:
bit=awaitTIME.hunt(ActTme.TEST_TIME,{})
bit=awaitste.hunt(ActMnu.PRINT_MENU,bit)
break;
caseActMnu.UPDATE_MENU:
bit=awaitste.hunt(ActMnu.UPDATE_MENU,{})
bit=awaitste.hunt(ActMnu.PRINT_MENU,bit)
break;
default:
bit=awaitste.hunt(ActTrm.CLOSE_TERMINAL,{})
break;
setTimeout(async()=>{
bit=awaitste.hunt(ActMnu.SPACE_MENU,{})
},333)
varpatch=(ste,type,bale)=>ste.dispatch({type,bale});
"usestrict";
exports.__esModule=true;
exportdefaultinterfaceMenuBit{
idx:string;
src?:string;
lst?:any;
slv?:Function
"usestrict";
exports.__esModule=true;
importMenuBitfrom"./menu.bit";
exportdefaultinterfaceMenu{
import{Action}from"../99.core/interface/action.interface";
importMenuBitfrom"./fce/menu.bit";
exportconstINIT_MENU="[Menuaction]InitMenu";
exportclassInitMenuimplementsAction{
readonlytype=INIT_MENU;
constructor(publicbale:MenuBit){}
exportconstUPDATE_MENU="[Menuaction]UpdateMenu";
exportclassUpdateMenuimplementsAction{
readonlytype=UPDATE_MENU;
constructor(publicbale:MenuBit){}
exportconstTEST_MENU="[Menuaction]TestMenu";
exportclassTestMenuimplementsAction{
readonlytype=TEST_MENU;
constructor(publicbale:MenuBit){}
exportconstCLOSE_MENU="[Menuaction]CloseMenu";
exportclassCloseMenuimplementsAction{
readonlytype=CLOSE_MENU;
constructor(publicbale:MenuBit){}
exportconstGITHUB_MENU="[Timeaction]GithubMenu";
exportclassGithubMenuimplementsAction{
readonlytype=GITHUB_MENU;
constructor(publicbale:MenuBit){}
exportconstSPACE_MENU="[Menuaction]SpaceMenu";
exportclassSpaceMenuimplementsAction{
readonlytype=SPACE_MENU;
constructor(publicbale:MenuBit){}
exportconstCONTROL_MENU="[Menuaction]ControlMenu";
exportclassControlMenuimplementsAction{
readonlytype=CONTROL_MENU;
constructor(publicbale:MenuBit){}
exportconstPIXEL_MENU="[Menuaction]PixelMenu";
exportclassPixelMenuimplementsAction{
readonlytype=PIXEL_MENU;
constructor(publicbale:MenuBit){}
exportconstTIME_MENU="[Menuaction]TimeMenu";
exportclassTimeMenuimplementsAction{
readonlytype=TIME_MENU;
constructor(publicbale:MenuBit){}
exportconstFOCUS_PLAY_MENU="[Focusaction]FocusPlayMenu";
exportclassFocusPlayMenuimplementsAction{
readonlytype=FOCUS_PLAY_MENU;
constructor(publicbale:MenuBit){}
exportconstUPDATE_FOCUS_PLAY_MENU="[Focusaction]UpdateFocusPlayMenu";
exportclassUpdateFocusPlayMenuimplementsAction{
readonlytype=UPDATE_FOCUS_PLAY_MENU;
constructor(publicbale:MenuBit){}
exportconstCREATE_MENU="[Createaction]CreateMenu";
exportclassCreateMenuimplementsAction{
readonlytype=CREATE_MENU;
constructor(publicbale:MenuBit){}
exportconstHEXMAP_MENU="[Hexmapaction]HexmapMenu";
exportclassHexmapMenuimplementsAction{
readonlytype=HEXMAP_MENU;
constructor(publicbale:MenuBit){}
exportconstCREATE_HEXMAP_MENU="[Hexmapaction]CreateHexmapMenu";
exportclassCreateHexmapMenuimplementsAction{
readonlytype=CREATE_HEXMAP_MENU;
constructor(publicbale:MenuBit){}
exportconstRENDER_MENU="[Renderaction]RenderMenu";
exportclassRenderMenuimplementsAction{
readonlytype=RENDER_MENU;
constructor(publicbale:MenuBit){}
exportconstYIELD_MENU="[Renderaction]YieldMenu";
exportclassYieldMenuimplementsAction{
readonlytype=YIELD_MENU;
constructor(publicbale:MenuBit){}
exportconstPRINT_MENU="[Renderaction]PrintMenu";
exportclassPrintMenuimplementsAction{
readonlytype=PRINT_MENU;
constructor(publicbale:MenuBit){}
exporttypeActions=InitMenu|UpdateMenu|TestMenu|CloseMenu
|GithubMenu
|TimeMenu
|CreateMenu
|HexmapMenu
|RenderMenu
|CreateHexmapMenu
|YieldMenu
|FocusPlayMenu
|UpdateFocusPlayMenu
|PrintMenu
|SpaceMenu
|ControlMenu
|PixelMenu
export{initMenu}from"./buz/00.menu.buzz";
export{updateMenu}from"./buz/00.menu.buzz";
export{testMenu}from"./buz/00.menu.buzz";
export{closeMenu}from"./buz/00.menu.buzz";
export{createMenu}from"./buz/00.menu.buzz";
export{printMenu}from"./buz/00.menu.buzz";
export{spaceMenu}from"./buz/menu.space";
export{pixelMenu}from"./buz/menu.pixel";
export{controlMenu}from"./buz/menu.control";
export{timeMenu}from"./buz/menu.time";
importMenufrom"./fce/menu.interface";
importMenuBitfrom"./fce/menu.interface";
exportclassMenuModelimplementsMenu{
lst:string[]=[]
geoJsonNow:any;
atlasNow:any;
sizeNow:any=0;
mapShape:string='none'
mapNomNow:string='none'
mapDimensions:string='none'
shapeBit:any;
import*asclonefrom"clone-deep";
import*asActfrom"./menu.action";
import{MenuModel}from"./menu.model";
import*asBuzzfrom"./menu.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:MenuModel=newMenuModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.UPDATE_MENU:
returnBuzz.updateMenu(clone(model),act.bale,state);
caseAct.INIT_MENU:
returnBuzz.initMenu(clone(model),act.bale,state);
caseAct.TEST_MENU:
returnBuzz.testMenu(clone(model),act.bale,state);
caseAct.CLOSE_MENU:
returnBuzz.closeMenu(clone(model),act.bale,state);
caseAct.CREATE_MENU:
returnBuzz.createMenu(clone(model),act.bale,state);
caseAct.PRINT_MENU:
returnBuzz.printMenu(clone(model),act.bale,state);
caseAct.PIXEL_MENU:
returnBuzz.pixelMenu(clone(model),act.bale,state);
caseAct.SPACE_MENU:
returnBuzz.spaceMenu(clone(model),act.bale,state);
caseAct.CONTROL_MENU:
returnBuzz.controlMenu(clone(model),act.bale,state);
caseAct.TIME_MENU:
returnBuzz.timeMenu(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassMenuUnit{
constructor(state:State){
import{Action}from"../99.core/interface/action.interface";
importBusBitfrom"./fce/bus.bit";
exportconstINIT_BUS="[Busaction]InitBus";
exportclassInitBusimplementsAction{
readonlytype=INIT_BUS;
constructor(publicbale:BusBit){}
exportconstOPEN_BUS="[Busaction]OpenBus";
exportclassOpenBusimplementsAction{
readonlytype=OPEN_BUS;
constructor(publicbale:BusBit){}
exportconstCONNECT_BUS="[Busaction]ConnectBus";
exportclassConnectBusimplementsAction{
readonlytype=CONNECT_BUS;
constructor(publicbale:BusBit){}
exportconstMESSAGE_BUS="[Busaction]MessageBus";
exportclassMessageBusimplementsAction{
readonlytype=MESSAGE_BUS;
constructor(publicbale:BusBit){}
exportconstUPDATE_BUS="[Busaction]UpdateBus";
exportclassUpdateBusimplementsAction{
readonlytype=UPDATE_BUS;
constructor(publicbale:BusBit){}
exportconstCREATE_BUS="[Busaction]CreateBus";
exportclassCreateBusimplementsAction{
readonlytype=CREATE_BUS;
constructor(publicbale:BusBit){}
exporttypeActions=|InitBus|OpenBus|UpdateBus|ConnectBus|MessageBus|CreateBus;
export{initBus}from"./buz/bus.buzz";
export{openBus}from"./buz/bus.buzz";
export{updateBus}from"./buz/bus.buzz";
export{connectBus}from"./buz/bus.buzz";
export{messageBus}from"./buz/bus.buzz";
export{createBus}from"./buz/bus.buzz";
importBusfrom"./fce/bus.interface";
importBusBitfrom"./fce/bus.interface";
exportclassBusModelimplementsBus{
MQTT:any;
actList:any;
client:any;
bus:Function;
responseSuffix:string='-response'
promises:any={}
import*asclonefrom"clone-deep";
import*asActfrom"./bus.action";
import{BusModel}from"./bus.model";
import*asBuzzfrom"./bus.buzzer";
importStatefrom"../99.core/state";
exportfunctionreducer(model:BusModel=newBusModel(),act:Act.Actions,state?:State){
switch(act.type){
caseAct.UPDATE_BUS:
returnBuzz.updateBus(clone(model),act.bale,state);
caseAct.OPEN_BUS:
returnBuzz.openBus(clone(model),act.bale,state);
caseAct.CONNECT_BUS:
returnBuzz.connectBus(clone(model),act.bale,state);
caseAct.CREATE_BUS:
returnBuzz.createBus(clone(model),act.bale,state);
caseAct.MESSAGE_BUS:
returnBuzz.connectBus(clone(model),act.bale,state);
caseAct.INIT_BUS:
returnBuzz.initBus(clone(model),act.bale,state);
default:
returnmodel;
importStatefrom"../99.core/state";
exportdefaultclassBusUnit{
constructor(state:State){
import*asActMnufrom"../../98.menu.unit/menu.action";
import*asActBusfrom"../../99.bus.unit/bus.action";
import*asActColfrom"../../97.collect.unit/collect.action";
varlst,idx,bit,src,dat,dex;
exportconstinitBus=(cpy:BusModel,bal:BusBit,ste:State)=>{
cpy.actList=[]
if(bal==null)bal={idx:null}
if(bal.lst==null)bal.lst=[]
if((bal.src!=null)&&(bal.src.constructor==Array))lst=bal.src;
bal.lst.forEach((a)=>{
for(varkeyina){
cpy.actList.push(a[key])
ste.bus=(idx,dat,bit)=>updateBus(cpy,{idx,dat,bit},ste)
if(bal.dat!=null){
cpy.MQTT=bal.dat;
else{
if(lst==null){
if(bal.src!=null)cpy.host=bal.src
cpy.client=cpy.MQTT.connect(cpy.host);
cpy.client.on('message',(tpc,msg)=>{messageBus(cpy,{idx:tpc,src:msg},ste)})
cpy.client.on('connect',()=>{
openBus(cpy,{idx:'init-bus',lst:cpy.actList},ste)
if(bal.slv!=null)bal.slv({intBit:{idx:"init-bus"}})
}else{
varcomplete=(lst)=>{
lst.shift()
if(lst.length!=0)return
if(bal.slv!=null)bal.slv({intBit:{idx:"init-bus"}})
lst.forEach(async(a)=>{
bit=awaitste.hunt(ActCol.WRITE_COLLECT,{idx:a.idx,src:a.src,bit:ActBus.CREATE_BUS})
varclient=bit.clcBit.dat;
client.on('message',(tpc,msg)=>{messageBus(cpy,{idx:tpc,src:msg,bit:a.idx},ste)})
client.on('connect',()=>{
openBus(cpy,{idx:'init-bus',lst:cpy.actList,bit:a.idx},ste)
complete(lst)
exportconstcreateBus=(cpy:BusModel,bal:BusBit,ste:State)=>{
varclient=cpy.MQTT.connect(bal.src);
if(bal.slv!=null)bal.slv({busBit:{idx:"create-bus",dat:client}});
exportconstopenBus=async(cpy:BusModel,bal:BusBit,ste:State)=>{
varout=[]
bal.lst.forEach((a)=>{
if(a==null)return
if(a.includes==null)return
if(a.includes('[')&&a.includes(']')==false)return
out.push(a)
varclient=cpy.client;
if(bal.bit!=null){
bit=awaitste.hunt(ActCol.READ_COLLECT,{idx:bal.bit,bit:ActBus.CREATE_BUS})
client=bit.clcBit.dat
out.forEach((a)=>{
client.subscribe(a,(err)=>{
if(!err){
exportconstconnectBus=(cpy:BusModel,bal:BusBit,ste:State)=>{
varlst=[]
if(bal.val==1)patch(ste,ActMnu.INIT_MENU,{lst})
exportconstmessageBus=async(cpy:BusModel,bal:BusBit,ste:State)=>{
if(bal.src!=null)dat=bal.src.toString()
idx=bal.idx
dat=JSON.parse(dat)
varclient=cpy.client;
if(bal.bit!=null){
bit=awaitste.hunt(ActCol.READ_COLLECT,{idx:bal.bit,bit:ActBus.CREATE_BUS})
client=bit.clcBit.dat
if(idx.includes(cpy.responseSuffix)==true){
varresponseIDX=bal.idx;
varobj=cpy.promises[responseIDX];
if(obj.slv!=null)obj.slv(dat);
client.unsubscribe(responseIDX,(err)=>{
if(!err){
}else{
varbit=awaitste.hunt(idx,dat)
varcloneBit=clone(bit)
for(varkeyincloneBit){
varitm=cloneBit[key]
if(itm.dat!=null){
if(itm.dat.bit!=null)itm.dat.bit=null
cloneBit
client.publish(bal.idx+cpy.responseSuffix,JSON.stringify(cloneBit))
exportconstupdateBus=async(cpy:BusModel,bal:BusBit,ste:State)=>{
varclient=cpy.client;
if(bal.bit!=null){
bit=awaitste.hunt(ActCol.READ_COLLECT,{idx:bal.bit,bit:ActBus.CREATE_BUS})
client=bit.clcBit.dat
if((client==null)&&(bal.bit==null)){
bit=awaitste.hunt(ActCol.FETCH_COLLECT,{bit:ActBus.CREATE_BUS})
client=bit.clcBit.dat
varresponseIDX=bal.idx+cpy.responseSuffix;
varslv;
constpromo=newPromise((rslv,rjct)=>(slv=rslv));
varobj={slv:(val0)=>slv(val0)};
cpy.promises[responseIDX]=obj
client.subscribe(responseIDX,(err)=>{
if(!err){
client.publish(bal.idx,JSON.stringify(bal.dat))
returnpromo;
varpatch=(ste,type,bale)=>ste.dispatch({type,bale});
import{BusModel}from"../bus.model";
importBusBitfrom"../fce/bus.bit";
importStatefrom"../../99.core/state";
importSfrom"string";
import*asclonefrom"clone-deep";
exportdefaultinterfaceBusBit{
idx:string;
val?:number;
lst?:any;
src?:any;
bit?:string;
slv?:Function;
dat?:any;
importBusBitfrom"./bus.bit";
exportdefaultinterfaceBus{
"usestrict";
exports.__esModule=true;
exportinterfaceAction<T=any>{
type:string;
bale?:T;
"usestrict";
exports.__esModule=true;
exportdefaultinterfaceModel{}
"usestrict";
var__extends=(this&&this.__extends)||(function(){
varextendStatics=function(d,b){
extendStatics=Object.setPrototypeOf||
({__proto__:[]}instanceofArray&&function(d,b){d.__proto__=b;})||
function(d,b){for(varpinb)if(Object.prototype.hasOwnProperty.call(b,p))d[p]=b[p];};
returnextendStatics(d,b);
returnfunction(d,b){
if(typeofb!=="function"&&b!==null)
thrownewTypeError("Classextendsvalue"+String(b)+"isnotaconstructorornull");
extendStatics(d,b);
function__(){this.constructor=d;}
d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new__());
})();
var__createBinding=(this&&this.__createBinding)||(Object.create?(function(o,m,k,k2){
if(k2===undefined)k2=k;
vardesc=Object.getOwnPropertyDescriptor(m,k);
if(!desc||("get"indesc?!m.__esModule:desc.writable||desc.configurable)){
desc={enumerable:true,get:function(){returnm[k];}};
Object.defineProperty(o,k2,desc);
}):(function(o,m,k,k2){
if(k2===undefined)k2=k;
o[k2]=m[k];
}));
var__setModuleDefault=(this&&this.__setModuleDefault)||(Object.create?(function(o,v){
Object.defineProperty(o,"default",{enumerable:true,value:v});
}):function(o,v){
o["default"]=v;
var__importStar=(this&&this.__importStar)||function(mod){
if(mod&&mod.__esModule)returnmod;
varresult={};
if(mod!=null)for(varkinmod)if(k!=="default"&&Object.prototype.hasOwnProperty.call(mod,k))__createBinding(result,mod,k);
__setModuleDefault(result,mod);
returnresult;
var__importDefault=(this&&this.__importDefault)||function(mod){
return(mod&&mod.__esModule)?mod:{"default":mod};
exports.__esModule=true;
varrx_lite_1=require("rx-lite");
varrx_lite_2=require("rx-lite");
varBEE_1=__importDefault(require("../BEE"));
varEffect=__importStar(require("../BEE"));
varState=/**@class*/(function(_super){
__extends(State,_super);
functionState(init){
if(init===void0){init=newBEE_1["default"]();}
var_this=_super.call(this,init)||this;
_this.dispatcher=newrx_lite_2.Subject();
_this.dispatcher
.scan(function(state,action){return_this.reducedApp(state,action);},init)
.subscribe(function(state){
_super.prototype.onNext.call(_this,state);
});
return_this;
State.prototype.reducedApp=function(nextState,key){
for(varkinEffect.reducer)
Effect.reducer[k](nextState[k],key,this);
returnnextState;
State.prototype.dispatch=function(value){
varresult=this.dispatcher.onNext(value);
returnresult;
State.prototype.pat=function(value){
this.dispatch(value);
State.prototype.next=function(value){
this.dispatcher.onNext(value);
returnState;
}(rx_lite_1.BehaviorSubject));
exports["default"]=State;
import{BehaviorSubject}from"rx-lite";
import{Subject}from"rx-lite";
import{Action}from"./interface/action.interface";
importUnitModelfrom"../BEE";
import*asEffectfrom"../BEE";
exportdefaultclassStateextendsBehaviorSubject<any>{
publichunt:any;
publicvalue:any;
publicpivot:any;
publicbus:any;
privatedispatcher:Subject=newSubject();
constructor(init:UnitModel=newUnitModel()){
super(init);
this.dispatcher
.scan((state,action)=>this.reducedApp(state,action),init)
.subscribe((state)=>{
super.onNext(state);
});
reducedApp(nextState:any,key:any){
for(varkinEffect.reducer)Effect.reducer[k](nextState[k],key,this);
returnnextState;
dispatch(value:Action){
varresult=this.dispatcher.onNext(value);
returnresult;
pat(value:Action){
this.dispatch(value);
next(value:any){
this.dispatcher.onNext(value);
exportconstINIT_CANVAS="[Canvasaction]InitCanvas";
exportconstUPDATE_CANVAS="[Canvasaction]UpdateCanvas";
exportconstREAD_CANVAS="[Readaction]ReadCanvas";
exportconstWRITE_CANVAS="[Writeaction]WriteCanvas";
exportconstDELETE_CANVAS="[Deleteaction]DeleteCanvas";
exportconstREMOVE_CANVAS="[Removeaction]RemoveCanvas";
exportconstCREATE_CANVAS="[Createaction]CreateCanvas";
exportconstNEST_CANVAS="[Nestaction]NestCanvas";
exportconstINIT_CHOICE="[Choiceaction]InitChoice";
exportconstUPDATE_CHOICE="[Choiceaction]UpdateChoice";
exportconstOPEN_CHOICE="[Openaction]OpenChoice";
exportconstKEY_CHOICE="[Keyaction]KeyChoice";
exportconstTOWER_CHOICE="[Toweraction]TowerChoice";
exportconstINIT_CONSOLE="[Consoleaction]InitConsole";
exportconstUPDATE_CONSOLE="[Consoleaction]UpdateConsole";
exportconstREAD_CONSOLE="[Readaction]ReadConsole";
exportconstWRITE_CONSOLE="[Writeaction]WriteConsole";
exportconstREMOVE_CONSOLE="[Removeaction]RemoveConsole";
exportconstDELETE_CONSOLE="[Deleteaction]DeleteConsole";
exportconstCREATE_CONSOLE="[Createaction]CreateConsole";
exportconstINIT_CONTROL="[Controlaction]InitControl";
exportconstUPDATE_CONTROL="[Controlaction]UpdateControl";
exportconstOPEN_CONTROL="[Openaction]OpenControl";
exportconstCREATE_CONTROL="[Createaction]CreateControl";
exportconstTEST_CONTROL="[Testaction]TestControl";
exportconstINIT_DISK='[Diskaction]InitDisk'
exportconstUPDATE_DISK='[Diskaction]UpdateDisk'
exportconstREAD_DISK='[Diskaction]ReadDisk'
exportconstWRITE_DISK='[Diskaction]WriteDisk'
exportconstINDEX_DISK='[Indexaction]IndexDisk'
exportconstLOAD_LIST_DISK='[Load_listaction]Load_listDisk'
exportconstCOPY_DISK='[Copyaction]CopyDisk'
exportconstFRAME_DISK='[Frameaction]FrameDisk'
exportconstBATCH_DISK='[Batchaction]BatchDisk'
exportconstTRASH_DISK='[Trashaction]TrashDisk'
exportconstENSURE_DISK='[Ensureaction]EnsureDisk'
exportconstDELETE_DISK='[Deleteaction]DeleteDisk'
import{Action}from"../99.core/interface/action.interface";
exportconstINIT_GRAPHIC="[Graphicaction]InitGraphic";
exportconstUPDATE_GRAPHIC="[Graphicaction]UpdateGraphic";
exportconstREAD_GRAPHIC="[Readaction]ReadGraphic";
exportconstWRITE_GRAPHIC="[Writeaction]WriteGraphic";
exportconstCREATE_GRAPHIC="[Createaction]CreateGraphic";
exportconstINIT_GRID="[Gridaction]InitGrid";
exportconstUPDATE_GRID="[Gridaction]UpdateGrid";
exportconstINIT_HEXAGON="[Hexagonaction]InitHexagon";
exportconstUPDATE_HEXAGON="[Hexagonaction]UpdateHexagon";
exportconstREAD_HEXAGON="[Readaction]ReadHexagon";
exportconstWRITE_HEXAGON="[Writeaction]WriteHexagon";
exportconstCREATE_HEXAGON="[Createaction]CreateHexagon";
exportconstINIT_INPUT="[Inputaction]InitInput";
exportconstUPDATE_INPUT="[Inputaction]UpdateInput";
exportconstOPEN_INPUT="[Openaction]OpenInput";
exportconstINIT_PIVOT="[Pivotaction]InitPivot";
exportconstUPDATE_PIVOT="[Pivotaction]UpdatePivot";
exportconstOPEN_PIVOT="[Openaction]OpenPivot";
exportconstRUN_PIVOT="[Runaction]RunPivot";
exportconstEDIT_PIVOT="[Editaction]EditPivot";
exportconstPATCH_PIVOT="[Patchaction]PatchPivot";
exportconstCOUNT_PIVOT="[Patchaction]CountPivot";
exportconstLIST_PIVOT="[Patchaction]ListPivot";
exportconstCREATE_PIVOT="[Patchaction]CreatePivot";
exportconstCONTAINS_PIVOT="[Patchaction]ContainsPivot";
exportconstBUNDLE_PIVOT="[Patchaction]BundlePivot";
exportconstREPLACE_PIVOT="[Patchaction]ReplacePivot";
exportconstSHIP_PIVOT="[Patchaction]ShipPivot";
exportconstINIT_PIXEL="[Pixelaction]InitPixel";
exportconstUPDATE_PIXEL="[Pixelaction]UpdatePixel";
exportconstOPEN_PIXEL="[Openaction]OpenPixel";
exportconstPROCESS_PIXEL="[Processaction]ProcessPixel";
exportconstCOLOR_PIXEL="[Coloraction]ColorPixel";
exportconstBUILD_PIXEL="[Buildaction]BuildPixel";
exportconstWRITE_PIXEL="[Writeaction]WritePixel";
exportconstREAD_PIXEL="[Readaction]ReadPixel";
exportconstPALETTE_PIXEL="[Readaction]PalettePixel";
exportconstBATCH_PIXEL="[Batchaction]BatchPixel";
exportconstFRAME_PIXEL="[Frameaction]FramePixel";
exportconstCHROMA_PIXEL="[Chromaaction]ChromaPixel";
exportconstSORT_PIXEL="[Chromaaction]SortPixel";
exportconstTEST_PIXEL="[Testaction]TestPixel";
exportconstINIT_RENPY="[Renpyaction]InitRenpy";
exportconstUPDATE_RENPY="[Renpyaction]UpdateRenpy";
exportconstOPEN_RENPY="[Renpyaction]OpenRenpy";
exportconstINIT_SHINY="[Shinyaction]InitShiny";
exportconstUPDATE_SHINY="[Shinyaction]UpdateShiny";
exportconstOPEN_SHINY="[Shinyaction]OpenShiny";
exportconstINIT_SPACE="[Spaceaction]InitSpace";
exportconstUPDATE_SPACE="[Spaceaction]UpdateSpace";
exportconstREADY_SPACE="[Readyaction]ReadySpace";
exportconstTEST_SPACE="[Testaction]TestSpace";
exportconstINIT_TERMINAL="[Terminalaction]InitTerminal";
exportconstUPDATE_TERMINAL="[Terminalaction]UpdateTerminal";
exportconstRUN_TERMINAL="[Runaction]RunTerminal";
exportconstEDIT_TERMINAL="[Editaction]EditTerminal";
exportconstPRINT_TERMINAL="[Printaction]PrintTerminal";
exportconstCLOSE_TERMINAL="[Closeaction]CloseTerminal";
exportconstOPTION_TERMINAL="[Optionaction]OptionTerminal";
exportconstINPUT_TERMINAL="[Inputaction]InputTerminal";
exportconstLAYOUT_TERMINAL="[Layoutaction]LayoutTerminal";
exportconstOPEN_TERMINAL="[Layoutaction]OpenTerminal";
exportconstCLEAR_TERMINAL="[Layoutaction]ClearTerminal";
exportconstINIT_TIME="[Timeaction]InitTime";
exportconstUPDATE_TIME="[Timeaction]UpdateTime";
exportconstNOW_TIME="[Timeaction]NowTime";
exportconstFORMAT_TIME="[Timeaction]FormatTime";
exportconstREAD_TIME="[Readaction]ReadTime";
exportconstWRITE_TIME="[Writeaction]WriteTime";
exportconstCREATE_TIME="[Createaction]CreateTime";
exportconstCOMPARE_TIME="[Compareaction]CompareTime";
exportconstREDUCE_TIME="[Reduceaction]ReduceTime";
exportconstTEST_TIME="[Reduceaction]TestTime";
exportconstINIT_VISAGE="[Visageaction]InitVisage";
exportconstUPDATE_VISAGE="[Visageaction]UpdateVisage";
exportconstFULLSCREEN_VISAGE="[Fullscreenaction]FullscreenVisage";
exportconstREAD_VISAGE="[Readaction]ReadVisage";
exportconstWRITE_VISAGE="[Writeaction]WriteVisage";
exportconstCREATE_VISAGE="[Createaction]CreateVisage";
exportconstSIZE_VISAGE="[Sizeaction]SizeVisage";
exportconstRENDER_VISAGE="[Renderaction]RenderVisage";
exportconstINIT_VURT="[Vurtaction]InitVurt";
exportconstDELAY_VURT="[Vurtaction]DelayVurt";
exportconstTEST_CLOUD_VURT="[Vurtaction]TestCloudVurt";
exportconstFETCH_VURT="[Vurtaction]FetchVurt";
exportconstUPDATE_VURT="[Vurtaction]UpdateVurt";
exportconstREPLACE_VURT="[Vurtaction]ReplaceVurt";
exportconstUNIT_VURT="[Vurtaction]UnitVurt";
exportconstCOUNT_VURT="[Vurtaction]CountVurt";
exportconstLIST_PIVOT_VURT="[Vurtaction]ListPivotVurt";
exportconstLIST_UNIT_VURT="[Vurtaction]ListUnitVurt";
exportconstCONTAINS_VURT="[Containsaction]ContainsVurt";
exportconstBUNDLE_VURT="[Bundleaction]BundleVurt";
exportconstVALUE_VURT="[Valueaction]ValueVurt";
importModelfrom"./99.core/interface/model.interface";
importLibraryUnitfrom"./00.library.unit/library.unit";
importTerminalUnitfrom"./80.terminal.unit/terminal.unit";
importGridUnitfrom"./81.grid.unit/grid.unit";
importCanvasUnitfrom"./82.canvas.unit/canvas.unit";
importConsoleUnitfrom"./83.console.unit/console.unit";
importInputUnitfrom"./84.input.unit/input.unit";
importChoiceUnitfrom"./85.choice.unit/choice.unit";
importContainerUnitfrom"./86.container.unit/container.unit";
importGraphicUnitfrom"./87.graphic.unit/graphic.unit";
importHexagonUnitfrom"./88.hexagon.unit/hexagon.unit";
importSpriteUnitfrom"./89.sprite.unit/sprite.unit";
importTextUnitfrom"./90.text.unit/text.unit";
importCollectUnitfrom"./97.collect.unit/collect.unit";
importMenuUnitfrom"./98.menu.unit/menu.unit";
importBusUnitfrom"./99.bus.unit/bus.unit";
importLibraryfrom"./00.library.unit/fce/library.interface";
import{LibraryModel}from"./00.library.unit/library.model";
importTerminalfrom"./80.terminal.unit/fce/terminal.interface";
import{TerminalModel}from"./80.terminal.unit/terminal.model";
importGridfrom"./81.grid.unit/fce/grid.interface";
import{GridModel}from"./81.grid.unit/grid.model";
importCanvasfrom"./82.canvas.unit/fce/canvas.interface";
import{CanvasModel}from"./82.canvas.unit/canvas.model";
importConsolefrom"./83.console.unit/fce/console.interface";
import{ConsoleModel}from"./83.console.unit/console.model";
importInputfrom"./84.input.unit/fce/input.interface";
import{InputModel}from"./84.input.unit/input.model";
importChoicefrom"./85.choice.unit/fce/choice.interface";
import{ChoiceModel}from"./85.choice.unit/choice.model";
importContainerfrom"./86.container.unit/fce/container.interface";
import{ContainerModel}from"./86.container.unit/container.model";
importGraphicfrom"./87.graphic.unit/fce/graphic.interface";
import{GraphicModel}from"./87.graphic.unit/graphic.model";
importHexagonfrom"./88.hexagon.unit/fce/hexagon.interface";
import{HexagonModel}from"./88.hexagon.unit/hexagon.model";
importSpritefrom"./89.sprite.unit/fce/sprite.interface";
import{SpriteModel}from"./89.sprite.unit/sprite.model";
importTextfrom"./90.text.unit/fce/text.interface";
import{TextModel}from"./90.text.unit/text.model";
importCollectfrom"./97.collect.unit/fce/collect.interface";
import{CollectModel}from"./97.collect.unit/collect.model";
importMenufrom"./98.menu.unit/fce/menu.interface";
import{MenuModel}from"./98.menu.unit/menu.model";
importBusfrom"./99.bus.unit/fce/bus.interface";
import{BusModel}from"./99.bus.unit/bus.model";
exportconstlist:Array<any>=[LibraryUnit,TerminalUnit,GridUnit,CanvasUnit,ConsoleUnit,InputUnit,ChoiceUnit,ContainerUnit,GraphicUnit,HexagonUnit,SpriteUnit,TextUnit,CollectUnit,MenuUnit,BusUnit];
import*asreduceFromLibraryfrom"./00.library.unit/library.reduce";
import*asreduceFromTerminalfrom"./80.terminal.unit/terminal.reduce";
import*asreduceFromGridfrom"./81.grid.unit/grid.reduce";
import*asreduceFromCanvasfrom"./82.canvas.unit/canvas.reduce";
import*asreduceFromConsolefrom"./83.console.unit/console.reduce";
import*asreduceFromInputfrom"./84.input.unit/input.reduce";
import*asreduceFromChoicefrom"./85.choice.unit/choice.reduce";
import*asreduceFromContainerfrom"./86.container.unit/container.reduce";
import*asreduceFromGraphicfrom"./87.graphic.unit/graphic.reduce";
import*asreduceFromHexagonfrom"./88.hexagon.unit/hexagon.reduce";
import*asreduceFromSpritefrom"./89.sprite.unit/sprite.reduce";
import*asreduceFromTextfrom"./90.text.unit/text.reduce";
import*asreduceFromCollectfrom"./97.collect.unit/collect.reduce";
import*asreduceFromMenufrom"./98.menu.unit/menu.reduce";
import*asreduceFromBusfrom"./99.bus.unit/bus.reduce";
exportconstreducer:any={
library:reduceFromLibrary.reducer,
terminal:reduceFromTerminal.reducer,
grid:reduceFromGrid.reducer,
canvas:reduceFromCanvas.reducer,
console:reduceFromConsole.reducer,
input:reduceFromInput.reducer,
choice:reduceFromChoice.reducer,
container:reduceFromContainer.reducer,
graphic:reduceFromGraphic.reducer,
hexagon:reduceFromHexagon.reducer,
sprite:reduceFromSprite.reducer,
text:reduceFromText.reducer,
collect:reduceFromCollect.reducer,
menu:reduceFromMenu.reducer,
bus:reduceFromBus.reducer,
exportdefaultclassUnitDataimplementsModel{
library:Library=newLibraryModel();
terminal:Terminal=newTerminalModel();
grid:Grid=newGridModel();
canvas:Canvas=newCanvasModel();
console:Console=newConsoleModel();
input:Input=newInputModel();
choice:Choice=newChoiceModel();
container:Container=newContainerModel();
graphic:Graphic=newGraphicModel();
hexagon:Hexagon=newHexagonModel();
sprite:Sprite=newSpriteModel();
text:Text=newTextModel();
collect:Collect=newCollectModel();
menu:Menu=newMenuModel();
bus:Bus=newBusModel();
varsim={
hunt:null,
state:null
sim.hunt=(typ,obj)=>{returnhost(obj,typ)}
varhost=(obj,typ)=>{
init();
varslv;
constpromo=newPromise((rslv,rjct)=>(slv=rslv));
if(obj==null)obj={};
if(obj.slv==null)obj.slv=(val0)=>slv(val0);
sim.state.dispatch({type:typ,bale:obj});
returnpromo;
varinit=()=>{
if(sim.state!=null)return;
sim.state=newState();
sim.state.pivot=sim;
sim.state.hunt=sim.hunt
for(varkinImport.list)newImport.list[k](sim.state);
import*asImportfrom"./BEE";
importStatefrom"./99.core/state";
module.exports=sim;
exportconstVERTICAL="vertical";
exportconstHORIZONTAL="horizontal";
exportconstBLACK:string="black";
exportconstRED:string="red";
exportconstGREEN:string="green";
exportconstYELLOW:string="yellow";
exportconstMAGENTA:string="magenta";
exportconstCYAN:string="cyan";
exportconstWHITE:string="white";
exportconstBLUE:string="blue";
exportconstRED:string="\x1b[31m%s\x1b[0m";
exportconstGREEN:string="\x1b[32m%s\x1b[0m";
exportconstYELLOW:string="\x1b[33m%s\x1b[0m";
exportconstMAGENTA:string="\x1b[34m%s\x1b[0m";
exportconstCYAN:string="\x1b[36m%s\x1b[0m";
exportconstEAST="E";
exportconstSOUTH_EAST="SE";
exportconstSOUTH="S";
exportconstSOUTH_WEST="SW";
exportconstWEST="W";
exportconstNORTH_WEST="NW";
exportconstNORTH="N";
exportconstNORTH_EAST="NE";
exportconstWISE_EAST="WiseE";
exportconstWISE_SOUTH_EAST="WiseSE";
exportconstWISE_SOUTH="WiseS";
exportconstWISE_SOUTH_WEST="WiseSW";
exportconstWISE_WEST="WiseW";
exportconstWISE_NORTH_WEST="WiseNW";
exportconstWISE_NORTH="WiseN";
exportconstWISE_NORTH_EAST="WiseNE";
exportconstPLAT:string="plat";
exportconstAMBT:string="ambt";
exportconstAVAS:string="avas";
exportconstRECTANGLE:string="rectangle";
exportconstROUNDED_RECTANGLE:string="rounded-rectangle";
exportconstCIRCLE:string="circle";
exporttypePosition<Type>={
x:number;
y:number;
}&Type
exporttypeGridFill=Position<{
xSpan:number;
ySpan:number;
exportconstTOP_FULL_IDX='top-fill';
exportconstMID_FULL_IDX='mid-fill';
exportconstBOT_FULL_IDX='bot-fill';
exportconstTOP_FULL_BIT:GridFill={x:0,y:0,xSpan:12,ySpan:4};
exportconstMID_FULL_BIT:GridFill={x:0,y:4,xSpan:12,ySpan:5};
exportconstBOT_FULL_BIT:GridFill={x:0,y:8,xSpan:12,ySpan:4};
exportconstFOCUS:string="focus";
exportconstHEXMAP:string="hexmap";
exportconstPLAT:string="plat";
exportconstAMBT:string="ambt";
exportconstAVAS:string="avas";
exportconstSPACE:string="space";
exportconstTIMELINE:string="timeline";
exportconstMENU_SINGLE:string="menu_single";
exportconstCLEAN:string="clean";
exportconstCYAN:string="cyan";
exportconstRED:string="red";
exportconstGREEN:string="green";
exportconstBLUE:string="blue";
exportconstYELLOW:string="yellow";
exportconstMAGENTA:string="magenta";
exportconstVISAGE:string="visage";
exportconstSURFACE:string="surface";
exportconstCONTAINER:string="container";
exportconstGRAPHIC:string="graphic";
exportconstTEXT:string="text";
exportconstSPRITE:string="sprite";
exportconstHEXAGON:string="hexagon";
exportconstVIDEO:string="video";
exportconstLOOP:string="loop";
exportconstGEOJSON="geojson";
exportconstRECTANGLE="rectangle";
exportconstTRIANGLE="triangle";
exportconstHEXAGON="hexagon";
exportconstPARALLELOGRAM="parallelogram";
exportconstFOCUS="focus";
exportconstHEXMAP="hexmap";
exportconstCLOCK:string="clock";
exportconstSCREEN:string="screen-visage";
exportconstMOUNT_FULL:string="mount-visage-full";
exportconstMOUNT_PART:string="mount-visage-part";
exportconstMOUNT_HEIGHT:string="mount-visage-height";
exportconstMOUNT_WIDTH:string="mount-visage-width";
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
exports.shipPivot=exports.patchPivot=exports.replacePivot=exports.bundlePivot=exports.containsPivot=exports.listPivot=exports.editPivot=exports.runPivot=exports.openPivot=exports.updatePivot=exports.initPivot=void0;
constActMnu=require("../../98.menu.unit/menu.action");
constActBus=require("../../99.bus.unit/bus.action");
constActPvt=require("../pivot.action");
constActDsk=require("../../96.disk.unit/disk.action");
varbit,val,idx,dex,lst,dat,src;
constinitPivot=async(cpy,bal,ste)=>{
if(bal.dat!=null)
bit=awaitste.hunt(ActBus.INIT_BUS,{idx:cpy.idx,lst:[ActPvt,ActDsk],dat:bal.dat,src:bal.src});
if(bal.val==1)
patch(ste,ActMnu.INIT_MENU,bal);
if(bal.slv!=null)
bal.slv({intBit:{idx:"init-pivot"}});
exports.initPivot=initPivot;
constupdatePivot=(cpy,bal,ste)=>{
lst=[];
src=bal.src;
if(src==null)
src='999.pivot';
const{exec}=require('child_process');
constpath=require("path");
exec('tsc-b'+src,async(err,stdout,stderr)=>{
if(err){
console.error(`execerror:${err}`);
bit=awaitste.hunt(ActDsk.EXIST_DISK,{src:'../../artefact'});
if(bit.dskBit.src=='false'){
lst.push("artefactdoesnotexist");
setTimeout(()=>{
if(bal.slv!=null)
bal.slv({pvtBit:{idx:"update-pivot"}});
},3);
bit=awaitste.hunt(ActPvt.SHIP_PIVOT,{src});
lst=lst.concat(bit.pvtBit.lst);
bal.slv({pvtBit:{idx:"update-pivot",src,lst}});
});
exports.updatePivot=updatePivot;
constopenPivot=async(cpy,bal,ste)=>{
bit=awaitste.bus(ActDsk.COPY_DISK,{src:'./vue',idx:'../gillisse/src'});
bit=awaitste.hunt(ActPvt.RUN_PIVOT,{});
constopen=require('open');
varloc='./vrt.opn.bat';
bit=awaitopen(loc);
setTimeout(()=>{
if(bal.slv!=null)
bal.slv({pvtBit:{idx:"open-pivot"}});
},33);
exports.openPivot=openPivot;
construnPivot=async(cpy,bal,ste)=>{
constopen=require('open');
varloc='./vrt.gil.bat';
bit=awaitopen(loc);
setTimeout(()=>{
if(bal.slv!=null)
bal.slv({pvtBit:{idx:"run-pivot"}});
});
exports.runPivot=runPivot;
consteditPivot=(cpy,bal,ste)=>{
const{exec}=require('child_process');
process.chdir("../../studio/");
exec('startCode.exe../packages/gillisse',async(err,stdout,stderr)=>{
if(err){
console.error(`execerror:${err}`);
process.chdir("../packages/999.pivot");
if(bal.slv!=null)
bal.slv({pvtBit:{idx:"edit-pivot",dat:{}}});
});
exports.editPivot=editPivot;
constlistPivot=async(cpy,bal,ste)=>{
varroot="../";
varlistDir=awaitFS.readdir(root);
varpivotList=[];
listDir.forEach((a)=>{
varpth=root+a;
if(FS.lstatSync(pth).isDirectory()==false)
return;
if(a.includes(".")==false)
return;
varsub=a.split(".")[0];
if(sub.length!=3)
return;
if(S(sub).isNumeric().s==false)
return;
pivotList.push(a);
});
if(bal.src!=null){
varout=[];
pivotList.forEach((a)=>{
varloc='../'+a+'/'+bal.src;
varflag=FS.existsSync(loc);
if(flag==false)
return;
out.push(a);
});
pivotList=out;
bal.slv({pvtBit:{idx:"list-pivot",lst:pivotList}});
exports.listPivot=listPivot;
constcontainsPivot=(cpy,bal,ste)=>{
varout=[];
varcheck=bal.src;
debugger;
bal.lst.forEach((a)=>{
vardir='../'+a+'/'+a;
varlst=FS.readdirSync(dir);
debugger;
lst.forEach((b)=>{
if(b.includes(check))
out.push([a,b]);
});
});
if(bal.slv!=null)
bal.slv({pvtBit:{idx:"contains-pivot",lst:out}});
exports.containsPivot=containsPivot;
constbundlePivot=async(cpy,bal,ste)=>{
varexec=require('child_process').exec;
if(bal.src==null)
bal.src='999.pivot';
varroot='999.pivot';
vartemplate='node./data/hand/000.eveiefy-t'+bal.src;
exec(template,async(err,stdout,stderr)=>{
if(err){
console.error(`execerror:${err}`);
if(bal.val==null)
bal.val=3;
setTimeout(()=>bal.slv({pvtBit:{idx:"bundle-pivot"},src:bal.src}),bal.val);
});
exports.bundlePivot=bundlePivot;
constreplacePivot=async(cpy,bal,ste)=>{
if(bal.lst==null)
bal.lst=[];
vardex=bal.lst.length;
varmessage=[];
varreplace=async()=>{
if(dex<=0){
bal.slv({pvtBit:{idx:"replace-pivot"},src:bal.src,lst:message});
idx=bal.lst[dex];
bit=awaitste.bus(ActDsk.COPY_DISK,{src:bal.src,idx});
message.push(bit);
dex-=1;
awaitreplace();
awaitreplace();
exports.replacePivot=replacePivot;
constpatchPivot=(cpy,bal,ste)=>{
debugger;
exports.patchPivot=patchPivot;
constshipPivot=async(cpy,bal,ste)=>{
varmsg=[];
if(bal.src==null)
bal.src='999.pivot';
src=bal.src;
msg.push("shippingpivot:"+src);
varfinal='./work/'+src;
bit=awaitste.hunt(ActDsk.COPY_DISK,{src:'../'+src+'/dist/'+src,idx:final});
lst=msg.concat(bit.dskBit.lst);
varfileList=[];
varindexFile='';
constpath=require("path");
constwalkFunc=async(err,pathname,dirent)=>{
if(err){
throwerr;
if(dirent.isDirectory()){
varext=path.extname(pathname);
varbase=path.basename(pathname);
if(base=='hunt.js'){
indexFile=pathname;
if(ext=='.ts'||ext=='.map'||ext=='.tsbuildinfo'){
fileList.push(pathname);
varwait=await(0,walk_1.walk)(final,walkFunc);
fileList;
bit=awaitste.hunt(ActDsk.READ_DISK,{src:final+'/hunt.js'});
dat=bit.dskBit.dat;
bit=awaitste.hunt(ActDsk.WRITE_DISK,{src:final+'/index.js',dat});
bit=awaitste.hunt(ActDsk.DELETE_DISK,{src:final+'/hunt.js'});
lst=lst.concat(bit.dskBit.lst);
fileList.forEach((a)=>ste.hunt(ActDsk.DELETE_DISK,{src:a}));
bal.slv({pvtBit:{idx:"ship-pivot",lst}});
exports.shipPivot=shipPivot;
varpatch=(ste,type,bale)=>ste.dispatch({type,bale});
constFS=require("fs-extra");
constS=require("string");
constwalk_1=require("@root/walk");
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
exports.countPivot=void0;
varbit,val,idx,dex,lst,dat;
constcountPivot=async(cpy,bal,ste)=>{
varpath=require("path");
varroot="../";
varlistDir=awaitFS.readdir(root);
varpivotList=[];
listDir.forEach((a)=>{
varpth=root+a;
if(FS.lstatSync(pth).isDirectory()==false)
return;
if(a.includes(".")==false)
return;
varsub=a.split(".")[0];
if(sub.length!=3)
return;
if(S(sub).isNumeric().s==false)
return;
pivotList.push(a);
});
varunitList=[];
pivotList.forEach((a)=>{
vardir=root+a+"/"+a;
varlist=FS.readdirSync(dir);
list.forEach((b)=>{
if(b.includes("unit")==false)
return;
unitList.push(dir+"/"+b);
});
});
varfileList=[];
varcount=0;
vardata={};
vartotal=0;
constfinFunc=()=>{
fileList.forEach((a)=>{
if(FS.lstatSync(a).isDirectory()==true)
return;
varline=FS.readFileSync(a).toString().split("\n");
line.forEach((b)=>{
if(b.length<3)
return;
return;
total+=1;
varidx=S(b).slugify().s;
if(idx.length<3)
return;
if(data[idx]!=null)
return(data[idx]+=1);
data[idx]=1;
});
});
varsnow=0;
varfinal=0;
for(varkeyindata){
snow+=1;
final+=data[key];
vardate=luxon_1.DateTime.now();
varnow=date.toLocaleString(luxon_1.DateTime.DATETIME_MED);
now=now.replaceAll(":","-");
now=S(now).slugify().s;
vardat={now,total,snow};
varcountSrc="./data/count.txt";
FS.ensureFileSync(countSrc);
varlist=FS.readFileSync(countSrc).toString().split("\n");
list.unshift(JSON.stringify(dat));
FS.writeFileSync(countSrc,list.join("\n"));
if(bal.slv!=null)
bal.slv({pvtBit:{idx:"count-pivot",dat}});
constwalkFunc=async(err,pathname,dirent)=>{
if(err){
throwerr;
if(dirent.isDirectory()&&dirent.name.startsWith(".")){
returnfalse;
varwant=pathname.split(path.sep);
fileList.push(want.join("/"));
unitList.forEach(async(a)=>{
await(0,walk_1.walk)(a,walkFunc);
vardirs=a.split('/');
varpythonDir='../'+dirs[1]+'/python/';
varrenpyDir='../'+dirs[1]+'/renpy/';
varscreenDir='../'+dirs[1]+'/screen/';
varpytExist=FS.existsSync(pythonDir);
varrenExist=FS.existsSync(pythonDir);
varscreenExist=FS.existsSync(screenDir);
varlisting;
if(pytExist==true){
listing=FS.readdirSync(pythonDir);
listing.forEach((a)=>{fileList.push(pythonDir+'/'+a);});
if(renExist==true){
listing=FS.readdirSync(renpyDir);
listing.forEach((a)=>{fileList.push(renpyDir+'/'+a);});
if(screenExist==true){
listing=FS.readdirSync(screenDir);
listing.forEach((a)=>{fileList.push(screenDir+'/'+a);});
count+=1;
if(count==unitList.length)
finFunc();
});
exports.countPivot=countPivot;
constFS=require("fs-extra");
constS=require("string");
constwalk_1=require("@root/walk");
constluxon_1=require("luxon");
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
exports.createPivot=void0;
constActDsk=require("../../96.disk.unit/disk.action");
constActCol=require("../../97.collect.unit/collect.action");
varbit,val,idx,dex,lst,dat,src;
constcreatePivot=async(cpy,bal,ste)=>{
varnom=bal.idx;
varname=bal.src;
vardex=String(bal.dex).padStart(3,'0');
if(nom==null)
nom='sed';
if(name==null)
name='seed';
if(dex==null)
dex='000';
varpivot=dex+'.'+name;
varpivotUnit=pivot+'.unit';
varpivotSrc='./data/redux/pivot/';
varvueSrc=pivotSrc+'vue';
vardataSrc=pivotSrc+'data';
varunitIdx='/000.pivot/';
varunitPvt='/00.'+name+'';
varcollectIdx='97.collect.unit';
varmenuIdx='98.menu.unit';
varbusIdx='99.bus.unit';
varcoreIdx='99.core';
varcollectSrc=pivotSrc+unitIdx+collectIdx;
varmenuSrc=pivotSrc+unitIdx+menuIdx;
varbusSrc=pivotSrc+unitIdx+busIdx;
varcoreSrc=pivotSrc+unitIdx+coreIdx;
varactionSrc=pivotSrc+unitIdx+'act';
varvalSrc=pivotSrc+unitIdx+'val';
varpivotFin='./data/'+pivot+'/';
varpivotUnt=pivotFin+pivot+'/00.'+name+'/';
bit=awaitste.hunt(ActDsk.ENSURE_DISK,{src:'./data/'+pivot});
bit=awaitste.hunt(ActDsk.DELETE_DISK,{src:'./data/'+pivot});
varitmSrc;
itmSrc={src:vueSrc,idx:pivotFin+"/vue"};
bit=awaitste.hunt(ActDsk.COPY_DISK,itmSrc);
itmSrc={src:dataSrc,idx:pivotFin+"/data"};
bit=awaitste.hunt(ActDsk.COPY_DISK,itmSrc);
itmSrc={src:collectSrc,idx:pivotFin+'/'+pivot+'/'+collectIdx};
bit=awaitste.hunt(ActDsk.COPY_DISK,itmSrc);
itmSrc={src:menuSrc,idx:pivotFin+'/'+pivot+'/'+menuIdx};
bit=awaitste.hunt(ActDsk.COPY_DISK,itmSrc);
itmSrc={src:busSrc,idx:pivotFin+'/'+pivot+'/'+busIdx};
bit=awaitste.hunt(ActDsk.COPY_DISK,itmSrc);
itmSrc={src:coreSrc,idx:pivotFin+'/'+pivot+'/'+coreIdx};
bit=awaitste.hunt(ActDsk.COPY_DISK,itmSrc);
itmSrc={src:actionSrc,idx:pivotFin+'/'+pivot+'/act/'};
bit=awaitste.hunt(ActDsk.COPY_DISK,itmSrc);
itmSrc={src:valSrc,idx:pivotFin+'/'+pivot+'/val/'};
bit=awaitste.hunt(ActDsk.COPY_DISK,itmSrc);
bit=awaitste.hunt(ActDsk.INDEX_DISK,{src:'./data/redux/pivot/'});
lst=bit.dskBit.lst;
varbatLst=[];
lst.forEach((a)=>{
if(a.includes('.bat')==false)
return;
varitmSrc={src:pivotSrc+a,idx:pivotFin+'/'+a};
batLst.push(itmSrc);
});
varhtmlLst=[];
lst.forEach((a)=>{
if(a.includes('.html')==false)
return;
varitmSrc={src:pivotSrc+a,idx:pivotFin+'/'+a};
htmlLst.push(itmSrc);
});
varjsLst=[];
lst.forEach((a)=>{
if(a.includes('.js')==false)
return;
varitmSrc={src:pivotSrc+a,idx:pivotFin+'/'+a};
jsLst.push(itmSrc);
});
varcjsLst=[];
lst.forEach((a)=>{
if(a.includes('.cjs')==false)
return;
varitmSrc={src:pivotSrc+a,idx:pivotFin+'/'+a};
cjsLst.push(itmSrc);
});
varjsonLst=[];
lst.forEach((a)=>{
if(a.includes('.json')==false)
return;
varitmSrc={src:pivotSrc+a,idx:pivotFin+'/'+a};
jsonLst.push(itmSrc);
});
varoutput=[];
output=output.concat(batLst);
output=output.concat(htmlLst);
output=output.concat(jsLst);
output=output.concat(cjsLst);
output=output.concat(jsonLst);
output;
varpvt='00.pivot.unit/';
varbuzzIdx='/buz/'+name+'.buzz.ts';
varbuzzPvt='/buz/pivot.buzz.ts';
varbuzzSrc={src:pivotSrc+unitIdx+pvt+buzzPvt,idx:pivotFin+'/'+pivot+'/'+unitPvt+'.unit/'+buzzIdx};
output.push(buzzSrc);
varbitIdx='/fce/'+name+'.bit.ts';
varbitPvt='/fce/pivot.bit.ts';
varbitSrc={src:pivotSrc+unitIdx+pvt+bitPvt,idx:pivotFin+'/'+pivot+'/'+unitPvt+'.unit/'+bitIdx};
output.push(bitSrc);
varfceIdx='/fce/'+name+'.interface.ts';
varfcePvt='/fce/pivot.interface.ts';
varfceSrc={src:pivotSrc+unitIdx+pvt+fcePvt,idx:pivotFin+'/'+pivot+'/'+unitPvt+'.unit/'+fceIdx};
output.push(fceSrc);
varactIdx='/'+name+'.action.ts';
varactPvt='/pivot.action.ts';
varactSrc={src:pivotSrc+unitIdx+pvt+actPvt,idx:pivotFin+'/'+pivot+'/'+unitPvt+'.unit/'+actIdx};
output.push(actSrc);
varbuzIdx='/'+name+'.buzzer.ts';
varbuzPvt='/pivot.buzzer.ts';
varbuzSrc={src:pivotSrc+unitIdx+pvt+buzPvt,idx:pivotFin+'/'+pivot+'/'+unitPvt+'.unit/'+buzIdx};
output.push(buzSrc);
varmodIdx='/'+name+'.model.ts';
varmodPvt='/pivot.model.ts';
varmodSrc={src:pivotSrc+unitIdx+pvt+modPvt,idx:pivotFin+'/'+pivot+'/'+unitPvt+'.unit/'+modIdx};
output.push(modSrc);
varrdcIdx='/'+name+'.reduce.ts';
varrdcPvt='/pivot.reduce.ts';
varrdcSrc={src:pivotSrc+unitIdx+pvt+rdcPvt,idx:pivotFin+'/'+pivot+'/'+unitPvt+'.unit/'+rdcIdx};
output.push(rdcSrc);
varuntIdx='/'+name+'.unit.ts';
varuntPvt='/pivot.unit.ts';
varuntSrc={src:pivotSrc+unitIdx+pvt+untPvt,idx:pivotFin+'/'+pivot+'/'+unitPvt+'.unit/'+untIdx};
output.push(untSrc);
varqstIdx='/000.quest.'+name+'.js';
varqstSrc={src:pivotSrc+unitIdx+'/000.quest.pivot.js',idx:pivotFin+'/'+pivot+'/'+qstIdx};
output.push(qstSrc);
varbeeIdx='/BEE.ts';
varbeeSrc={src:pivotSrc+unitIdx+'/'+beeIdx,idx:pivotFin+'/'+pivot+'/'+beeIdx};
output.push(beeSrc);
varhntIdx='/hunt.ts';
varbeeSrc={src:pivotSrc+unitIdx+'/'+hntIdx,idx:pivotFin+'/'+pivot+'/'+hntIdx};
output.push(beeSrc);
varcfgIdx='/tsconfig.json';
varcfgSrc={src:pivotSrc+unitIdx+'/'+cfgIdx,idx:pivotFin+'/'+pivot+'/'+cfgIdx};
output.push(cfgSrc);
varmnuIdx='/00.menu.buzz.ts';
varmnuSrc={src:pivotSrc+unitIdx+'/98.menu.unit/buz/'+mnuIdx,idx:pivotFin+'/'+pivot+'/98.menu.unit/buz/'+mnuIdx};
output.push(mnuSrc);
varbitReadMain=awaitste.hunt(ActDsk.READ_DISK,{src:pivotSrc+'/main.js'});
varbitWriteMain=awaitste.hunt(ActDsk.WRITE_DISK,{src:pivotFin+'/main.js',dat:bitReadMain.dskBit.dat});
vargel={};
gel.nom=nom;
gel.name=name;
gel.pivot=dex+'.'+name;
gel.nameCaps=name.toUpperCase();
gel.nomCaps=nom.toUpperCase();
gel.nomTitle=nom.charAt(0).toUpperCase()+nom.slice(1);
gel.nameTitle=name.charAt(0).toUpperCase()+name.slice(1);
constnext=async(lst)=>{
if(lst.length==0){
if(bal.slv!=null)
bal.slv({vrtBit:{idx:"pivot-vurt",src:''}});
return;
varitm=lst.shift();
if(itm==null)
returnnext(lst);
itm.src;
varbitRed=awaitste.hunt(ActDsk.READ_DISK,{src:itm.src});
src=bitRed.dskBit.dat;
varbitDot=awaitste.hunt(ActCol.DOT_COLLECT,{src,dat:gel});
varlstDot=bitDot.colBit.lst;
itm.idx;
varbitDsk=awaitste.hunt(ActDsk.WRITE_DISK,{src:itm.idx,dat:lstDot.join('\n')});
lst;
next(lst);
output;
next(output);
exports.createPivot=createPivot;
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
exports.ShipPivot=exports.SHIP_PIVOT=exports.ReplacePivot=exports.REPLACE_PIVOT=exports.BundlePivot=exports.BUNDLE_PIVOT=exports.ContainsPivot=exports.CONTAINS_PIVOT=exports.CreatePivot=exports.CREATE_PIVOT=exports.ListPivot=exports.LIST_PIVOT=exports.CountPivot=exports.COUNT_PIVOT=exports.PatchPivot=exports.PATCH_PIVOT=exports.EditPivot=exports.EDIT_PIVOT=exports.RunPivot=exports.RUN_PIVOT=exports.OpenPivot=exports.OPEN_PIVOT=exports.UpdatePivot=exports.UPDATE_PIVOT=exports.InitPivot=exports.INIT_PIVOT=void0;
exports.INIT_PIVOT="[Pivotaction]InitPivot";
classInitPivot{
constructor(bale){
this.bale=bale;
this.type=exports.INIT_PIVOT;
exports.InitPivot=InitPivot;
exports.UPDATE_PIVOT="[Pivotaction]UpdatePivot";
classUpdatePivot{
constructor(bale){
this.bale=bale;
this.type=exports.UPDATE_PIVOT;
exports.UpdatePivot=UpdatePivot;
exports.OPEN_PIVOT="[Openaction]OpenPivot";
classOpenPivot{
constructor(bale){
this.bale=bale;
this.type=exports.OPEN_PIVOT;
exports.OpenPivot=OpenPivot;
exports.RUN_PIVOT="[Runaction]RunPivot";
classRunPivot{
constructor(bale){
this.bale=bale;
this.type=exports.RUN_PIVOT;
exports.RunPivot=RunPivot;
exports.EDIT_PIVOT="[Editaction]EditPivot";
classEditPivot{
constructor(bale){
this.bale=bale;
this.type=exports.EDIT_PIVOT;
exports.EditPivot=EditPivot;
exports.PATCH_PIVOT="[Patchaction]PatchPivot";
classPatchPivot{
constructor(bale){
this.bale=bale;
this.type=exports.PATCH_PIVOT;
exports.PatchPivot=PatchPivot;
exports.COUNT_PIVOT="[Patchaction]CountPivot";
classCountPivot{
constructor(bale){
this.bale=bale;
this.type=exports.COUNT_PIVOT;
exports.CountPivot=CountPivot;
exports.LIST_PIVOT="[Patchaction]ListPivot";
classListPivot{
constructor(bale){
this.bale=bale;
this.type=exports.LIST_PIVOT;
exports.ListPivot=ListPivot;
exports.CREATE_PIVOT="[Patchaction]CreatePivot";
classCreatePivot{
constructor(bale){
this.bale=bale;
this.type=exports.CREATE_PIVOT;
exports.CreatePivot=CreatePivot;
exports.CONTAINS_PIVOT="[Patchaction]ContainsPivot";
classContainsPivot{
constructor(bale){
this.bale=bale;
this.type=exports.CONTAINS_PIVOT;
exports.ContainsPivot=ContainsPivot;
exports.BUNDLE_PIVOT="[Patchaction]BundlePivot";
classBundlePivot{
constructor(bale){
this.bale=bale;
this.type=exports.BUNDLE_PIVOT;
exports.BundlePivot=BundlePivot;
exports.REPLACE_PIVOT="[Patchaction]ReplacePivot";
classReplacePivot{
constructor(bale){
this.bale=bale;
this.type=exports.REPLACE_PIVOT;
exports.ReplacePivot=ReplacePivot;
exports.SHIP_PIVOT="[Patchaction]ShipPivot";
classShipPivot{
constructor(bale){
this.bale=bale;
this.type=exports.SHIP_PIVOT;
exports.ShipPivot=ShipPivot;
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
exports.createPivot=exports.countPivot=exports.bundlePivot=exports.containsPivot=exports.replacePivot=exports.listPivot=exports.shipPivot=exports.patchPivot=exports.editPivot=exports.runPivot=exports.openPivot=exports.updatePivot=exports.initPivot=void0;
var_00_pivot_buzz_1=require("./buz/00.pivot.buzz");
Object.defineProperty(exports,"initPivot",{enumerable:true,get:function(){return_00_pivot_buzz_1.initPivot;}});
var_00_pivot_buzz_2=require("./buz/00.pivot.buzz");
Object.defineProperty(exports,"updatePivot",{enumerable:true,get:function(){return_00_pivot_buzz_2.updatePivot;}});
var_00_pivot_buzz_3=require("./buz/00.pivot.buzz");
Object.defineProperty(exports,"openPivot",{enumerable:true,get:function(){return_00_pivot_buzz_3.openPivot;}});
var_00_pivot_buzz_4=require("./buz/00.pivot.buzz");
Object.defineProperty(exports,"runPivot",{enumerable:true,get:function(){return_00_pivot_buzz_4.runPivot;}});
var_00_pivot_buzz_5=require("./buz/00.pivot.buzz");
Object.defineProperty(exports,"editPivot",{enumerable:true,get:function(){return_00_pivot_buzz_5.editPivot;}});
var_00_pivot_buzz_6=require("./buz/00.pivot.buzz");
Object.defineProperty(exports,"patchPivot",{enumerable:true,get:function(){return_00_pivot_buzz_6.patchPivot;}});
var_00_pivot_buzz_7=require("./buz/00.pivot.buzz");
Object.defineProperty(exports,"shipPivot",{enumerable:true,get:function(){return_00_pivot_buzz_7.shipPivot;}});
var_00_pivot_buzz_8=require("./buz/00.pivot.buzz");
Object.defineProperty(exports,"listPivot",{enumerable:true,get:function(){return_00_pivot_buzz_8.listPivot;}});
var_00_pivot_buzz_9=require("./buz/00.pivot.buzz");
Object.defineProperty(exports,"replacePivot",{enumerable:true,get:function(){return_00_pivot_buzz_9.replacePivot;}});
var_00_pivot_buzz_10=require("./buz/00.pivot.buzz");
Object.defineProperty(exports,"containsPivot",{enumerable:true,get:function(){return_00_pivot_buzz_10.containsPivot;}});
var_00_pivot_buzz_11=require("./buz/00.pivot.buzz");
Object.defineProperty(exports,"bundlePivot",{enumerable:true,get:function(){return_00_pivot_buzz_11.bundlePivot;}});
varcount_pivot_1=require("./buz/count-pivot");
Object.defineProperty(exports,"countPivot",{enumerable:true,get:function(){returncount_pivot_1.countPivot;}});
varcreate_pivot_1=require("./buz/create-pivot");
Object.defineProperty(exports,"createPivot",{enumerable:true,get:function(){returncreate_pivot_1.createPivot;}});
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
exports.PivotModel=void0;
classPivotModel{
constructor(){
this.idx='999.pivot-23.11.05';
exports.PivotModel=PivotModel;
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
exports.reducer=void0;
constclone=require("clone-deep");
constAct=require("./pivot.action");
constpivot_model_1=require("./pivot.model");
constBuzz=require("./pivot.buzzer");
functionreducer(model=newpivot_model_1.PivotModel(),act,state){
switch(act.type){
caseAct.UPDATE_PIVOT:
returnBuzz.updatePivot(clone(model),act.bale,state);
caseAct.INIT_PIVOT:
returnBuzz.initPivot(clone(model),act.bale,state);
caseAct.OPEN_PIVOT:
returnBuzz.openPivot(clone(model),act.bale,state);
caseAct.RUN_PIVOT:
returnBuzz.runPivot(clone(model),act.bale,state);
caseAct.EDIT_PIVOT:
returnBuzz.editPivot(clone(model),act.bale,state);
caseAct.REPLACE_PIVOT:
returnBuzz.replacePivot(clone(model),act.bale,state);
caseAct.SHIP_PIVOT:
returnBuzz.shipPivot(clone(model),act.bale,state);
caseAct.PATCH_PIVOT:
returnBuzz.patchPivot(clone(model),act.bale,state);
caseAct.COUNT_PIVOT:
returnBuzz.countPivot(clone(model),act.bale,state);
caseAct.LIST_PIVOT:
returnBuzz.listPivot(clone(model),act.bale,state);
caseAct.CREATE_PIVOT:
returnBuzz.createPivot(clone(model),act.bale,state);
caseAct.CONTAINS_PIVOT:
returnBuzz.containsPivot(clone(model),act.bale,state);
caseAct.BUNDLE_PIVOT:
returnBuzz.bundlePivot(clone(model),act.bale,state);
default:
returnmodel;
exports.reducer=reducer;
"usestrict";
var__decorate=(this&&this.__decorate)||function(decorators,target,key,desc){
varc=arguments.length,r=c<3?target:desc===null?desc=Object.getOwnPropertyDescriptor(target,key):desc,d;
if(typeofReflect==="object"&&typeofReflect.decorate==="function")r=Reflect.decorate(decorators,target,key,desc);
elsefor(vari=decorators.length-1;i>=0;i--)if(d=decorators[i])r=(c<3?d(r):c>3?d(target,key,r):d(target,key))||r;
returnc>3&&r&&Object.defineProperty(target,key,r),r;
var__metadata=(this&&this.__metadata)||function(k,v){
if(typeofReflect==="object"&&typeofReflect.metadata==="function")returnReflect.metadata(k,v);
Object.defineProperty(exports,"__esModule",{value:true});
consttypescript_ioc_1=require("typescript-ioc");
conststate_1=require("../99.core/state");
letPivotUnit=classPivotUnit{
constructor(state){
PivotUnit=__decorate([
typescript_ioc_1.Singleton,
__metadata("design:paramtypes",[state_1.default])
],PivotUnit);
exports.default=PivotUnit;
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
exports.addPort=exports.updateTerminal=exports.contentTerminal=exports.writeTerminal=exports.openTerminal=exports.tableTerminal=exports.inputTerminal=exports.closeTerminal=exports.clearTerminal=exports.focusTerminal=exports.rootTerminal=exports.initTerminal=void0;
constActTrm=require("../terminal.action");
varsrc,bit,lst,dat,idx;
constinitTerminal=async(cpy,bal,ste)=>{
if(bal==null)
bal={val:0};
if(cpy.term!=null){
if(bal.slv!=null)
bal.slv({intBit:{idx:"error-terminal"}});
return;
cpy.term=require("terminal-kit").terminal;
if(bal.lst==null)
bal.lst=[];
if(bal.src!=null)
src=bal.src;
if(bal.slv!=null)
bal.slv({intBit:{idx:"init-terminal"}});
exports.initTerminal=initTerminal;
constrootTerminal=(cpy,bal,ste)=>{
cpy.rootIDX=bal.idx;
cpy.rootDAT=bal.dat;
if(bal.slv!=null)
bal.slv({trmBit:{idx:"root-terminal"}});
exports.rootTerminal=rootTerminal;
constfocusTerminal=(cpy,bal,ste)=>{
cpy.term.grabInput(true);
if(bal.slv!=null)
bal.slv({trmBit:{idx:"focus-terminal"}});
exports.focusTerminal=focusTerminal;
constclearTerminal=(cpy,bal,ste)=>{
cpy.term.clear();
if(bal.slv!=null)
bal.slv({trmBit:{idx:"clear-terminal"}});
exports.clearTerminal=clearTerminal;
constcloseTerminal=(cpy,bal,ste)=>{
cpy.term.processExit();
if(bal.slv!=null)
bal.slv({trmBit:{idx:"close-terminal"}});
exports.closeTerminal=closeTerminal;
constinputTerminal=async(cpy,bal,ste)=>{
if(bal==null)
bal={};
if(bal.lst==null)
bal.lst=[];
bal.lst.forEach((a)=>cpy.term(a+"\n"));
varinput=awaitcpy.term.inputField({selectedIndex:bal.val}).promise;
bal.slv({trmBit:{idx:"input-terminal",src:input}});
exports.inputTerminal=inputTerminal;
consttableTerminal=(cpy,bal,ste)=>{
if(bal==null)
bal={};
if(bal.lst==null)
bal.lst=[
["h0","h1","h2","h3"],
["00","01","02","03"],
["000","001","002","003"],
if(bal.sze==null)
bal.sze=100;
cpy.term.table(bal.lst,{
hasBorder:false,
contentHasMarkup:true,
textAttr:{bgColor:"default"},
firstCellTextAttr:{bgColor:"blue"},
firstRowTextAttr:{bgColor:"yellow"},
firstColumnTextAttr:{bgColor:"red"},
checkerEvenCellTextAttr:{bgColor:"gray"},
width:bal.sze,
});
exports.tableTerminal=tableTerminal;
constopenTerminal=(cpy,bal,ste)=>{
if(bal==null)
bal={idx:"none",src:null,lst:null,dat:null};
if(cpy.term==null)
(0,exports.initTerminal)(cpy,bal,ste);
if(bal.lst==null)
bal.lst=["0","1"];
if(bal.dat==null)
varblessed=require("blessed");
varcontrib=require("blessed-contrib");
if(cpy.screen==null)
cpy.screen=blessed.screen();
vartree=contrib.tree({fg:"green"});
setTimeout(()=>tree.focus(),5);
vardata={};
varmain={};
bal.lst.forEach((a,b)=>{
varidx=String(b).padStart(3,"0");
data[idx+"-"+a]={};
main[b]=bal.dat[b];
});
tree.on("select",(node)=>{
varkey=node.name;
vardex=Number(key.split("-")[0]);
main[dex]();
cpy.screen.lockKeys=true;
setTimeout(()=>cpy.screen.destroy(),3);
});
cpy.screen.key(["escape","q","C-c"],function(ch,key){
returnprocess.exit(0);
});
varbox=blessed.box({
content:"Hello{bold}world{/bold}!",
});
cpy.screen.append(box);
tree.setData({extended:true,children:data});
cpy.screen.render();
exports.openTerminal=openTerminal;
constwriteTerminal=(cpy,bal,ste)=>{
if(bal==null)
bal={src:"write-terminal"};
if(bal.val==null)
bal.val=0;
switch(bal.val){
case9:
cpy.term.italic.yellow(bal.src+"\n");
break;
case8:
cpy.term.yellow(bal.src+"\n");
break;
case7:
cpy.term.underline.yellow(bal.src+"\n");
break;
case6:
cpy.term.bold.white(bal.src+"\n");
break;
case5:
cpy.term.bold.magenta(bal.src+"\n");
break;
case4:
cpy.term.bold.blue(bal.src+"\n");
break;
case3:
cpy.term.bold.yellow(bal.src+"\n");
break;
case2:
cpy.term.bold.red(bal.src+"\n");
break;
case1:
cpy.term.bold.cyan(bal.src+"\n");
break;
default:
cpy.term.bold.green(bal.src+"\n");
if(bal.slv!=null)
bal.slv({trmBit:{idx:"write-terminal"}});
exports.writeTerminal=writeTerminal;
constcontentTerminal=(cpy,bal,ste)=>{
if(bal==null)
bal={};
if(bal.lst==null)
bal.lst=["000","001"];
if(bal.val==null)
bal.val=0;
if(bal.dat==null)
bal.dat={};
varadd0,add1;
if(bal.dat.idx!=null){
add0=true;
bal.lst.forEach((a)=>{
if(a==bal.dat.idx)
add0=false;
});
if(bal.dat.src!=null){
add1=true;
bal.lst.forEach((a)=>{
if(a==bal.dat.src)
add1=false;
});
if(add0==true)
bal.lst.unshift(bal.dat.idx);
if(add1==true)
bal.lst.push(bal.dat.src);
cpy.term.singleColumnMenu(bal.lst,{selectedIndex:bal.val},(err,rsp)=>{
if(bal.slv!=null)
bal.slv({trmBit:{idx:"content-terminal",lst:bal.lst,val:rsp.selectedIndex}});
});
exports.contentTerminal=contentTerminal;
constupdateTerminal=(cpy,bal,ste)=>{
if(bal==null)
bal={};
if(bal.lst==null)
bal.lst=["000","001"];
if(bal.val==null)
bal.val=0;
if(cpy.rootIDX!=null)
bal.lst.push(cpy.rootIDX);
bal.lst.push(ActTrm.CLOSE_TERMINAL);
varlist=[];
varoptions={};
bal.lst.forEach((a)=>{
if(a!="---"){
if(options[a]!=null)
return;
options[a]=1;
list.push(a);
});
cpy.term.singleColumnMenu(list,{selectedIndex:bal.val},(err,rsp)=>{
if(cpy.rootDAT!=null){
if(rsp.selectedIndex==bal.lst.length-2){
cpy.rootDAT();
return;
if(rsp.selectedIndex==bal.lst.length-1){
(0,exports.closeTerminal)(cpy,bal,ste);
return;
if(bal.slv!=null)
bal.slv({trmBit:{idx:"update-terminal",lst:list,val:rsp.selectedIndex}});
});
exports.updateTerminal=updateTerminal;
constaddPort=async(cpy,bal,ste)=>{
if(bal.lst==null)
bal.lst=[];
bal.lst.forEach(async(a)=>{
switch(a.idx){
case"bus":
varlst=[];
for(varkeyinActTrm){
varidx=ActTrm[key];
if(idx==null)
continue;
if(idx.includes==null)
continue;
if(idx.includes('[')&&idx.includes(']')==false)
continue;
lst.push(idx);
cpy.port=a.dat;
varbit=awaitcpy.port.hunt(bal.src,{src:'terminal',lst,dat:ste.pivot});
break;
default:
break;
});
if(bal.slv!=null)
bal.slv({clrBit:{idx:"add-port",src:bal.idx}});
if(bal.slv!=null)
bal.slv({trmBit:{idx:"add-port"}});
exports.addPort=addPort;
varpatch=(ste,type,bale)=>ste.dispatch({type,bale});
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
exports.AddPort=exports.ADD_PORT=exports.ContentTerminal=exports.CONTENT_TERMINAL=exports.RootTerminal=exports.ROOT_TERMINAL=exports.CloseTerminal=exports.CLOSE_TERMINAL=exports.TableTerminal=exports.TABLE_TERMINAL=exports.InputTerminal=exports.INPUT_TERMINAL=exports.ClearTerminal=exports.CLEAR_TERMINAL=exports.UpdateTerminal=exports.UPDATE_TERMINAL=exports.WriteTerminal=exports.WRITE_TERMINAL=exports.FocusTerminal=exports.FOCUS_TERMINAL=exports.OpenTerminal=exports.OPEN_TERMINAL=exports.InitTerminal=exports.INIT_TERMINAL=void0;
exports.INIT_TERMINAL="[Terminalaction]InitTerminal";
classInitTerminal{
constructor(bale){
this.bale=bale;
this.type=exports.INIT_TERMINAL;
exports.InitTerminal=InitTerminal;
exports.OPEN_TERMINAL="[Terminalaction]OpenTerminal";
classOpenTerminal{
constructor(bale){
this.bale=bale;
this.type=exports.OPEN_TERMINAL;
exports.OpenTerminal=OpenTerminal;
exports.FOCUS_TERMINAL="[Terminalaction]FocusTerminal";
classFocusTerminal{
constructor(bale){
this.bale=bale;
this.type=exports.FOCUS_TERMINAL;
exports.FocusTerminal=FocusTerminal;
exports.WRITE_TERMINAL="[Terminalaction]WriteTerminal";
classWriteTerminal{
constructor(bale){
this.bale=bale;
this.type=exports.WRITE_TERMINAL;
exports.WriteTerminal=WriteTerminal;
exports.UPDATE_TERMINAL="[Terminalaction]UpdateTerminal";
classUpdateTerminal{
constructor(bale){
this.bale=bale;
this.type=exports.UPDATE_TERMINAL;
exports.UpdateTerminal=UpdateTerminal;
exports.CLEAR_TERMINAL="[Terminalaction]ClearTerminal";
classClearTerminal{
constructor(bale){
this.bale=bale;
this.type=exports.CLEAR_TERMINAL;
exports.ClearTerminal=ClearTerminal;
exports.INPUT_TERMINAL="[Terminalaction]InputTerminal";
classInputTerminal{
constructor(bale){
this.bale=bale;
this.type=exports.INPUT_TERMINAL;
exports.InputTerminal=InputTerminal;
exports.TABLE_TERMINAL="[Terminalaction]TableTerminal";
classTableTerminal{
constructor(bale){
this.bale=bale;
this.type=exports.TABLE_TERMINAL;
exports.TableTerminal=TableTerminal;
exports.CLOSE_TERMINAL="[Terminalaction]CloseTerminal";
classCloseTerminal{
constructor(bale){
this.bale=bale;
this.type=exports.CLOSE_TERMINAL;
exports.CloseTerminal=CloseTerminal;
exports.ROOT_TERMINAL="[Terminalaction]RootTerminal";
classRootTerminal{
constructor(bale){
this.bale=bale;
this.type=exports.ROOT_TERMINAL;
exports.RootTerminal=RootTerminal;
exports.CONTENT_TERMINAL="[Terminalaction]ContentTerminal";
classContentTerminal{
constructor(bale){
this.bale=bale;
this.type=exports.CONTENT_TERMINAL;
exports.ContentTerminal=ContentTerminal;
exports.ADD_PORT="[Terminalaction]AddPort";
classAddPort{
constructor(bale){
this.bale=bale;
this.type=exports.ADD_PORT;
exports.AddPort=AddPort;
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
exports.addPort=exports.focusTerminal=exports.contentTerminal=exports.clearTerminal=exports.openTerminal=exports.inputTerminal=exports.tableTerminal=exports.rootTerminal=exports.closeTerminal=exports.writeTerminal=exports.updateTerminal=exports.initTerminal=void0;
varterminal_buzz_1=require("./buz/terminal.buzz");
Object.defineProperty(exports,"initTerminal",{enumerable:true,get:function(){returnterminal_buzz_1.initTerminal;}});
varterminal_buzz_2=require("./buz/terminal.buzz");
Object.defineProperty(exports,"updateTerminal",{enumerable:true,get:function(){returnterminal_buzz_2.updateTerminal;}});
varterminal_buzz_3=require("./buz/terminal.buzz");
Object.defineProperty(exports,"writeTerminal",{enumerable:true,get:function(){returnterminal_buzz_3.writeTerminal;}});
varterminal_buzz_4=require("./buz/terminal.buzz");
Object.defineProperty(exports,"closeTerminal",{enumerable:true,get:function(){returnterminal_buzz_4.closeTerminal;}});
varterminal_buzz_5=require("./buz/terminal.buzz");
Object.defineProperty(exports,"rootTerminal",{enumerable:true,get:function(){returnterminal_buzz_5.rootTerminal;}});
varterminal_buzz_6=require("./buz/terminal.buzz");
Object.defineProperty(exports,"tableTerminal",{enumerable:true,get:function(){returnterminal_buzz_6.tableTerminal;}});
varterminal_buzz_7=require("./buz/terminal.buzz");
Object.defineProperty(exports,"inputTerminal",{enumerable:true,get:function(){returnterminal_buzz_7.inputTerminal;}});
varterminal_buzz_8=require("./buz/terminal.buzz");
Object.defineProperty(exports,"openTerminal",{enumerable:true,get:function(){returnterminal_buzz_8.openTerminal;}});
varterminal_buzz_9=require("./buz/terminal.buzz");
Object.defineProperty(exports,"clearTerminal",{enumerable:true,get:function(){returnterminal_buzz_9.clearTerminal;}});
varterminal_buzz_10=require("./buz/terminal.buzz");
Object.defineProperty(exports,"contentTerminal",{enumerable:true,get:function(){returnterminal_buzz_10.contentTerminal;}});
varterminal_buzz_11=require("./buz/terminal.buzz");
Object.defineProperty(exports,"focusTerminal",{enumerable:true,get:function(){returnterminal_buzz_11.focusTerminal;}});
varterminal_buzz_12=require("./buz/terminal.buzz");
Object.defineProperty(exports,"addPort",{enumerable:true,get:function(){returnterminal_buzz_12.addPort;}});
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
exports.TerminalModel=void0;
classTerminalModel{
constructor(){
this.idx='998.terminal';
this.port={};
this.clear=false;
exports.TerminalModel=TerminalModel;
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
exports.reducer=void0;
constclone=require("clone-deep");
constAct=require("./terminal.action");
constterminal_model_1=require("./terminal.model");
constBuzz=require("./terminal.buzzer");
functionreducer(model=newterminal_model_1.TerminalModel(),act,state){
switch(act.type){
caseAct.UPDATE_TERMINAL:
returnBuzz.updateTerminal(clone(model),act.bale,state);
caseAct.OPEN_TERMINAL:
returnBuzz.openTerminal(clone(model),act.bale,state);
caseAct.CLOSE_TERMINAL:
returnBuzz.closeTerminal(clone(model),act.bale,state);
caseAct.ROOT_TERMINAL:
returnBuzz.rootTerminal(clone(model),act.bale,state);
caseAct.CLEAR_TERMINAL:
returnBuzz.clearTerminal(clone(model),act.bale,state);
caseAct.WRITE_TERMINAL:
returnBuzz.writeTerminal(clone(model),act.bale,state);
caseAct.INIT_TERMINAL:
returnBuzz.initTerminal(clone(model),act.bale,state);
caseAct.INPUT_TERMINAL:
returnBuzz.inputTerminal(clone(model),act.bale,state);
caseAct.TABLE_TERMINAL:
returnBuzz.tableTerminal(clone(model),act.bale,state);
caseAct.FOCUS_TERMINAL:
returnBuzz.focusTerminal(clone(model),act.bale,state);
caseAct.CONTENT_TERMINAL:
returnBuzz.contentTerminal(clone(model),act.bale,state);
caseAct.ADD_PORT:
returnBuzz.addPort(clone(model),act.bale,state);
default:
returnmodel;
exports.reducer=reducer;
"usestrict";
var__decorate=(this&&this.__decorate)||function(decorators,target,key,desc){
varc=arguments.length,r=c<3?target:desc===null?desc=Object.getOwnPropertyDescriptor(target,key):desc,d;
if(typeofReflect==="object"&&typeofReflect.decorate==="function")r=Reflect.decorate(decorators,target,key,desc);
elsefor(vari=decorators.length-1;i>=0;i--)if(d=decorators[i])r=(c<3?d(r):c>3?d(target,key,r):d(target,key))||r;
returnc>3&&r&&Object.defineProperty(target,key,r),r;
var__metadata=(this&&this.__metadata)||function(k,v){
if(typeofReflect==="object"&&typeofReflect.metadata==="function")returnReflect.metadata(k,v);
Object.defineProperty(exports,"__esModule",{value:true});
consttypescript_ioc_1=require("typescript-ioc");
conststate_1=require("../99.core/state");
letTerminalUnit=classTerminalUnit{
constructor(state){
TerminalUnit=__decorate([
typescript_ioc_1.Singleton,
__metadata("design:paramtypes",[state_1.default])
],TerminalUnit);
exports.default=TerminalUnit;
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
exports.replaceUnit=exports.listUnit=exports.codeUnit=exports.createUnit=exports.updateUnit=exports.initUnit=void0;
constActPvt=require("../../00.pivot.unit/pivot.action");
constActDsk=require("../../96.disk.unit/disk.action");
constinitUnit=(cpy,bal,ste)=>{
debugger;
exports.initUnit=initUnit;
constupdateUnit=async(cpy,bal,ste)=>{
vardir=bal.src;
if(bal.sub!=null){
dir=bal.src;
bal.src=bal.idx;
bal.idx=bal.sub;
varbit;
varroot=bal.idx.split('.')[1];
varrootUpper=root.charAt(0).toUpperCase()+root.slice(1);
varnom=bal.dat;
varnomUpper=nom.charAt(0).toUpperCase()+nom.slice(1);
varbuzzFile='../'+dir+'/'+bal.src+'/'+bal.idx+'/buz/'+root+'.buzz.ts';
varbuzzerFile='../'+dir+'/'+bal.src+'/'+bal.idx+'/'+root+'.buzzer.ts';
varactionFile='../'+dir+'/'+bal.src+'/'+bal.idx+'/'+root+'.action.ts';
varreduceFile='../'+dir+'/'+bal.src+'/'+bal.idx+'/'+root+'.reduce.ts';
varexistBuzz=FS.existsSync(buzzFile);
varexistBuzzer=FS.existsSync(buzzerFile);
varexistAction=FS.existsSync(actionFile);
varexistReduce=FS.existsSync(reduceFile);
if(existBuzz==false||existAction==false||existReduce==false||existBuzzer==false){
if(bal.slv!=null)
bal.slv({untBit:{idx:"update-unit-error",src:'noexistonsourcefile'}});
return;
varlistBuzz=FS.readFileSync(buzzFile).toString().split('\n');
varlistBuzzer=FS.readFileSync(buzzerFile).toString().split('\n');
varlistAction=FS.readFileSync(actionFile).toString().split('\n');
varlistReduce=FS.readFileSync(reduceFile).toString().split('\n');
vardoT=require("dot");
constupdateBuzz=(lst)=>{
varhold=[];
varout=[];
lst.forEach((a,b)=>{
if(a.includes('import'))
hold.push(b);
});
vardex=0;
hold=hold.reverse();
varflag=false;
hold.forEach((a,b)=>{
if(flag==true)
return;
varnow=a-1;
varnxt=hold[b+1];
if(nxt==now){
dex=nxt;
else
flag=true;
});
varbuzNom=nom+rootUpper;
varcpyNom=rootUpper+'Model';
varbalNom=rootUpper+"Bit";
varlineList=cpy.buzzTemplate.toString().split("\n");
vargel={buzNom,cpyNom,balNom};
lineList.forEach((a,b)=>{
vardoTCompiled=doT.template(a);
varoutLine=doTCompiled(gel);
out.push(outLine);
});
return{lst:out,val:dex};
constupdateActionUpper=(lst)=>{
varout=[];
vardex=0;
lst.forEach((a,b)=>{
if(a.includes('exporttypeActions')==true)
dex=b;
});
varactUpr=nom+'_'+rootUpper;
actUpr=actUpr.toUpperCase();
varactMsg='['+nomUpper+'action]'+nomUpper+''+rootUpper;
varactTle=nomUpper+rootUpper;
varbitNom=rootUpper+"Bit";
varlineList=cpy.actTemplate.toString().split("\n");
vargel={actUpr,actMsg,actTle,bitNom};
lineList.forEach((a,b)=>{
vardoTCompiled=doT.template(a);
varoutLine=doTCompiled(gel);
out.push(outLine);
});
return{lst:out,val:dex};
constupdateActionLower=(lst)=>{
varout=[];
vardex=0;
lst.forEach((a,b)=>{
if(a.includes('exporttypeActions=')==true)
dex=b;
});
varactTle=nomUpper+rootUpper;
varlineList=cpy.actTemplateLower.toString().split("\n");
vargel={actTle};
lineList.forEach((a,b)=>{
vardoTCompiled=doT.template(a);
varoutLine=doTCompiled(gel);
out.push(outLine);
});
return{lst:out,val:dex};
constupdateReduce=(lst)=>{
varout=[];
vardex=0;
lst.forEach((a,b)=>{
if(a.includes('default')==true)
dex=b;
});
varactUpr=nom+'_'+rootUpper;
actUpr=actUpr.toUpperCase();
varactTle=nom+rootUpper;
varlineList=cpy.reduceTemplate.toString().split("\n");
vargel={actUpr,actTle};
lineList.forEach((a,b)=>{
vardoTCompiled=doT.template(a);
varoutLine=doTCompiled(gel);
out.push(outLine);
});
return{lst:out,val:dex};
constupdateBuzzer=(lst)=>{
varout=[];
varactTle=nom+rootUpper;
varlineList=cpy.buzzerTemplate.toString().split("\n");
vargel={actTle,root};
lineList.forEach((a,b)=>{
vardoTCompiled=doT.template(a);
varoutLine=doTCompiled(gel);
lst.push(outLine);
});
return{lst};
varbuzzBit=updateBuzz(listBuzz);
varbuzzerBit=updateBuzzer(listBuzzer);
varactionUpperBit=updateActionUpper(listAction);
varactionLowerBit=updateActionLower(listAction);
varreduceBit=updateReduce(listReduce);
constmerge=(a,b,i=0)=>{
returna.slice(0,i).concat(b,a.slice(i));
varresultBuzz=merge(listBuzz,buzzBit.lst,buzzBit.val);
varresultBuzzer=buzzerBit.lst.filter((e)=>{returne.length>2;});
varresultReduce=merge(listReduce,reduceBit.lst,reduceBit.val);
varresultActionUpper=merge(listAction,actionUpperBit.lst,actionUpperBit.val);
varupperActionDex=updateActionUpper(resultActionUpper).val;
varlowerDex=actionLowerBit.val;
varlowerActionList=listAction.slice(lowerDex,listAction.length);
lowerActionList.forEach((a,b)=>{
lowerActionList[b]=a.replace(';','');
});
lowerActionList=lowerActionList.filter((e)=>{
if(e.length>=2)
returne;
});
lowerActionList.push('|'+nomUpper+rootUpper);
lowerActionList.unshift('');
resultActionUpper=resultActionUpper.slice(0,upperActionDex);
varresultAction=resultActionUpper.concat(lowerActionList);
bit=awaitFS.writeFile(buzzFile,resultBuzz.join('\n'));
bit=awaitFS.writeFile(buzzerFile,resultBuzzer.join('\n'));
bit=awaitFS.writeFile(reduceFile,resultReduce.join('\n'));
bit=awaitFS.writeFile(actionFile,resultAction.join('\n'));
setTimeout(()=>{
if(bal.slv!=null)
bal.slv({untBit:{idx:"update-unit",dat:bal}});
},2111);
exports.updateUnit=updateUnit;
constcreateUnit=(cpy,bal,ste)=>{
if(bal.src==null)
bal.src="alligator";
const{fork}=require("child_process");
bal.src=S(bal.src).replaceAll('','_').s;
constchild=fork("./data/hand/001.create-unit.js",[bal.src]);
child.on("close",(cde)=>{
setTimeout(()=>{
if(bal.slv!=null)
bal.slv({untBit:{idx:"create-unit"}});
},3333);
});
exports.createUnit=createUnit;
constcodeUnit=(cpy,bal,ste)=>{
if(bal.src==null)
bal.src='111.symbol';
const{exec}=require('child_process');
process.chdir("../../studio/");
exec('startCode.exe../packages/'+bal.src,async(err,stdout,stderr)=>{
if(err){
console.error(`execerror:${err}`);
process.chdir("../packages/999.vurt");
if(bal.slv!=null)
bal.slv({cdeBit:{idx:"code-pivot",dat:{}}});
});
exports.codeUnit=codeUnit;
constlistUnit=(cpy,bal,ste)=>{
varpath='../'+bal.src+'/'+bal.src;
varoption=FS.pathExistsSync(path)
if(option==true){
varlist=FS.readdirSync('../'+bal.src+'/'+bal.src);
varlst=list.filter((e)=>{returne.includes('.unit')==true;});
bal.slv({untBit:{idx:"list-unit",lst,val:1}});
bal.slv({untBit:{idx:"list-unit",lst,val:0}});
exports.listUnit=listUnit;
constsublistUnit=(cpy,bal,ste)=>{
varpath='../'+bal.src+'/'+bal.idx;
varoption=FS.pathExistsSync(path)
if(option==true){
varlist=FS.readdirSync('../'+bal.src+'/'+bal.idx);
varlst=list.filter((e)=>{returne.includes('.unit')==true;});
bal.slv({untBit:{idx:"sublist-unit",lst,val:1}});
bal.slv({untBit:{idx:"sublist-unit",lst,val:0}});
exports.sublistUnit=sublistUnit;
conststackUnit=(cpy,bal,ste)=>{
varlist=FS.readdirSync('../'+bal.src+'/');
constlst=list.filter(fileName=>/^\d{3}\.[a-zA-Z]+$/.test(fileName));
bal.slv({untBit:{idx:"list-unit",lst,val:0}});
exports.stackUnit=stackUnit;
constfilterUnit=(cpy,bal,ste)=>{
varlist=FS.readdirSync('../'+bal.src+'/');
constlst=list.filter(fileName=>/^\d{3}\.[a-zA-Z]+$/.test(fileName));
bal.slv({untBit:{idx:"filter-unit",lst,val:0}});
exports.filterUnit=filterUnit;
constreplaceUnit=async(cpy,bal,ste)=>{
debugger;
varbit;
bit=awaitste.hunt(ActPvt.LIST_PIVOT);
varlist=bit.pvtBit.lst;
letfilter=list.filter((e)=>{returne!=cpy.idx;});
varfin='';
if(bal.idx=='pivot'){
bit=awaitste.bus(ActDsk.READ_DISK,{src:'./work/999.pivot.js'});
varvurt=bit.dskBit.dat;
bit=awaitste.bus(ActDsk.WRITE_DISK,{src:'../998.work/work/999.pivot.js',dat:vurt});
setTimeout(()=>{
if(bal.slv!=null)
bal.slv({untBit:{idx:"replace-unit"}});
},3333);
return;
if(bal.idx=='collect'){
debugger;
bit=awaitste.hunt(ActPvt.CONTAINS_PIVOT,{lst:filter,src:'collect'});
letfilterB=bit.pvtBit.lst.filter((e)=>{returne[0]!='999.pivot';});
debugger;
filterB.forEach(async(a)=>{
varsigh='999.pivot';
varremove='../'+a[0]+'/'+a[0]+'/'+a[1];
varcopy='../'+sigh+'/'+sigh+'/'+a[1];
debugger;
bit=awaitFS.ensureDir(remove);
bit=awaitFS.remove(remove);
bit=awaitFS.copy(copy,remove);
});
setTimeout(()=>{
if(bal.slv!=null)
bal.slv({untBit:{idx:"replace-unit",lst:filterB}});
},1333);
return;
switch(bal.idx){
case"bus":
fin='99.bus.unit';
break;
case"core":
fin='99.core';
break;
case"hunt":
fin='hunt.ts';
break;
filter.forEach((a)=>{
varsrc,out;
if(fin.includes('.')==true){
src='../'+a+'/'+a+'/'+fin;
out='./'+cpy.idx+'/'+fin;
else{
src='../'+a+'/'+a+'/'+fin;
out='./'+cpy.idx+'/'+fin;
FS.ensureDirSync(src);
FS.removeSync(src);
FS.copySync(out,src);
});
if(bal.slv!=null)
bal.slv({untBit:{idx:"replace-unit",lst:filter}});
exports.replaceUnit=replaceUnit;
constFS=require("fs-extra");
constS=require("string");
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
exports.ReplaceUnit=exports.REPLACE_UNIT=exports.ListUnit=exports.LIST_UNIT=exports.StackUnit=exports.STACK_UNIT=exports.CodeUnit=exports.CODE_UNIT=exports.UpdateUnit=exports.UPDATE_UNIT=exports.CreateUnit=exports.CREATE_UNIT=exports.InitUnit=exports.INIT_UNIT=void0;
exports.INIT_UNIT="[Unitaction]InitUnit";
classInitUnit{
constructor(bale){
this.bale=bale;
this.type=exports.INIT_UNIT;
exports.InitUnit=InitUnit;
exports.CREATE_UNIT="[Unitaction]CreateUnit";
classCreateUnit{
constructor(bale){
this.bale=bale;
this.type=exports.CREATE_UNIT;
exports.CreateUnit=CreateUnit;
exports.UPDATE_UNIT="[Unitaction]UpdateUnit";
classUpdateUnit{
constructor(bale){
this.bale=bale;
this.type=exports.UPDATE_UNIT;
exports.UpdateUnit=UpdateUnit;
exports.CODE_UNIT="[Codeaction]CodeUnit";
classCodeUnit{
constructor(bale){
this.bale=bale;
this.type=exports.CODE_UNIT;
exports.CodeUnit=CodeUnit;
exports.LIST_UNIT="[Codeaction]ListUnit";
classListUnit{
constructor(bale){
this.bale=bale;
this.type=exports.LIST_UNIT;
exports.ListUnit=ListUnit;
exports.SUBLIST_UNIT="[Codeaction]SublistUnit";
classSublistUnit{
constructor(bale){
this.bale=bale;
this.type=exports.SUBLIST_UNIT;
exports.SublistUnit=SublistUnit;
exports.STACK_UNIT="[Codeaction]StackUnit";
classStackUnit{
constructor(bale){
this.bale=bale;
this.type=exports.STACK_UNIT;
exports.StackUnit=StackUnit;
exports.REPLACE_UNIT="[Replaceaction]ReplaceUnit";
classReplaceUnit{
constructor(bale){
this.bale=bale;
this.type=exports.REPLACE_UNIT;
exports.ReplaceUnit=ReplaceUnit;
exports.FILTER_UNIT="[Replaceaction]FilterUnit";
classFilterUnit{
constructor(bale){
this.bale=bale;
this.type=exports.FILTER_UNIT;
exports.FilterUnit=FilterUnit;
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
exports.replaceUnit=exports.listUnit=exports.codeUnit=exports.updateUnit=exports.createUnit=exports.initUnit=void0;
varunit_buzz_1=require("./buz/unit.buzz");
Object.defineProperty(exports,"initUnit",{enumerable:true,get:function(){returnunit_buzz_1.initUnit;}});
varunit_buzz_2=require("./buz/unit.buzz");
Object.defineProperty(exports,"createUnit",{enumerable:true,get:function(){returnunit_buzz_2.createUnit;}});
varunit_buzz_3=require("./buz/unit.buzz");
Object.defineProperty(exports,"updateUnit",{enumerable:true,get:function(){returnunit_buzz_3.updateUnit;}});
varunit_buzz_4=require("./buz/unit.buzz");
Object.defineProperty(exports,"codeUnit",{enumerable:true,get:function(){returnunit_buzz_4.codeUnit;}});
varunit_buzz_5=require("./buz/unit.buzz");
Object.defineProperty(exports,"listUnit",{enumerable:true,get:function(){returnunit_buzz_5.listUnit;}});
varunit_buzz_6=require("./buz/unit.buzz");
Object.defineProperty(exports,"replaceUnit",{enumerable:true,get:function(){returnunit_buzz_6.replaceUnit;}});
varunit_buzz_7=require("./buz/unit.buzz");
Object.defineProperty(exports,"stackUnit",{enumerable:true,get:function(){returnunit_buzz_7.stackUnit;}});
varunit_buzz_8=require("./buz/unit.buzz");
Object.defineProperty(exports,"filterUnit",{enumerable:true,get:function(){returnunit_buzz_8.filterUnit;}});
varunit_buzz_9=require("./buz/unit.buzz");
Object.defineProperty(exports,"sublistUnit",{enumerable:true,get:function(){returnunit_buzz_9.sublistUnit;}});
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
exports.UnitModel=void0;
classUnitModel{
constructor(){
this.idx='02.unit';
this.buzzTemplate=`exportconst{{=it.buzNom}}=(cpy:{{=it.cpyNom}},bal:{{=it.balNom}},ste:State)=>{
debugger
};`;
this.buzzerTemplate=`export{{{=it.actTle}}}from"./buz/{{=it.root}}.buzz";`;
this.actTemplate=`exportconst{{=it.actUpr}}="{{=it.actMsg}}";
exportclass{{=it.actTle}}implementsAction{
readonlytype={{=it.actUpr}};
constructor(publicbale:{{=it.bitNom}}){}
}`;
this.actTemplateLower=`
exporttypeActions=|{{=it.actTle}}
this.reduceTemplate=`caseAct.{{=it.actUpr}}:
returnBuzz.{{=it.actTle}}(clone(model),act.bale,state);
exports.UnitModel=UnitModel;
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
exports.reducer=void0;
constclone=require("clone-deep");
constAct=require("./unit.action");
constunit_model_1=require("./unit.model");
constBuzz=require("./unit.buzzer");
functionreducer(model=newunit_model_1.UnitModel(),act,state){
switch(act.type){
caseAct.UPDATE_UNIT:
returnBuzz.updateUnit(clone(model),act.bale,state);
caseAct.INIT_UNIT:
returnBuzz.initUnit(clone(model),act.bale,state);
caseAct.CREATE_UNIT:
returnBuzz.createUnit(clone(model),act.bale,state);
caseAct.CODE_UNIT:
returnBuzz.codeUnit(clone(model),act.bale,state);
caseAct.LIST_UNIT:
returnBuzz.listUnit(clone(model),act.bale,state);
caseAct.SUBLIST_UNIT:
returnBuzz.sublistUnit(clone(model),act.bale,state);
caseAct.REPLACE_UNIT:
returnBuzz.replaceUnit(clone(model),act.bale,state);
caseAct.STACK_UNIT:
returnBuzz.stackUnit(clone(model),act.bale,state);
caseAct.FILTER_UNIT:
returnBuzz.filterUnit(clone(model),act.bale,state);
default:
returnmodel;
exports.reducer=reducer;
"usestrict";
var__decorate=(this&&this.__decorate)||function(decorators,target,key,desc){
varc=arguments.length,r=c<3?target:desc===null?desc=Object.getOwnPropertyDescriptor(target,key):desc,d;
if(typeofReflect==="object"&&typeofReflect.decorate==="function")r=Reflect.decorate(decorators,target,key,desc);
elsefor(vari=decorators.length-1;i>=0;i--)if(d=decorators[i])r=(c<3?d(r):c>3?d(target,key,r):d(target,key))||r;
returnc>3&&r&&Object.defineProperty(target,key,r),r;
var__metadata=(this&&this.__metadata)||function(k,v){
if(typeofReflect==="object"&&typeofReflect.metadata==="function")returnReflect.metadata(k,v);
Object.defineProperty(exports,"__esModule",{value:true});
consttypescript_ioc_1=require("typescript-ioc");
conststate_1=require("../99.core/state");
letUnitUnit=classUnitUnit{
constructor(state){
UnitUnit=__decorate([
typescript_ioc_1.Singleton,
__metadata("design:paramtypes",[state_1.default])
],UnitUnit);
exports.default=UnitUnit;
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
exports.UpdateBitmap=exports.UPDATE_BITMAP=exports.InitBitmap=exports.INIT_BITMAP=void0;
exports.INIT_BITMAP="[Bitmapaction]InitBitmap";
classInitBitmap{
constructor(bale){
this.bale=bale;
this.type=exports.INIT_BITMAP;
exports.InitBitmap=InitBitmap;
exports.UPDATE_BITMAP="[Bitmapaction]UpdateBitmap";
classUpdateBitmap{
constructor(bale){
this.bale=bale;
this.type=exports.UPDATE_BITMAP;
exports.UpdateBitmap=UpdateBitmap;
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
exports.updateBitmap=exports.initBitmap=void0;
varbitmap_buzz_1=require("./buz/bitmap.buzz");
Object.defineProperty(exports,"initBitmap",{enumerable:true,get:function(){returnbitmap_buzz_1.initBitmap;}});
varbitmap_buzz_2=require("./buz/bitmap.buzz");
Object.defineProperty(exports,"updateBitmap",{enumerable:true,get:function(){returnbitmap_buzz_2.updateBitmap;}});
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
exports.BitmapModel=void0;
classBitmapModel{
exports.BitmapModel=BitmapModel;
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
exports.reducer=void0;
constclone=require("clone-deep");
constAct=require("./bitmap.action");
constbitmap_model_1=require("./bitmap.model");
constBuzz=require("./bitmap.buzzer");
functionreducer(model=newbitmap_model_1.BitmapModel(),act,state){
switch(act.type){
caseAct.UPDATE_BITMAP:
returnBuzz.updateBitmap(clone(model),act.bale,state);
caseAct.INIT_BITMAP:
returnBuzz.initBitmap(clone(model),act.bale,state);
default:
returnmodel;
exports.reducer=reducer;
"usestrict";
var__decorate=(this&&this.__decorate)||function(decorators,target,key,desc){
varc=arguments.length,r=c<3?target:desc===null?desc=Object.getOwnPropertyDescriptor(target,key):desc,d;
if(typeofReflect==="object"&&typeofReflect.decorate==="function")r=Reflect.decorate(decorators,target,key,desc);
elsefor(vari=decorators.length-1;i>=0;i--)if(d=decorators[i])r=(c<3?d(r):c>3?d(target,key,r):d(target,key))||r;
returnc>3&&r&&Object.defineProperty(target,key,r),r;
var__metadata=(this&&this.__metadata)||function(k,v){
if(typeofReflect==="object"&&typeofReflect.metadata==="function")returnReflect.metadata(k,v);
Object.defineProperty(exports,"__esModule",{value:true});
consttypescript_ioc_1=require("typescript-ioc");
conststate_1=require("../99.core/state");
letBitmapUnit=classBitmapUnit{
constructor(state){
BitmapUnit=__decorate([
typescript_ioc_1.Singleton,
__metadata("design:paramtypes",[state_1.default])
],BitmapUnit);
exports.default=BitmapUnit;
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
exports.updateBitmap=exports.initBitmap=void0;
constinitBitmap=(cpy,bal,ste)=>{
debugger;
exports.initBitmap=initBitmap;
constupdateBitmap=(cpy,bal,ste)=>{
exports.updateBitmap=updateBitmap;
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
exports.typeDisk=exports.colorDisk=exports.swatchDisk=exports.existDisk=exports.deleteDisk=exports.ensureDisk=exports.trashDisk=exports.batchDisk=exports.frameDisk=exports.copyDisk=exports.load_listDisk=exports.indexDisk=exports.readDisk=exports.writeDisk=exports.updateDisk=exports.initDisk=void0;
constActDsk=require("../../96.disk.unit/disk.action");
varbit,lst,idx,val,dat,src;
constinitDisk=(cpy,bal,ste)=>{
cpy.local=bal.val;
lst=[ActDsk.UPDATE_DISK,ActDsk.WRITE_DISK,ActDsk.READ_DISK];
if(bal.slv!=null)
bal.slv({intBit:{idx:"init-disk",lst}});
exports.initDisk=initDisk;
constupdateDisk=async(cpy,bal,ste)=>{
bit=awaitste.hunt(ActDsk.READ_DISK,{src:bal.src});
bit=bit.dskBit;
lst=bit.lst;
lst.push(bal.dat);
bit=awaitste.hunt(ActDsk.WRITE_DISK,{src:bal.src,dat:lst.join('\n')});
if(bal.slv!=null)
bal.slv({dskBit:{idx:"update-disk",src:bal.src}});
exports.updateDisk=updateDisk;
constwriteDisk=async(cpy,bal,ste)=>{
if(bal.val==null)
bal.val=0;
if(bal.idx!=null)
bal.src=bal.idx;
if(bal.src==null){
if(bal.slv!=null)
returnbal.slv({dskBit:{idx:"write-disk-error",src:"nosource"}});
if(bal.dat==null){
if(bal.slv!=null)
returnbal.slv({dskBit:{idx:"write-disk-error",src:"nodata"}});
FS.ensureFileSync(bal.src);
bal;
if(bal.val==1)
bit=awaitFS.writeJson(bal.src,bal.dat);
else
bit=awaitFS.writeFile(bal.src,bal.dat);
bit;
setTimeout(()=>{
if(bal.slv!=null)
bal.slv({dskBit:{idx:"write-disk",src:bal.src}});
},3);
exports.writeDisk=writeDisk;
constreadDisk=async(cpy,bal,ste)=>{
if(bal.val==null)
bal.val=0;
FS.ensureFileSync(bal.src);
if(bal.val==1)
dat=FS.readJsonSync(bal.src);
else
dat=FS.readFileSync(bal.src).toString();
lst=[];
dat;
if(dat.split!=null){
lst=dat.split('\n');
if(bal.slv!=null)
bal.slv({dskBit:{idx:"read-disk",src:bal.src,dat,lst}});
exports.readDisk=readDisk;
constindexDisk=async(cpy,bal,ste)=>{
if((bal.src==null)&&(bal.slv!=null))
bal.slv({dskBit:{idx:"list-disk-error",src:'nosrcpresent'}});
if(bal.val==null)
bal.val=1;
lst=awaitFS.readdir(bal.src);
if(bal.slv!=null)
bal.slv({dskBit:{idx:"index-disk",src:bal.src,lst}});
exports.indexDisk=indexDisk;
constload_listDisk=async(cpy,bal,ste)=>{
bit=awaitste.hunt(ActDsk.INDEX_DISK,{src:bal.src});
lst=bit.dskBit.lst;
lst.forEach((a,b)=>{
lst[b]=bal.src+a;
});
varout=[];
lst.forEach(async(a,b)=>{
bit=awaitste.hunt(ActDsk.READ_DISK,{src:a});
out.push({src:a,dat:bit.dskBit.dat});
});
if(bal.slv!=null)
bal.slv({dskBit:{idx:"load-list-disk",src:bal.src,lst:out}});
exports.load_listDisk=load_listDisk;
constcopyDisk=async(cpy,bal,ste)=>{
lst=[];
if(bal.src==null){
if(bal.slv!=null)
returnbal.slv({dskBit:{idx:"write-directory-disk-error",src:"nosource"}});
if(bal.idx==null){
if(bal.slv!=null)
returnbal.slv({dskBit:{idx:"write-directory-disk-error",src:"notarget"}});
if(FS.lstatSync(bal.src).isDirectory()==false){
if(bal.slv!=null)
returnbal.slv({dskBit:{idx:"write-directory-disk-error",src:"nodirectory"}});
return;
FS.ensureDirSync(bal.src);
FS.ensureDirSync(bal.idx);
if(bal.val==null)
bal.val=0;
if(bal.val==0){
bit=awaitFS.remove(bal.idx);
if(bal.dat=='debug'){
lst.push("............");
lst.push("copying..."+bal.src);
lst.push("............");
bit=awaitFS.copy(bal.src,bal.idx);
setTimeout(()=>{
if(bal.slv!=null)
bal.slv({dskBit:{idx:"copy-disk",src:bal.src,dat:bal.idx,lst}});
},33);
exports.copyDisk=copyDisk;
constframeDisk=async(cpy,bal,ste)=>{
vardat=bal.dat;
vardataUrlRegExp=/^data:image\/\w+;base64,/;
varbase64Data=dat.replace(dataUrlRegExp,"");
varimageBuffer=Buffer.from(base64Data,"base64");
FS.ensureDirSync(bal.src);
varlist=FS.readdirSync(bal.src);
vardex=String(list.length).padStart(5,"0");
varfin=bal.src+dex+'.png';
varbit=awaitFS.writeFile(fin,imageBuffer);
if(bal.slv!=null)
bal.slv({dskBit:{idx:"frame-disk",src:bal.src,dat:dex}});
exports.frameDisk=frameDisk;
constbatchDisk=(cpy,bal,ste)=>{
varchild_process=require('child_process');
varspawn=child_process.spawn;
varls=spawn(bal.src);
ls.stdout.on('data',function(data){
});
ls.stderr.on('data',function(data){
});
ls.on('exit',function(code){
if(bal.slv!=null)
bal.slv({dskBit:{idx:"batch-disk",src:bal.src}});
});
exports.batchDisk=batchDisk;
consttrashDisk=async(cpy,bal,ste)=>{
varloc=bal.idx+'/'+bal.src;
bit=awaitFS.ensureDir(loc);
bit=awaitFS.emptyDir(loc);
if(bal.slv!=null)
bal.slv({dskBit:{idx:"trash-disk",src:loc}});
exports.trashDisk=trashDisk;
constensureDisk=async(cpy,bal,ste)=>{
bit=awaitFS.ensureDir(bal.src);
if(bal.slv!=null)
bal.slv({dskBit:{idx:"ensure-disk",src:bal.src}});
exports.ensureDisk=ensureDisk;
constdeleteDisk=(cpy,bal,ste)=>{
lst=[];
if(bal.idx!=null)
bal.src=bal.idx;
bit=FS.remove(bal.src,err=>{
if(err)
returnconsole.error(err);
lst.push('deleting!'+bal.src);
if(bal.slv!=null)
bal.slv({dskBit:{idx:"delete-disk",src:bal.src,lst}});
});
exports.deleteDisk=deleteDisk;
constexistDisk=(cpy,bal,ste)=>{
letfileExists=FS.existsSync(bal.src);
if(bal.slv!=null)
bal.slv({dskBit:{idx:"exist-disk",src:fileExists}});
exports.existDisk=existDisk;
constswatchDisk=(cpy,bal,ste)=>{
if(bal.src==null)
bal.src='./data/swatch.png';
if(bal.idx==null)
bal.idx='FF00FF';
varPNG=require("pngjs").PNG;
varconvert=require('color-convert');
varrgb=convert.hex.rgb(bal.idx);
FS.ensureFileSync(bal.src);
letnewfile=newPNG({width:128,height:128});
for(lety=0;y<newfile.height;y++){
for(letx=0;x<newfile.width;x++){
letidx=(newfile.width*y+x)<<2;
newfile.data[idx]=rgb[0];
newfile.data[idx+1]=rgb[1];
newfile.data[idx+2]=rgb[2];
newfile.data[idx+3]=0xff;
newfile
.pack()
.pipe(FS.createWriteStream(bal.src))
.on("finish",function(){
if(bal.slv!=null)
bal.slv({dskBit:{idx:"swatch-disk",src:bal.src}});
});
exports.swatchDisk=swatchDisk;
constcolorDisk=(cpy,bal,ste)=>{
varPNG=require("pngjs").PNG;
varconvert=require('color-convert');
varr,g,b;
varhex;
bal.src;
FS.createReadStream(bal.src)
.pipe(newPNG({
filterType:4,
}))
.on("parsed",function(){
for(vary=0;y<this.height;y++){
for(varx=0;x<this.width;x++){
varidx=(this.width*y+x)<<2;
r=this.data[idx];
g=this.data[idx+1];
b=this.data[idx+2];
hex=convert.rgb.hex([r,g,b]);
dat={r,g,b,hex};
if(bal.slv!=null)
bal.slv({dskBit:{idx:"color-disk",dat}});
});
exports.colorDisk=colorDisk;
consttypeDisk=(cpy,bal,ste)=>{
if(bal.src!=null)
bal.idx=bal.src;
varflag=FS.lstatSync(bal.idx).isDirectory();
src='file';
if(flag==true)
src='directory';
bal.slv({dskBit:{idx:"type-disk",src}});
exports.typeDisk=typeDisk;
constFS=require("fs-extra");
(async()=>{
constrawResponse=awaitfetch(loc,{
method:"POST",
headers:{
Accept:"application/json",
"Content-Type":"application/json",
body:JSON.stringify({src}),
});
constcontent=awaitrawResponse.json();
})();
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
exports.TypeDisk=exports.TYPE_DISK=exports.ColorDisk=exports.COLOR_DISK=exports.SwatchDisk=exports.SWATCH_DISK=exports.ExistDisk=exports.EXIST_DISK=exports.DeleteDisk=exports.DELETE_DISK=exports.EnsureDisk=exports.ENSURE_DISK=exports.TrashDisk=exports.TRASH_DISK=exports.BatchDisk=exports.BATCH_DISK=exports.FrameDisk=exports.FRAME_DISK=exports.CopyDisk=exports.COPY_DISK=exports.Load_listDisk=exports.LOAD_LIST_DISK=exports.IndexDisk=exports.INDEX_DISK=exports.WriteDisk=exports.WRITE_DISK=exports.ReadDisk=exports.READ_DISK=exports.UpdateDisk=exports.UPDATE_DISK=exports.InitDisk=exports.INIT_DISK=void0;
exports.INIT_DISK='[Diskaction]InitDisk';
classInitDisk{
constructor(bale){
this.bale=bale;
this.type=exports.INIT_DISK;
exports.InitDisk=InitDisk;
exports.UPDATE_DISK='[Diskaction]UpdateDisk';
classUpdateDisk{
constructor(bale){
this.bale=bale;
this.type=exports.UPDATE_DISK;
exports.UpdateDisk=UpdateDisk;
exports.READ_DISK='[Diskaction]ReadDisk';
classReadDisk{
constructor(bale){
this.bale=bale;
this.type=exports.READ_DISK;
exports.ReadDisk=ReadDisk;
exports.WRITE_DISK='[Diskaction]WriteDisk';
classWriteDisk{
constructor(bale){
this.bale=bale;
this.type=exports.WRITE_DISK;
exports.WriteDisk=WriteDisk;
exports.INDEX_DISK='[Indexaction]IndexDisk';
classIndexDisk{
constructor(bale){
this.bale=bale;
this.type=exports.INDEX_DISK;
exports.IndexDisk=IndexDisk;
exports.LOAD_LIST_DISK='[Load_listaction]Load_listDisk';
classLoad_listDisk{
constructor(bale){
this.bale=bale;
this.type=exports.LOAD_LIST_DISK;
exports.Load_listDisk=Load_listDisk;
exports.COPY_DISK='[Copyaction]CopyDisk';
classCopyDisk{
constructor(bale){
this.bale=bale;
this.type=exports.COPY_DISK;
exports.CopyDisk=CopyDisk;
exports.FRAME_DISK='[Frameaction]FrameDisk';
classFrameDisk{
constructor(bale){
this.bale=bale;
this.type=exports.FRAME_DISK;
exports.FrameDisk=FrameDisk;
exports.BATCH_DISK='[Batchaction]BatchDisk';
classBatchDisk{
constructor(bale){
this.bale=bale;
this.type=exports.BATCH_DISK;
exports.BatchDisk=BatchDisk;
exports.TRASH_DISK='[Trashaction]TrashDisk';
classTrashDisk{
constructor(bale){
this.bale=bale;
this.type=exports.TRASH_DISK;
exports.TrashDisk=TrashDisk;
exports.ENSURE_DISK='[Ensureaction]EnsureDisk';
classEnsureDisk{
constructor(bale){
this.bale=bale;
this.type=exports.ENSURE_DISK;
exports.EnsureDisk=EnsureDisk;
exports.DELETE_DISK='[Deleteaction]DeleteDisk';
classDeleteDisk{
constructor(bale){
this.bale=bale;
this.type=exports.DELETE_DISK;
exports.DeleteDisk=DeleteDisk;
exports.EXIST_DISK="[Existaction]ExistDisk";
classExistDisk{
constructor(bale){
this.bale=bale;
this.type=exports.EXIST_DISK;
exports.ExistDisk=ExistDisk;
exports.SWATCH_DISK="[Swatchaction]SwatchDisk";
classSwatchDisk{
constructor(bale){
this.bale=bale;
this.type=exports.SWATCH_DISK;
exports.SwatchDisk=SwatchDisk;
exports.COLOR_DISK="[Coloraction]ColorDisk";
classColorDisk{
constructor(bale){
this.bale=bale;
this.type=exports.COLOR_DISK;
exports.ColorDisk=ColorDisk;
exports.TYPE_DISK="[Typeaction]TypeDisk";
classTypeDisk{
constructor(bale){
this.bale=bale;
this.type=exports.TYPE_DISK;
exports.TypeDisk=TypeDisk;
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
exports.typeDisk=exports.colorDisk=exports.swatchDisk=exports.existDisk=exports.deleteDisk=exports.ensureDisk=exports.trashDisk=exports.batchDisk=exports.frameDisk=exports.copyDisk=exports.load_listDisk=exports.indexDisk=exports.readDisk=exports.writeDisk=exports.updateDisk=exports.initDisk=void0;
vardisk_buzz_1=require("./buz/disk.buzz");
Object.defineProperty(exports,"initDisk",{enumerable:true,get:function(){returndisk_buzz_1.initDisk;}});
vardisk_buzz_2=require("./buz/disk.buzz");
Object.defineProperty(exports,"updateDisk",{enumerable:true,get:function(){returndisk_buzz_2.updateDisk;}});
vardisk_buzz_3=require("./buz/disk.buzz");
Object.defineProperty(exports,"writeDisk",{enumerable:true,get:function(){returndisk_buzz_3.writeDisk;}});
vardisk_buzz_4=require("./buz/disk.buzz");
Object.defineProperty(exports,"readDisk",{enumerable:true,get:function(){returndisk_buzz_4.readDisk;}});
vardisk_buzz_5=require("./buz/disk.buzz");
Object.defineProperty(exports,"indexDisk",{enumerable:true,get:function(){returndisk_buzz_5.indexDisk;}});
vardisk_buzz_6=require("./buz/disk.buzz");
Object.defineProperty(exports,"load_listDisk",{enumerable:true,get:function(){returndisk_buzz_6.load_listDisk;}});
vardisk_buzz_7=require("./buz/disk.buzz");
Object.defineProperty(exports,"copyDisk",{enumerable:true,get:function(){returndisk_buzz_7.copyDisk;}});
vardisk_buzz_8=require("./buz/disk.buzz");
Object.defineProperty(exports,"frameDisk",{enumerable:true,get:function(){returndisk_buzz_8.frameDisk;}});
vardisk_buzz_9=require("./buz/disk.buzz");
Object.defineProperty(exports,"batchDisk",{enumerable:true,get:function(){returndisk_buzz_9.batchDisk;}});
vardisk_buzz_10=require("./buz/disk.buzz");
Object.defineProperty(exports,"trashDisk",{enumerable:true,get:function(){returndisk_buzz_10.trashDisk;}});
vardisk_buzz_11=require("./buz/disk.buzz");
Object.defineProperty(exports,"ensureDisk",{enumerable:true,get:function(){returndisk_buzz_11.ensureDisk;}});
vardisk_buzz_12=require("./buz/disk.buzz");
Object.defineProperty(exports,"deleteDisk",{enumerable:true,get:function(){returndisk_buzz_12.deleteDisk;}});
vardisk_buzz_13=require("./buz/disk.buzz");
Object.defineProperty(exports,"existDisk",{enumerable:true,get:function(){returndisk_buzz_13.existDisk;}});
vardisk_buzz_14=require("./buz/disk.buzz");
Object.defineProperty(exports,"swatchDisk",{enumerable:true,get:function(){returndisk_buzz_14.swatchDisk;}});
vardisk_buzz_15=require("./buz/disk.buzz");
Object.defineProperty(exports,"colorDisk",{enumerable:true,get:function(){returndisk_buzz_15.colorDisk;}});
vardisk_buzz_16=require("./buz/disk.buzz");
Object.defineProperty(exports,"typeDisk",{enumerable:true,get:function(){returndisk_buzz_16.typeDisk;}});
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
exports.DiskModel=void0;
classDiskModel{
constructor(){
this.local=0;
exports.DiskModel=DiskModel;
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
exports.reducer=void0;
constclone=require("clone-deep");
constAct=require("./disk.action");
constdisk_model_1=require("./disk.model");
constBuzz=require("./disk.buzzer");
functionreducer(model=newdisk_model_1.DiskModel(),act,state){
switch(act.type){
caseAct.UPDATE_DISK:
returnBuzz.updateDisk(clone(model),act.bale,state);
caseAct.INIT_DISK:
returnBuzz.initDisk(clone(model),act.bale,state);
caseAct.WRITE_DISK:
returnBuzz.writeDisk(clone(model),act.bale,state);
caseAct.READ_DISK:
returnBuzz.readDisk(clone(model),act.bale,state);
caseAct.INDEX_DISK:
returnBuzz.indexDisk(clone(model),act.bale,state);
caseAct.LOAD_LIST_DISK:
returnBuzz.load_listDisk(clone(model),act.bale,state);
caseAct.COPY_DISK:
returnBuzz.copyDisk(clone(model),act.bale,state);
caseAct.FRAME_DISK:
returnBuzz.frameDisk(clone(model),act.bale,state);
caseAct.BATCH_DISK:
returnBuzz.batchDisk(clone(model),act.bale,state);
caseAct.TRASH_DISK:
returnBuzz.trashDisk(clone(model),act.bale,state);
caseAct.ENSURE_DISK:
returnBuzz.ensureDisk(clone(model),act.bale,state);
caseAct.DELETE_DISK:
returnBuzz.deleteDisk(clone(model),act.bale,state);
caseAct.EXIST_DISK:
returnBuzz.existDisk(clone(model),act.bale,state);
caseAct.SWATCH_DISK:
returnBuzz.swatchDisk(clone(model),act.bale,state);
caseAct.COLOR_DISK:
returnBuzz.colorDisk(clone(model),act.bale,state);
caseAct.TYPE_DISK:
returnBuzz.typeDisk(clone(model),act.bale,state);
default:
returnmodel;
exports.reducer=reducer;
"usestrict";
var__decorate=(this&&this.__decorate)||function(decorators,target,key,desc){
varc=arguments.length,r=c<3?target:desc===null?desc=Object.getOwnPropertyDescriptor(target,key):desc,d;
if(typeofReflect==="object"&&typeofReflect.decorate==="function")r=Reflect.decorate(decorators,target,key,desc);
elsefor(vari=decorators.length-1;i>=0;i--)if(d=decorators[i])r=(c<3?d(r):c>3?d(target,key,r):d(target,key))||r;
returnc>3&&r&&Object.defineProperty(target,key,r),r;
var__metadata=(this&&this.__metadata)||function(k,v){
if(typeofReflect==="object"&&typeofReflect.metadata==="function")returnReflect.metadata(k,v);
Object.defineProperty(exports,"__esModule",{value:true});
consttypescript_ioc_1=require("typescript-ioc");
letDiskUnit=classDiskUnit{
constructor(){}
DiskUnit=__decorate([
typescript_ioc_1.Singleton,
__metadata("design:paramtypes",[])
],DiskUnit);
exports.default=DiskUnit;
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
exports.formatCollect=exports.dotCollect=exports.emptyCollect=exports.deleteCollect=exports.modelCollect=exports.getCollect=exports.putCollect=exports.removeCollect=exports.createCollect=exports.writeCollect=exports.readCollect=exports.fetchCollect=exports.updateCollect=exports.initCollect=void0;
constActCol=require("../../97.collect.unit/collect.action");
varbit,lst,dat,idx,val,src,dex;
constinitCollect=(cpy,bal,ste)=>{
exports.initCollect=initCollect;
constupdateCollect=(cpy,bal,ste)=>{
exports.updateCollect=updateCollect;
constfetchCollect=(cpy,bal,ste)=>{
if(bal.val==null)
bal.val=1;
if((bal.bit==null))
bal.slv({clcBit:{idx:"fetch-collect-err",src:'no-bit'}});
vartype=bal.bit.split('').slice(-1).pop().toLowerCase();
varcabBit=cpy.caboodleBitList[cpy.caboodleBits[type]];
if(bal.val==1)
bit=cabBit.bitList[0];
else
bit=cabBit;
if(bal.slv!=null)
bal.slv({clcBit:{idx:"fetch-collect",dat:bit}});
exports.fetchCollect=fetchCollect;
constreadCollect=async(cpy,bal,ste)=>{
if((bal.bit==null))
bal.slv({clcBit:{idx:"read-collect-err",src:'no-bit'}});
vartype=bal.bit.split('').slice(-1).pop().toLowerCase();
if(cpy.caboodleBits[type]==null)
(0,exports.createCollect)(cpy,{idx:type},ste);
varcabBit=cpy.caboodleBitList[cpy.caboodleBits[type]];
if(cabBit.bits[bal.idx]==null){
bit=awaitste.hunt(ActCol.WRITE_COLLECT,{idx:bal.idx,src:bal.src,bit:bal.bit});
else{
dat=cabBit.bitList[cabBit.bits[bal.idx]];
if(bal.slv!=null)
bal.slv({clcBit:{idx:"read-collect",dat}});
exports.readCollect=readCollect;
constwriteCollect=async(cpy,bal,ste)=>{
dat=null;
vartype=bal.bit.split('').slice(-1).pop().toLowerCase();
if(cpy.caboodleBits[type]==null)
(0,exports.createCollect)(cpy,{idx:type},ste);
if((bal.bit==null))
bal.slv({rskBit:{idx:"write-collect-err",src:'no-bit'}});
varcabBit=cpy.caboodleBitList[cpy.caboodleBits[type]];
bal.idx;
if(cabBit.bits[bal.idx]==null){
bit=awaitste.hunt(bal.bit,{idx:bal.idx,src:bal.src,dat:bal.dat});
varobjDat=bit[Object.keys(bit)[0]];
dat=objDat.dat;
if(dat==null)
dat={};
dat.dex=cabBit.bitList.length;
cabBit.bitList.push(dat);
varidx=bal.idx;
if(idx==null)
idx=dat.idx;
if(idx==null)
thrownewError("writecollecthasnoidx");
cabBit.bits[idx]=dat.dex;
else{
varcabDat=cabBit.bitList[cabBit.bits[bal.idx]];
bal.dat;
for(varkeyinbal.dat){
if(cabDat==null)
cabDat={};
cabDat[key]=bal.dat[key];
cabBit.bitList[cabBit.bits[bal.idx]]=cabDat;
dat=cabBit;
if((dat==null)&&(bal.slv!=null))
bal.slv({rskBit:{idx:"write-collect-err",src:'no-dat'}});
if(bal.slv!=null)
bal.slv({clcBit:{idx:"write-collect",dat}});
exports.writeCollect=writeCollect;
constcreateCollect=(cpy,bal,ste)=>{
varcabBit={idx:bal.idx,dex:0,bits:{},bitList:[]};
cabBit.dex=cpy.caboodleBitList.length;
cpy.caboodleBitList.push(cabBit);
cpy.caboodleBits[cabBit.idx]=cabBit.dex;
if(bal.slv!=null)
bal.slv({clcBit:{idx:"create-collect",dat:cabBit}});
exports.createCollect=createCollect;
constremoveCollect=async(cpy,bal,ste)=>{
vartype=bal.bit.split('').slice(-1).pop().toLowerCase();
if(cpy.caboodleBits[type]==null)
returnbal.slv({rskBit:{idx:"remove-collect-not-present"}});
varcabBit=cpy.caboodleBitList[cpy.caboodleBits[type]];
if(cabBit.bits[bal.idx]==null)
returnbal.slv({rskBit:{idx:"remove-collect-idx-not-present"}});
bit=awaitste.hunt(bal.bit,{idx:bal.idx,src:bal.src,dat:bal.dat});
varobjDat=bit[Object.keys(bit)[0]];
dat=objDat.dat;
dex=dat.dex;
for(vari=dex;i<cabBit.bitList.length-1;i++){
varupdate=cabBit.bitList[i];
update.dex-=1;
for(varkeyindat){
dat[key]=null;
deletecabBit.bits[bal.idx];
varitm=cabBit.bitList.splice(dex,1);
cabBit.dex-=1;
if(bal.slv!=null)
bal.slv({clcBit:{idx:"remove-collect",dat:itm[0]}});
exports.removeCollect=removeCollect;
constputCollect=(cpy,bal,ste)=>{
cpy.caboodleBits[bal.idx]=bal.val;
cpy.caboodleBitList[bal.val]=bal.dat;
if(bal.slv!=null)
bal.slv({clcBit:{idx:"put-collect",dat:bal.dat}});
exports.putCollect=putCollect;
constgetCollect=(cpy,bal,ste)=>{
val=cpy.caboodleBits[bal.idx];
dat=cpy.caboodleBitList[val];
if(bal.slv!=null)
bal.slv({clcBit:{idx:"get-collect",val,dat}});
exports.getCollect=getCollect;
constmodelCollect=(cpy,bal,ste)=>{
if(bal.slv!=null)
bal.slv({clcBit:{idx:"model-collect",dat:cpy}});
exports.modelCollect=modelCollect;
constdeleteCollect=(cpy,bal,ste)=>{
exports.deleteCollect=deleteCollect;
constemptyCollect=(cpy,bal,ste)=>{
exports.emptyCollect=emptyCollect;
constdotCollect=(cpy,bal,ste)=>{
vargel=bal.dat;
varout=[];
bal.src.split("\n").forEach((a,b)=>{
return;
vardoTCompiled=doT.template(a);
varoutLine=doTCompiled(gel);
out.push(outLine);
});
if(bal.slv!=null)
bal.slv({colBit:{idx:"dot-vurt",lst:out,src:out.join('\n')}});
exports.dotCollect=dotCollect;
constformatCollect=(cpy,bal,ste)=>{
lst=bal.src.split(':');
varidx=lst[0];
varout=[];
idx=S(idx).collapseWhitespace().s;
varopt=lst[1].split(',');
opt.forEach((a,b)=>{
varnow=S(a).collapseWhitespace().s;
if(a.length<1)
return;
out.push(now);
});
dat=[idx,out];
bal.slv({colBit:{idx:"format-collect",dat}});
exports.formatCollect=formatCollect;
constS=require("string");
constdoT=require("dot");
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
exports.DotCollect=exports.DOT_COLLECT=exports.FormatCollect=exports.FORMAT_COLLECT=exports.GetCollect=exports.GET_COLLECT=exports.PutCollect=exports.PUT_COLLECT=exports.ModelCollect=exports.MODEL_COLLECT=exports.EmptyCollect=exports.EMPTY_COLLECT=exports.DeleteCollect=exports.DELETE_COLLECT=exports.RemoveCollect=exports.REMOVE_COLLECT=exports.CreateCollect=exports.CREATE_COLLECT=exports.WriteCollect=exports.WRITE_COLLECT=exports.ReadCollect=exports.READ_COLLECT=exports.FetchCollect=exports.FETCH_COLLECT=exports.UpdateCollect=exports.UPDATE_COLLECT=exports.InitCollect=exports.INIT_COLLECT=void0;
exports.INIT_COLLECT="[Collectaction]InitCollect";
classInitCollect{
constructor(bale){
this.bale=bale;
this.type=exports.INIT_COLLECT;
exports.InitCollect=InitCollect;
exports.UPDATE_COLLECT="[Collectaction]UpdateCollect";
classUpdateCollect{
constructor(bale){
this.bale=bale;
this.type=exports.UPDATE_COLLECT;
exports.UpdateCollect=UpdateCollect;
exports.FETCH_COLLECT="[Collectaction]FetchCollect";
classFetchCollect{
constructor(bale){
this.bale=bale;
this.type=exports.FETCH_COLLECT;
exports.FetchCollect=FetchCollect;
exports.READ_COLLECT="[Readaction]ReadCollect";
classReadCollect{
constructor(bale){
this.bale=bale;
this.type=exports.READ_COLLECT;
exports.ReadCollect=ReadCollect;
exports.WRITE_COLLECT="[Writeaction]WriteCollect";
classWriteCollect{
constructor(bale){
this.bale=bale;
this.type=exports.WRITE_COLLECT;
exports.WriteCollect=WriteCollect;
exports.CREATE_COLLECT="[Createaction]CreateCollect";
classCreateCollect{
constructor(bale){
this.bale=bale;
this.type=exports.CREATE_COLLECT;
exports.CreateCollect=CreateCollect;
exports.REMOVE_COLLECT="[Createaction]RemoveCollect";
classRemoveCollect{
constructor(bale){
this.bale=bale;
this.type=exports.REMOVE_COLLECT;
exports.RemoveCollect=RemoveCollect;
exports.DELETE_COLLECT="[Createaction]DeleteCollect";
classDeleteCollect{
constructor(bale){
this.bale=bale;
this.type=exports.DELETE_COLLECT;
exports.DeleteCollect=DeleteCollect;
exports.EMPTY_COLLECT="[Emptyaction]EmptyCollect";
classEmptyCollect{
constructor(bale){
this.bale=bale;
this.type=exports.EMPTY_COLLECT;
exports.EmptyCollect=EmptyCollect;
exports.MODEL_COLLECT="[Emptyaction]ModelCollect";
classModelCollect{
constructor(bale){
this.bale=bale;
this.type=exports.MODEL_COLLECT;
exports.ModelCollect=ModelCollect;
exports.PUT_COLLECT="[Emptyaction]PutCollect";
classPutCollect{
constructor(bale){
this.bale=bale;
this.type=exports.PUT_COLLECT;
exports.PutCollect=PutCollect;
exports.GET_COLLECT="[Emptyaction]GetCollect";
classGetCollect{
constructor(bale){
this.bale=bale;
this.type=exports.GET_COLLECT;
exports.GetCollect=GetCollect;
exports.FORMAT_COLLECT="[Formataction]FormatCollect";
classFormatCollect{
constructor(bale){
this.bale=bale;
this.type=exports.FORMAT_COLLECT;
exports.FormatCollect=FormatCollect;
exports.DOT_COLLECT="[Formataction]DotCollect";
classDotCollect{
constructor(bale){
this.bale=bale;
this.type=exports.DOT_COLLECT;
exports.DotCollect=DotCollect;
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
exports.dotCollect=exports.formatCollect=exports.getCollect=exports.putCollect=exports.modelCollect=exports.removeCollect=exports.deleteCollect=exports.fetchCollect=exports.emptyCollect=exports.createCollect=exports.writeCollect=exports.readCollect=exports.updateCollect=exports.initCollect=void0;
varcollect_buzz_1=require("./buz/collect.buzz");
Object.defineProperty(exports,"initCollect",{enumerable:true,get:function(){returncollect_buzz_1.initCollect;}});
varcollect_buzz_2=require("./buz/collect.buzz");
Object.defineProperty(exports,"updateCollect",{enumerable:true,get:function(){returncollect_buzz_2.updateCollect;}});
varcollect_buzz_3=require("./buz/collect.buzz");
Object.defineProperty(exports,"readCollect",{enumerable:true,get:function(){returncollect_buzz_3.readCollect;}});
varcollect_buzz_4=require("./buz/collect.buzz");
Object.defineProperty(exports,"writeCollect",{enumerable:true,get:function(){returncollect_buzz_4.writeCollect;}});
varcollect_buzz_5=require("./buz/collect.buzz");
Object.defineProperty(exports,"createCollect",{enumerable:true,get:function(){returncollect_buzz_5.createCollect;}});
varcollect_buzz_6=require("./buz/collect.buzz");
Object.defineProperty(exports,"emptyCollect",{enumerable:true,get:function(){returncollect_buzz_6.emptyCollect;}});
varcollect_buzz_7=require("./buz/collect.buzz");
Object.defineProperty(exports,"fetchCollect",{enumerable:true,get:function(){returncollect_buzz_7.fetchCollect;}});
varcollect_buzz_8=require("./buz/collect.buzz");
Object.defineProperty(exports,"deleteCollect",{enumerable:true,get:function(){returncollect_buzz_8.deleteCollect;}});
varcollect_buzz_9=require("./buz/collect.buzz");
Object.defineProperty(exports,"removeCollect",{enumerable:true,get:function(){returncollect_buzz_9.removeCollect;}});
varcollect_buzz_10=require("./buz/collect.buzz");
Object.defineProperty(exports,"modelCollect",{enumerable:true,get:function(){returncollect_buzz_10.modelCollect;}});
varcollect_buzz_11=require("./buz/collect.buzz");
Object.defineProperty(exports,"putCollect",{enumerable:true,get:function(){returncollect_buzz_11.putCollect;}});
varcollect_buzz_12=require("./buz/collect.buzz");
Object.defineProperty(exports,"getCollect",{enumerable:true,get:function(){returncollect_buzz_12.getCollect;}});
varcollect_buzz_13=require("./buz/collect.buzz");
Object.defineProperty(exports,"formatCollect",{enumerable:true,get:function(){returncollect_buzz_13.formatCollect;}});
varcollect_buzz_14=require("./buz/collect.buzz");
Object.defineProperty(exports,"dotCollect",{enumerable:true,get:function(){returncollect_buzz_14.dotCollect;}});
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
exports.CollectModel=void0;
classCollectModel{
constructor(){
this.idx='23.11.14';
this.caboodleBitList=[];
this.caboodleBits={};
exports.CollectModel=CollectModel;
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
exports.reducer=void0;
constclone=require("clone-deep");
constAct=require("./collect.action");
constcollect_model_1=require("./collect.model");
constBuzz=require("./collect.buzzer");
functionreducer(model=newcollect_model_1.CollectModel(),act,state){
switch(act.type){
caseAct.UPDATE_COLLECT:
returnBuzz.updateCollect(clone(model),act.bale,state);
caseAct.INIT_COLLECT:
returnBuzz.initCollect(clone(model),act.bale,state);
caseAct.READ_COLLECT:
returnBuzz.readCollect(clone(model),act.bale,state);
caseAct.WRITE_COLLECT:
returnBuzz.writeCollect(clone(model),act.bale,state);
caseAct.CREATE_COLLECT:
returnBuzz.createCollect(clone(model),act.bale,state);
caseAct.DELETE_COLLECT:
returnBuzz.deleteCollect(clone(model),act.bale,state);
caseAct.REMOVE_COLLECT:
returnBuzz.removeCollect(clone(model),act.bale,state);
caseAct.EMPTY_COLLECT:
returnBuzz.emptyCollect(clone(model),act.bale,state);
caseAct.FETCH_COLLECT:
returnBuzz.fetchCollect(clone(model),act.bale,state);
caseAct.MODEL_COLLECT:
returnBuzz.modelCollect(clone(model),act.bale,state);
caseAct.GET_COLLECT:
returnBuzz.getCollect(clone(model),act.bale,state);
caseAct.PUT_COLLECT:
returnBuzz.putCollect(clone(model),act.bale,state);
caseAct.FORMAT_COLLECT:
returnBuzz.formatCollect(clone(model),act.bale,state);
caseAct.DOT_COLLECT:
returnBuzz.dotCollect(clone(model),act.bale,state);
default:
returnmodel;
exports.reducer=reducer;
"usestrict";
var__decorate=(this&&this.__decorate)||function(decorators,target,key,desc){
varc=arguments.length,r=c<3?target:desc===null?desc=Object.getOwnPropertyDescriptor(target,key):desc,d;
if(typeofReflect==="object"&&typeofReflect.decorate==="function")r=Reflect.decorate(decorators,target,key,desc);
elsefor(vari=decorators.length-1;i>=0;i--)if(d=decorators[i])r=(c<3?d(r):c>3?d(target,key,r):d(target,key))||r;
returnc>3&&r&&Object.defineProperty(target,key,r),r;
var__metadata=(this&&this.__metadata)||function(k,v){
if(typeofReflect==="object"&&typeofReflect.metadata==="function")returnReflect.metadata(k,v);
Object.defineProperty(exports,"__esModule",{value:true});
consttypescript_ioc_1=require("typescript-ioc");
conststate_1=require("../99.core/state");
letCollectUnit=classCollectUnit{
constructor(state){
CollectUnit=__decorate([
typescript_ioc_1.Singleton,
__metadata("design:paramtypes",[state_1.default])
],CollectUnit);
exports.default=CollectUnit;
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
exports.visageMenu=exports.shadeMenu=exports.closeMenu=exports.testMenu=exports.updateMenu=exports.initMenu=void0;
constActMnu=require("../menu.action");
constActPvt=require("../../00.pivot.unit/pivot.action");
constActTrm=require("../../01.terminal.unit/terminal.action");
constActDsk=require("../../96.disk.unit/disk.action");
varbit,lst,dex,src;
constinitMenu=async(cpy,bal,ste)=>{
if(bal==null)
bal={idx:null};
bit=awaitste.hunt(ActTrm.INIT_TERMINAL,{});
(0,exports.updateMenu)(cpy,bal,ste);
exports.initMenu=initMenu;
constupdateMenu=async(cpy,bal,ste)=>{
bit=awaitste.hunt(ActTrm.WRITE_TERMINAL,{src:"-----------",bit:'local'});
bit=awaitste.hunt(ActTrm.WRITE_TERMINAL,{src:"PIVOTPIVOTV0",bit:'local'});
bit=awaitste.hunt(ActTrm.WRITE_TERMINAL,{src:"-----------",bit:"local"});
varlst=[ActMnu.UNIT_MENU,ActPvt.UPDATE_PIVOT,ActPvt.COUNT_PIVOT,ActPvt.CREATE_PIVOT,
ActPvt.BUNDLE_PIVOT,ActDsk.SWATCH_DISK,
ActDsk.COLOR_DISK
bit=awaitste.hunt(ActTrm.UPDATE_TERMINAL,{lst});
bit=bit.trmBit;
varidx=lst[bit.val];
switch(idx){
caseActPvt.COUNT_PIVOT:
bit=awaitste.hunt(ActTrm.WRITE_TERMINAL,{src:"count-menu"});
bit=awaitste.hunt(ActPvt.COUNT_PIVOT,{});
bit=awaitste.hunt(ActTrm.WRITE_TERMINAL,{val:2,src:JSON.stringify(bit)});
setTimeout(()=>(0,exports.updateMenu)(cpy,bal,ste),3333);
break;
caseActDsk.SWATCH_DISK:
bit=awaitste.hunt(ActTrm.INPUT_TERMINAL,{lst:["","","SwatchColor..."]});
idx=bit.trmBit.src;
bit=awaitste.hunt(ActDsk.SWATCH_DISK,{idx});
break;
caseActDsk.COLOR_DISK:
bit=awaitste.hunt(ActDsk.COLOR_DISK,{src:'./data/swatch.png'});
break;
caseActPvt.OPEN_PIVOT:
bit=awaitste.hunt(ActPvt.OPEN_PIVOT,{});
break;
caseActPvt.UPDATE_PIVOT:
bit=awaitste.hunt(ActPvt.LIST_PIVOT);
lst=bit.pvtBit.lst;
bit=awaitste.hunt(ActTrm.UPDATE_TERMINAL,{lst});
varval=bit.trmBit.val;
varsrc=lst[val];
bit=awaitste.hunt(ActPvt.UPDATE_PIVOT,{src});
lst=bit.pvtBit.lst;
lst.forEach((a)=>{
ste.hunt(ActTrm.WRITE_TERMINAL,{val:3,src:a});
});
break;
caseActMnu.UNIT_MENU:
bit=awaitste.hunt(ActMnu.UNIT_MENU,{});
break;
caseActPvt.CREATE_PIVOT:
bit=awaitste.hunt(ActTrm.INPUT_TERMINAL,{lst:["","","NomPivot..."]});
idx=bit.trmBit.src;
bit=awaitste.hunt(ActTrm.INPUT_TERMINAL,{lst:["","","NamePivot..."]});
src=bit.trmBit.src;
bit=awaitste.hunt(ActTrm.INPUT_TERMINAL,{lst:["","","DexPivot..."]});
dex=bit.trmBit.src;
bit=awaitste.hunt(ActPvt.CREATE_PIVOT,{idx,src,dex});
(0,exports.updateMenu)(cpy,bal,ste);
break;
caseActPvt.EDIT_PIVOT:
bit=awaitste.hunt(ActPvt.EDIT_PIVOT,{});
bit=awaitste.bus(ActTrm.WRITE_TERMINAL,{src:"PATCHING...",bit:'local'});
bit=awaitste.bus(ActTrm.WRITE_TERMINAL,{src:"-----------",bit:"local"});
lst=[ActPvt.PATCH_PIVOT];
bit=awaitste.bus(ActTrm.UPDATE_TERMINAL,{lst});
bit=awaitste.hunt(ActPvt.PATCH_PIVOT,{});
break;
caseActPvt.BUNDLE_PIVOT:
bit=awaitste.hunt(ActPvt.BUNDLE_PIVOT,{});
bit=awaitste.bus(ActTrm.WRITE_TERMINAL,{src:"BUNLDING...",bit:'local'});
bit=awaitste.bus(ActTrm.WRITE_TERMINAL,{src:"-----------",bit:"local"});
bit=awaitste.hunt(ActPvt.LIST_PIVOT);
lst=bit.pvtBit.lst;
bit=awaitste.hunt(ActTrm.UPDATE_TERMINAL,{lst});
varval=bit.trmBit.val;
varsrc=lst[val];
bit=awaitste.hunt(ActPvt.BUNDLE_PIVOT,{src});
break;
default:
bit=awaitawaitste.bus(ActTrm.CLOSE_TERMINAL,{});
break;
(0,exports.updateMenu)(cpy,bal,ste);
exports.updateMenu=updateMenu;
consttestMenu=async(cpy,bal,ste)=>{
exports.testMenu=testMenu;
constcloseMenu=async(cpy,bal,ste)=>{
awaitste.bus(ActTrm.CLOSE_TERMINAL,{});
exports.closeMenu=closeMenu;
constshadeMenu=async(cpy,bal,ste)=>{
exports.shadeMenu=shadeMenu;
varpatch=(ste,type,bale)=>ste.dispatch({type,bale});
constvisageMenu=(cpy,bal,ste)=>{
debugger;
exports.visageMenu=visageMenu;
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
exports.unitMenu=void0;
constActMnu=require("../menu.action");
constActPvt=require("../../00.pivot.unit/pivot.action");
constActTrm=require("../../01.terminal.unit/terminal.action");
constActUnt=require("../../02.unit.unit/unit.action");
varlst,bit,dat,src;
constunitMenu=async(cpy,bal,ste)=>{
varbit;
bit=awaitste.hunt(ActTrm.WRITE_TERMINAL,{val:1,src:""});
bit=awaitste.hunt(ActTrm.WRITE_TERMINAL,{val:1,src:"-----------"});
bit=awaitste.hunt(ActTrm.WRITE_TERMINAL,{val:4,src:"UNITMENU"});
bit=awaitste.hunt(ActTrm.WRITE_TERMINAL,{val:1,src:"-----------"});
varlist=[ActUnt.UPDATE_UNIT,ActUnt.CREATE_UNIT,ActUnt.CODE_UNIT,ActUnt.REPLACE_UNIT];
bit=awaitste.hunt(ActTrm.UPDATE_TERMINAL,{lst:list});
bit=bit.trmBit;
varidx=list[bit.val];
switch(idx){
caseActUnt.CODE_UNIT:
bit=awaitste.hunt(ActPvt.LIST_PIVOT);
list=bit.pvtBit.lst;
bit=awaitste.hunt(ActTrm.UPDATE_TERMINAL,{lst:list});
varval=bit.trmBit.val;
varsrc=list[val];
bit=awaitste.hunt(ActUnt.CODE_UNIT,{src});
(0,exports.unitMenu)(cpy,bal,ste);
break;
caseActUnt.CREATE_UNIT:
bit=awaitste.hunt(ActTrm.INPUT_TERMINAL,{lst:["","","CreateUnit"]});
bal.src=bit.trmBit.src;
bit=awaitste.hunt(ActUnt.CREATE_UNIT,bal);
(0,exports.unitMenu)(cpy,bal,ste);
break;
caseActUnt.REPLACE_UNIT:
varlist=['core','bus','hunt','collect','vurt'];
bit=awaitste.hunt(ActTrm.UPDATE_TERMINAL,{lst:list});
bit=bit.trmBit;
varidx=list[bit.val];
if(idx==null){
bit=awaitste.hunt(ActMnu.CLOSE_MENU,{});
return;
bit=awaitste.hunt(ActUnt.REPLACE_UNIT,{idx});
(0,exports.unitMenu)(cpy,bal,ste);
break;
caseActUnt.UPDATE_UNIT:
bit=awaitste.hunt(ActPvt.LIST_PIVOT,{});
list=bit.pvtBit.lst;
bit=awaitste.hunt(ActTrm.UPDATE_TERMINAL,{lst:list});
varval=bit.trmBit.val;
varsrc=list[val];
bit=awaitste.hunt(ActUnt.LIST_UNIT,{src});
if(bit.untBit.val==0){
bit=awaitste.hunt(ActUnt.FILTER_UNIT,{src});
list=bit.untBit.lst;
bit=awaitste.hunt(ActTrm.UPDATE_TERMINAL,{lst:list});
varval=bit.trmBit.val;
varidx=list[val];
bit=awaitste.hunt(ActUnt.SUBLIST_UNIT,{src,idx});
varsublist=bit.untBit.lst;
bit=awaitste.hunt(ActTrm.UPDATE_TERMINAL,{lst:sublist});
varval=bit.trmBit.val;
varsub=sublist[val];
else{
list=bit.untBit.lst;
bit=awaitste.hunt(ActTrm.UPDATE_TERMINAL,{lst:list});
varval=bit.trmBit.val;
varidx=list[val];
bit=awaitste.hunt(ActTrm.INPUT_TERMINAL,{lst:["","","InputVerb"]});
vardat=bit.trmBit.src;
bit=awaitste.hunt(ActUnt.UPDATE_UNIT,{src,idx,dat,sub});
(0,exports.unitMenu)(cpy,bal,ste);
break;
exports.unitMenu=unitMenu;
varpatch=(ste,type,bale)=>ste.dispatch({type,bale});
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
exports.ContainerMenu=exports.CONTAINER_MENU=exports.VisageMenu=exports.VISAGE_MENU=exports.UnitMenu=exports.UNIT_MENU=exports.CloseMenu=exports.CLOSE_MENU=exports.TestMenu=exports.TEST_MENU=exports.UpdateMenu=exports.UPDATE_MENU=exports.InitMenu=exports.INIT_MENU=void0;
exports.INIT_MENU="[Menuaction]InitMenu";
classInitMenu{
constructor(bale){
this.bale=bale;
this.type=exports.INIT_MENU;
exports.InitMenu=InitMenu;
exports.UPDATE_MENU="[Menuaction]UpdateMenu";
classUpdateMenu{
constructor(bale){
this.bale=bale;
this.type=exports.UPDATE_MENU;
exports.UpdateMenu=UpdateMenu;
exports.TEST_MENU="[Menuaction]TestMenu";
classTestMenu{
constructor(bale){
this.bale=bale;
this.type=exports.TEST_MENU;
exports.TestMenu=TestMenu;
exports.CLOSE_MENU="[Menuaction]CloseMenu";
classCloseMenu{
constructor(bale){
this.bale=bale;
this.type=exports.CLOSE_MENU;
exports.CloseMenu=CloseMenu;
exports.UNIT_MENU="[Menuaction]UnitMenu";
classUnitMenu{
constructor(bale){
this.bale=bale;
this.type=exports.UNIT_MENU;
exports.UnitMenu=UnitMenu;
exports.VISAGE_MENU="[Visageaction]VisageMenu";
classVisageMenu{
constructor(bale){
this.bale=bale;
this.type=exports.VISAGE_MENU;
exports.VisageMenu=VisageMenu;
exports.CONTAINER_MENU="[Visageaction]ContainerMenu";
classContainerMenu{
constructor(bale){
this.bale=bale;
this.type=exports.CONTAINER_MENU;
exports.ContainerMenu=ContainerMenu;
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
exports.unitMenu=exports.shadeMenu=exports.closeMenu=exports.testMenu=exports.updateMenu=exports.initMenu=void0;
var_00_menu_buzz_1=require("./buz/00.menu.buzz");
Object.defineProperty(exports,"initMenu",{enumerable:true,get:function(){return_00_menu_buzz_1.initMenu;}});
var_00_menu_buzz_2=require("./buz/00.menu.buzz");
Object.defineProperty(exports,"updateMenu",{enumerable:true,get:function(){return_00_menu_buzz_2.updateMenu;}});
var_00_menu_buzz_3=require("./buz/00.menu.buzz");
Object.defineProperty(exports,"testMenu",{enumerable:true,get:function(){return_00_menu_buzz_3.testMenu;}});
var_00_menu_buzz_4=require("./buz/00.menu.buzz");
Object.defineProperty(exports,"closeMenu",{enumerable:true,get:function(){return_00_menu_buzz_4.closeMenu;}});
var_00_menu_buzz_5=require("./buz/00.menu.buzz");
Object.defineProperty(exports,"shadeMenu",{enumerable:true,get:function(){return_00_menu_buzz_5.shadeMenu;}});
varunit_menu_1=require("./buz/unit-menu");
Object.defineProperty(exports,"unitMenu",{enumerable:true,get:function(){returnunit_menu_1.unitMenu;}});
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
exports.MenuModel=void0;
classMenuModel{
constructor(){
this.lst=[];
exports.MenuModel=MenuModel;
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
exports.reducer=void0;
constclone=require("clone-deep");
constAct=require("./menu.action");
constmenu_model_1=require("./menu.model");
constBuzz=require("./menu.buzzer");
functionreducer(model=newmenu_model_1.MenuModel(),act,state){
switch(act.type){
caseAct.UPDATE_MENU:
returnBuzz.updateMenu(clone(model),act.bale,state);
caseAct.INIT_MENU:
returnBuzz.initMenu(clone(model),act.bale,state);
caseAct.TEST_MENU:
returnBuzz.testMenu(clone(model),act.bale,state);
caseAct.CLOSE_MENU:
returnBuzz.closeMenu(clone(model),act.bale,state);
caseAct.UNIT_MENU:
returnBuzz.unitMenu(clone(model),act.bale,state);
caseAct.UNIT_MENU:
returnBuzz.unitMenu(clone(model),act.bale,state);
default:
returnmodel;
exports.reducer=reducer;
"usestrict";
var__decorate=(this&&this.__decorate)||function(decorators,target,key,desc){
varc=arguments.length,r=c<3?target:desc===null?desc=Object.getOwnPropertyDescriptor(target,key):desc,d;
if(typeofReflect==="object"&&typeofReflect.decorate==="function")r=Reflect.decorate(decorators,target,key,desc);
elsefor(vari=decorators.length-1;i>=0;i--)if(d=decorators[i])r=(c<3?d(r):c>3?d(target,key,r):d(target,key))||r;
returnc>3&&r&&Object.defineProperty(target,key,r),r;
var__metadata=(this&&this.__metadata)||function(k,v){
if(typeofReflect==="object"&&typeofReflect.metadata==="function")returnReflect.metadata(k,v);
Object.defineProperty(exports,"__esModule",{value:true});
consttypescript_ioc_1=require("typescript-ioc");
conststate_1=require("../99.core/state");
letMenuUnit=classMenuUnit{
constructor(state){
MenuUnit=__decorate([
typescript_ioc_1.Singleton,
__metadata("design:paramtypes",[state_1.default])
],MenuUnit);
exports.default=MenuUnit;
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
exports.CreateBus=exports.CREATE_BUS=exports.UpdateBus=exports.UPDATE_BUS=exports.MessageBus=exports.MESSAGE_BUS=exports.ConnectBus=exports.CONNECT_BUS=exports.OpenBus=exports.OPEN_BUS=exports.InitBus=exports.INIT_BUS=void0;
exports.INIT_BUS="[Busaction]InitBus";
classInitBus{
constructor(bale){
this.bale=bale;
this.type=exports.INIT_BUS;
exports.InitBus=InitBus;
exports.OPEN_BUS="[Busaction]OpenBus";
classOpenBus{
constructor(bale){
this.bale=bale;
this.type=exports.OPEN_BUS;
exports.OpenBus=OpenBus;
exports.CONNECT_BUS="[Busaction]ConnectBus";
classConnectBus{
constructor(bale){
this.bale=bale;
this.type=exports.CONNECT_BUS;
exports.ConnectBus=ConnectBus;
exports.MESSAGE_BUS="[Busaction]MessageBus";
classMessageBus{
constructor(bale){
this.bale=bale;
this.type=exports.MESSAGE_BUS;
exports.MessageBus=MessageBus;
exports.UPDATE_BUS="[Busaction]UpdateBus";
classUpdateBus{
constructor(bale){
this.bale=bale;
this.type=exports.UPDATE_BUS;
exports.UpdateBus=UpdateBus;
exports.CREATE_BUS="[Busaction]CreateBus";
classCreateBus{
constructor(bale){
this.bale=bale;
this.type=exports.CREATE_BUS;
exports.CreateBus=CreateBus;
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
exports.createBus=exports.messageBus=exports.connectBus=exports.updateBus=exports.openBus=exports.initBus=void0;
varbus_buzz_1=require("./buz/bus.buzz");
Object.defineProperty(exports,"initBus",{enumerable:true,get:function(){returnbus_buzz_1.initBus;}});
varbus_buzz_2=require("./buz/bus.buzz");
Object.defineProperty(exports,"openBus",{enumerable:true,get:function(){returnbus_buzz_2.openBus;}});
varbus_buzz_3=require("./buz/bus.buzz");
Object.defineProperty(exports,"updateBus",{enumerable:true,get:function(){returnbus_buzz_3.updateBus;}});
varbus_buzz_4=require("./buz/bus.buzz");
Object.defineProperty(exports,"connectBus",{enumerable:true,get:function(){returnbus_buzz_4.connectBus;}});
varbus_buzz_5=require("./buz/bus.buzz");
Object.defineProperty(exports,"messageBus",{enumerable:true,get:function(){returnbus_buzz_5.messageBus;}});
varbus_buzz_6=require("./buz/bus.buzz");
Object.defineProperty(exports,"createBus",{enumerable:true,get:function(){returnbus_buzz_6.createBus;}});
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
exports.BusModel=void0;
classBusModel{
constructor(){
this.responseSuffix='-response';
this.promises={};
exports.BusModel=BusModel;
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
exports.reducer=void0;
constclone=require("clone-deep");
constAct=require("./bus.action");
constbus_model_1=require("./bus.model");
constBuzz=require("./bus.buzzer");
functionreducer(model=newbus_model_1.BusModel(),act,state){
switch(act.type){
caseAct.UPDATE_BUS:
returnBuzz.updateBus(clone(model),act.bale,state);
caseAct.OPEN_BUS:
returnBuzz.openBus(clone(model),act.bale,state);
caseAct.CONNECT_BUS:
returnBuzz.connectBus(clone(model),act.bale,state);
caseAct.CREATE_BUS:
returnBuzz.createBus(clone(model),act.bale,state);
caseAct.MESSAGE_BUS:
returnBuzz.connectBus(clone(model),act.bale,state);
caseAct.INIT_BUS:
returnBuzz.initBus(clone(model),act.bale,state);
default:
returnmodel;
exports.reducer=reducer;
"usestrict";
var__decorate=(this&&this.__decorate)||function(decorators,target,key,desc){
varc=arguments.length,r=c<3?target:desc===null?desc=Object.getOwnPropertyDescriptor(target,key):desc,d;
if(typeofReflect==="object"&&typeofReflect.decorate==="function")r=Reflect.decorate(decorators,target,key,desc);
elsefor(vari=decorators.length-1;i>=0;i--)if(d=decorators[i])r=(c<3?d(r):c>3?d(target,key,r):d(target,key))||r;
returnc>3&&r&&Object.defineProperty(target,key,r),r;
var__metadata=(this&&this.__metadata)||function(k,v){
if(typeofReflect==="object"&&typeofReflect.metadata==="function")returnReflect.metadata(k,v);
Object.defineProperty(exports,"__esModule",{value:true});
consttypescript_ioc_1=require("typescript-ioc");
conststate_1=require("../99.core/state");
letBusUnit=classBusUnit{
constructor(state){
BusUnit=__decorate([
typescript_ioc_1.Singleton,
__metadata("design:paramtypes",[state_1.default])
],BusUnit);
exports.default=BusUnit;
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
exports.updateBus=exports.messageBus=exports.connectBus=exports.openBus=exports.createBus=exports.initBus=void0;
constActMnu=require("../../98.menu.unit/menu.action");
constActBus=require("../../99.bus.unit/bus.action");
constActCol=require("../../97.collect.unit/collect.action");
varlst,idx,bit,src,dat,dex;
constinitBus=(cpy,bal,ste)=>{
cpy.actList=[];
if(bal==null)
bal={idx:null};
if(bal.lst==null)
bal.lst=[];
if((bal.src!=null)&&(bal.src.constructor==Array))
lst=bal.src;
bal.lst.forEach((a)=>{
for(varkeyina){
cpy.actList.push(a[key]);
});
ste.bus=(idx,dat,bit)=>(0,exports.updateBus)(cpy,{idx,dat,bit},ste);
if(bal.dat!=null){
cpy.MQTT=bal.dat;
else{
if(lst==null){
if(bal.src!=null)
cpy.host=bal.src;
cpy.client=cpy.MQTT.connect(cpy.host);
cpy.client.on('message',(tpc,msg)=>{(0,exports.messageBus)(cpy,{idx:tpc,src:msg},ste);});
cpy.client.on('connect',async()=>{
(0,exports.openBus)(cpy,{idx:'init-bus',lst:cpy.actList},ste);
if(bal.slv!=null)
bal.slv({intBit:{idx:"init-bus"}});
});
else{
varcomplete=(lst)=>{
lst.shift();
if(lst.length!=0)
return;
if(bal.slv!=null)
bal.slv({intBit:{idx:"init-bus"}});
lst.forEach(async(a)=>{
bit=awaitste.hunt(ActCol.WRITE_COLLECT,{idx:a.idx,src:a.src,bit:ActBus.CREATE_BUS});
varclient=bit.clcBit.dat;
client.on('message',(tpc,msg)=>{(0,exports.messageBus)(cpy,{idx:tpc,src:msg,bit:a.idx},ste);});
client.on('connect',()=>{
(0,exports.openBus)(cpy,{idx:'init-bus',lst:cpy.actList,bit:a.idx},ste);
complete(lst);
});
});
exports.initBus=initBus;
constcreateBus=(cpy,bal,ste)=>{
varclient=cpy.MQTT.connect(bal.src);
if(bal.slv!=null)
bal.slv({busBit:{idx:"create-bus",dat:client}});
exports.createBus=createBus;
constopenBus=async(cpy,bal,ste)=>{
varout=[];
bal.lst.forEach((a)=>{
if(a==null)
return;
if(a.includes==null)
return;
if(a.includes('[')&&a.includes(']')==false)
return;
out.push(a);
});
varclient=cpy.client;
if(bal.bit!=null){
bit=awaitste.hunt(ActCol.READ_COLLECT,{idx:bal.bit,bit:ActBus.CREATE_BUS});
client=bit.clcBit.dat;
out.forEach((a)=>{
client.subscribe(a,(err)=>{
if(!err){
});
});
exports.openBus=openBus;
constconnectBus=(cpy,bal,ste)=>{
varlst=[];
if(bal.val==1)
patch(ste,ActMnu.INIT_MENU,{lst});
exports.connectBus=connectBus;
constmessageBus=async(cpy,bal,ste)=>{
if(bal.src!=null)
dat=bal.src.toString();
idx=bal.idx;
dat=JSON.parse(dat);
varclient=cpy.client;
if(bal.bit!=null){
bit=awaitste.hunt(ActCol.READ_COLLECT,{idx:bal.bit,bit:ActBus.CREATE_BUS});
client=bit.clcBit.dat;
if(idx.includes(cpy.responseSuffix)==true){
varresponseIDX=bal.idx;
varobj=cpy.promises[responseIDX];
if(obj.slv!=null)
obj.slv(dat);
client.unsubscribe(responseIDX,(err)=>{
if(!err){
});
else{
varbit=awaitste.hunt(idx,dat);
varcloneBit=clone(bit);
for(varkeyincloneBit){
varitm=cloneBit[key];
if(itm.dat!=null){
if(itm.dat.bit!=null)
itm.dat.bit=null;
cloneBit;
client.publish(bal.idx+cpy.responseSuffix,JSON.stringify(cloneBit));
exports.messageBus=messageBus;
constupdateBus=async(cpy,bal,ste)=>{
varclient=cpy.client;
if(bal.bit!=null){
bit=awaitste.hunt(ActCol.READ_COLLECT,{idx:bal.bit,bit:ActBus.CREATE_BUS});
client=bit.clcBit.dat;
if((client==null)&&(bal.bit==null)){
bit=awaitste.hunt(ActCol.FETCH_COLLECT,{bit:ActBus.CREATE_BUS});
client=bit.clcBit.dat;
varresponseIDX=bal.idx+cpy.responseSuffix;
varslv;
constpromo=newPromise((rslv,rjct)=>(slv=rslv));
varobj={slv:(val0)=>slv(val0)};
cpy.promises[responseIDX]=obj;
client.subscribe(responseIDX,(err)=>{
if(!err){
});
client.publish(bal.idx,JSON.stringify(bal.dat));
returnpromo;
exports.updateBus=updateBus;
varpatch=(ste,type,bale)=>ste.dispatch({type,bale});
constclone=require("clone-deep");
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
constrx_lite_1=require("rx-lite");
constrx_lite_2=require("rx-lite");
constBEE_1=require("../BEE");
constEffect=require("../BEE");
classStateextendsrx_lite_1.BehaviorSubject{
constructor(init=newBEE_1.default()){
super(init);
this.dispatcher=newrx_lite_2.Subject();
this.dispatcher
.scan((state,action)=>this.reducedApp(state,action),init)
.subscribe((state)=>{
super.onNext(state);
});
reducedApp(nextState,key){
for(varkinEffect.reducer)
Effect.reducer[k](nextState[k],key,this);
returnnextState;
dispatch(value){
varresult=this.dispatcher.onNext(value);
returnresult;
pat(value){
this.dispatch(value);
next(value){
this.dispatcher.onNext(value);
exports.default=State;
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
exports.COPY_DISK=exports.LOAD_LIST_DISK=exports.LIST_DISK=exports.WRITE_DISK=exports.READ_DISK=exports.UPDATE_DISK=exports.INIT_DISK=void0;
exports.INIT_DISK="[Diskaction]InitDisk";
exports.UPDATE_DISK="[Diskaction]UpdateDisk";
exports.READ_DISK="[Diskaction]ReadDisk";
exports.WRITE_DISK="[Diskaction]WriteDisk";
exports.LIST_DISK="[Listaction]ListDisk";
exports.LOAD_LIST_DISK="[Load_listaction]Load_listDisk";
exports.COPY_DISK="[Copyaction]CopyDisk";
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
exports.OPEN_RENPY=exports.UPDATE_RENPY=exports.INIT_RENPY=void0;
exports.INIT_RENPY="[Renpyaction]InitRenpy";
exports.UPDATE_RENPY="[Renpyaction]UpdateRenpy";
exports.OPEN_RENPY="[Renpyaction]OpenRenpy";
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
exports.OPEN_SHINY=exports.UPDATE_SHINY=exports.INIT_SHINY=void0;
exports.INIT_SHINY="[Shinyaction]InitShiny";
exports.UPDATE_SHINY="[Shinyaction]UpdateShiny";
exports.OPEN_SHINY="[Shinyaction]OpenShiny";
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
exports.READY_SPACE=exports.UPDATE_SPACE=exports.INIT_SPACE=void0;
exports.INIT_SPACE="[Spaceaction]InitSpace";
exports.UPDATE_SPACE="[Spaceaction]UpdateSpace";
exports.READY_SPACE="[Readyaction]ReadySpace";
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
exports.ADD_PORT=exports.CONTENT_TERMINAL=exports.ROOT_TERMINAL=exports.CLOSE_TERMINAL=exports.TABLE_TERMINAL=exports.INPUT_TERMINAL=exports.CLEAR_TERMINAL=exports.UPDATE_TERMINAL=exports.WRITE_TERMINAL=exports.FOCUS_TERMINAL=exports.OPEN_TERMINAL=exports.INIT_TERMINAL=void0;
exports.INIT_TERMINAL="[Terminalaction]InitTerminal";
exports.OPEN_TERMINAL="[Terminalaction]OpenTerminal";
exports.FOCUS_TERMINAL="[Terminalaction]FocusTerminal";
exports.WRITE_TERMINAL="[Terminalaction]WriteTerminal";
exports.UPDATE_TERMINAL="[Terminalaction]UpdateTerminal";
exports.CLEAR_TERMINAL="[Terminalaction]ClearTerminal";
exports.INPUT_TERMINAL="[Terminalaction]InputTerminal";
exports.TABLE_TERMINAL="[Terminalaction]TableTerminal";
exports.CLOSE_TERMINAL="[Terminalaction]CloseTerminal";
exports.ROOT_TERMINAL="[Terminalaction]RootTerminal";
exports.CONTENT_TERMINAL="[Terminalaction]ContentTerminal";
exports.ADD_PORT="[Terminalaction]AddPort";
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
exports.VALUE_VURT=exports.BUNDLE_VURT=exports.CONTAINS_VURT=exports.LIST_UNIT_VURT=exports.LIST_PIVOT_VURT=exports.COUNT_VURT=exports.UNIT_VURT=exports.REPLACE_VURT=exports.UPDATE_VURT=exports.FETCH_VURT=exports.TEST_CLOUD_VURT=exports.DELAY_VURT=exports.INIT_VURT=void0;
exports.INIT_VURT="[Vurtaction]InitVurt";
exports.DELAY_VURT="[Vurtaction]DelayVurt";
exports.TEST_CLOUD_VURT="[Vurtaction]TestCloudVurt";
exports.FETCH_VURT="[Vurtaction]FetchVurt";
exports.UPDATE_VURT="[Vurtaction]UpdateVurt";
exports.REPLACE_VURT="[Vurtaction]ReplaceVurt";
exports.UNIT_VURT="[Vurtaction]UnitVurt";
exports.COUNT_VURT="[Vurtaction]CountVurt";
exports.LIST_PIVOT_VURT="[Vurtaction]ListPivotVurt";
exports.LIST_UNIT_VURT="[Vurtaction]ListUnitVurt";
exports.CONTAINS_VURT="[Containsaction]ContainsVurt";
exports.BUNDLE_VURT="[Bundleaction]BundleVurt";
exports.VALUE_VURT="[Valueaction]ValueVurt";
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
exports.reducer=exports.list=void0;
constpivot_unit_1=require("./00.pivot.unit/pivot.unit");
constterminal_unit_1=require("./01.terminal.unit/terminal.unit");
constunit_unit_1=require("./02.unit.unit/unit.unit");
constbitmap_unit_1=require("./03.bitmap.unit/bitmap.unit");
constdisk_unit_1=require("./96.disk.unit/disk.unit");
constcollect_unit_1=require("./97.collect.unit/collect.unit");
constmenu_unit_1=require("./98.menu.unit/menu.unit");
constbus_unit_1=require("./99.bus.unit/bus.unit");
constpivot_model_1=require("./00.pivot.unit/pivot.model");
constterminal_model_1=require("./01.terminal.unit/terminal.model");
constunit_model_1=require("./02.unit.unit/unit.model");
constbitmap_model_1=require("./03.bitmap.unit/bitmap.model");
constdisk_model_1=require("./96.disk.unit/disk.model");
constcollect_model_1=require("./97.collect.unit/collect.model");
constmenu_model_1=require("./98.menu.unit/menu.model");
constbus_model_1=require("./99.bus.unit/bus.model");
exports.list=[pivot_unit_1.default,terminal_unit_1.default,unit_unit_1.default,bitmap_unit_1.default,disk_unit_1.default,collect_unit_1.default,menu_unit_1.default,bus_unit_1.default];
constreduceFromPivot=require("./00.pivot.unit/pivot.reduce");
constreduceFromTerminal=require("./01.terminal.unit/terminal.reduce");
constreduceFromUnit=require("./02.unit.unit/unit.reduce");
constreduceFromBitmap=require("./03.bitmap.unit/bitmap.reduce");
constreduceFromDisk=require("./96.disk.unit/disk.reduce");
constreduceFromCollect=require("./97.collect.unit/collect.reduce");
constreduceFromMenu=require("./98.menu.unit/menu.reduce");
constreduceFromBus=require("./99.bus.unit/bus.reduce");
exports.reducer={
pivot:reduceFromPivot.reducer,
terminal:reduceFromTerminal.reducer,
unit:reduceFromUnit.reducer,
bitmap:reduceFromBitmap.reducer,
disk:reduceFromDisk.reducer,
collect:reduceFromCollect.reducer,
menu:reduceFromMenu.reducer,
bus:reduceFromBus.reducer,
classUnitData{
constructor(){
this.pivot=newpivot_model_1.PivotModel();
this.terminal=newterminal_model_1.TerminalModel();
this.unit=newunit_model_1.UnitModel();
this.bitmap=newbitmap_model_1.BitmapModel();
this.disk=newdisk_model_1.DiskModel();
this.collect=newcollect_model_1.CollectModel();
this.menu=newmenu_model_1.MenuModel();
this.bus=newbus_model_1.BusModel();
exports.default=UnitData;
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
varsim={
hunt:null,
state:null
sim.hunt=(typ,obj)=>{returnhost(obj,typ);};
varhost=(obj,typ)=>{
init();
varslv;
constpromo=newPromise((rslv,rjct)=>(slv=rslv));
if(obj==null)
obj={};
if(obj.slv==null)
obj.slv=(val0)=>slv(val0);
sim.state.dispatch({type:typ,bale:obj});
returnpromo;
varinit=()=>{
if(sim.state!=null)
return;
sim.state=newstate_1.default();
sim.state.pivot=sim;
sim.state.hunt=sim.hunt;
for(varkinImport.list)
newImport.list[k](sim.state);
constImport=require("./BEE");
conststate_1=require("./99.core/state");
module.exports=sim;
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
exports.CYAN=exports.MAGENTA=exports.YELLOW=exports.GREEN=exports.RED=void0;
exports.RED="\x1b[31m%s\x1b[0m";
exports.GREEN="\x1b[32m%s\x1b[0m";
exports.YELLOW="\x1b[33m%s\x1b[0m";
exports.MAGENTA="\x1b[34m%s\x1b[0m";
exports.CYAN="\x1b[36m%s\x1b[0m";
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
exports.WISE_NORTH_EAST=exports.WISE_NORTH=exports.WISE_NORTH_WEST=exports.WISE_WEST=exports.WISE_SOUTH_WEST=exports.WISE_SOUTH=exports.WISE_SOUTH_EAST=exports.WISE_EAST=exports.NORTH_EAST=exports.NORTH=exports.NORTH_WEST=exports.WEST=exports.SOUTH_WEST=exports.SOUTH=exports.SOUTH_EAST=exports.EAST=void0;
exports.EAST="E";
exports.SOUTH_EAST="SE";
exports.SOUTH="S";
exports.SOUTH_WEST="SW";
exports.WEST="W";
exports.NORTH_WEST="NW";
exports.NORTH="N";
exports.NORTH_EAST="NE";
exports.WISE_EAST="WiseE";
exports.WISE_SOUTH_EAST="WiseSE";
exports.WISE_SOUTH="WiseS";
exports.WISE_SOUTH_WEST="WiseSW";
exports.WISE_WEST="WiseW";
exports.WISE_NORTH_WEST="WiseNW";
exports.WISE_NORTH="WiseN";
exports.WISE_NORTH_EAST="WiseNE";
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
exports.CIRCLE=exports.ROUNDED_RECTANGLE=exports.RECTANGLE=void0;
exports.RECTANGLE="rectangle";
exports.ROUNDED_RECTANGLE="rounded-rectangle";
exports.CIRCLE="circle";
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
exports.HEXMAP=exports.FOCUS=void0;
exports.FOCUS="focus";
exports.HEXMAP="hexmap";
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
exports.PASTURE=exports.FANG_SWAMP=exports.GEORGIA=exports.GALLBLADDER=void0;
exports.GALLBLADDER="00000.gallbladder";
exports.GEORGIA="00001.georgia";
exports.FANG_SWAMP="00002.fang-swamp";
exports.PASTURE="00003.pasture";
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
exports.MAGENTA=exports.YELLOW=exports.BLUE=exports.GREEN=exports.RED=exports.CYAN=exports.CLEAN=exports.MENU_SINGLE=exports.TIMELINE=exports.SPACE=void0;
exports.SPACE="space";
exports.TIMELINE="timeline";
exports.MENU_SINGLE="menu_single";
exports.CLEAN="clean";
exports.CYAN="cyan";
exports.RED="red";
exports.GREEN="green";
exports.BLUE="blue";
exports.YELLOW="yellow";
exports.MAGENTA="magenta";
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
exports.LOOP=exports.VIDEO=exports.HEXAGON=exports.SPRITE=exports.TEXT=exports.GRAPHIC=exports.CONTAINER=exports.SURFACE=exports.VISAGE=void0;
exports.VISAGE="visage";
exports.SURFACE="surface";
exports.CONTAINER="container";
exports.GRAPHIC="graphic";
exports.TEXT="text";
exports.SPRITE="sprite";
exports.HEXAGON="hexagon";
exports.VIDEO="video";
exports.LOOP="loop";
"usestrict";
Object.defineProperty(exports,"__esModule",{value:true});
exports.MOUNT_WIDTH=exports.MOUNT_HEIGHT=exports.MOUNT_PART=exports.MOUNT_FULL=exports.SCREEN=void0;
exports.SCREEN="screen-visage";
exports.MOUNT_FULL="mount-visage-full";
exports.MOUNT_PART="mount-visage-part";
exports.MOUNT_HEIGHT="mount-visage-height";
exports.MOUNT_WIDTH="mount-visage-width";
module.exports={
'.git',
'.vscode',
'node_modules',
'package.json',
'package-lock.json',
'yarn-lock.json',
'count.output.json',
'dist',
'data',
'public',
'modules'
'.zip','.rar','.png','.jpg','.jpeg','.gif','.bmp','.mp3','.wma','.wav','.mp4','.flv','.mov','.avi','.wmv','.rmvb','.ogg','.avi','.ppt','.pptx','.doc','.docx','.xls','.xlsx','.psd','.ttf','.fon','.exe','.msi',
'ascii',
'utf8',
'utf-8',
'unicode'
ignoreEmptyLine:true,
const{exec}=require("child_process");
constFS=require("fs-extra");
exec("npmrunbuild",async(err,stdout,stderr)=>{
if(err){
console.error(`execerror:${err}`);
varsource='./dist'
varoutput='../glops.ink'
FS.cpSync(source,output,{recursive:true});
exportconstonRequestGet=async()=>{
varqueryFn=async()=>{
if(!response.ok){
thrownewError('Networkresponsewasnotok:okwierdo.onrender.com/api/okwierdo/open')
returnresponse.json()
constbit=awaitqueryFn()
returnnewResponse(JSON.stringify(bit));
exportconstonRequestGet=async(request)=>{
consturl=newURL(request.url);
constidx=url.searchParams.get('idx');
varbit={idx:"onrequestget"+idx}
returnnewResponse(JSON.stringify(bit));
exportconstonRequestGet=async(request)=>{
consturl=newURL(request.url);
constidx=url.searchParams.get('idx');
varqueryFn=async()=>{
if(!response.ok){
thrownewError('Networkresponsewasnotok:okwierdo.onrender.com/api/0kwierdo/funfoot/read')
returnresponse.json()
constbit=awaitqueryFn()
returnnewResponse(JSON.stringify(bit));
exportconstonRequestGet=async(request)=>{
consturl=newURL(request.url);
constidx=url.searchParams.get('idx');
varqueryFn=async()=>{
if(!response.ok){
thrownewError('Networkresponsewasnotok:okwierdo.onrender.com/api/0kwierdo/funfoot/read')
returnresponse.json()
constbit=awaitqueryFn()
returnnewResponse(JSON.stringify(bit));
exportconstonRequestGet=async(context)=>{
varrequest=context.request
const{searchParams}=newURL(request.url)
letidx=searchParams.get('idx')
if(idx==null){
varbitNow={idx:'request-error',src:"noidxpresent"}
returnnewResponse(JSON.stringify(bitNow));
varqueryFn=async()=>{
if(!response.ok){
thrownewError('Networkresponsewasnotok:okwierdo.onrender.com/api/okwierdo/open')
returnresponse.json()
constbit=awaitqueryFn()
returnnewResponse(JSON.stringify(bit));
exportconstonRequestGet=async(context)=>{
varrequest=context.request
const{searchParams}=newURL(request.url)
letidx=searchParams.get('idx')
if(idx==null){
varbitNow={idx:'request-error',src:"noidxpresent"}
returnnewResponse(JSON.stringify(bitNow));
varqueryFn=async()=>{
if(!response.ok){
thrownewError('Networkresponsewasnotok:okwierdo.onrender.com/api/okwierdo/read')
returnresponse.json()
constbit=awaitqueryFn()
returnnewResponse(JSON.stringify(bit));
exportconstonRequestGet=async(context)=>{
varrequest=context.request
const{searchParams}=newURL(request.url)
letidx=searchParams.get('idx')
if(idx==null){
varbitNow={idx:'request-error',src:"noidxpresent"}
returnnewResponse(JSON.stringify(bitNow));
varqueryFn=async()=>{
if(!response.ok){
thrownewError('Networkresponsewasnotok:okwierdo.onrender.com/api/okwierdo/write')
returnresponse.json()
constbit=awaitqueryFn()
returnnewResponse(JSON.stringify(bit));
exportconstonRequestGet=()=>{
returnnewResponse("Hello,world!");
exportconstonRequestPost=async({request})=>{
const{name}=awaitrequest.json();
returnnewResponse(`Hello,${name}!`);
exportconstonRequestGet=async()=>{
varqueryFn=async()=>{
if(!response.ok){
thrownewError('Networkresponsewasnotok')
returnresponse.json()
constbit=awaitqueryFn()
returnnewResponse(JSON.stringify(bit));
exportconstonRequestGet=async()=>{
varqueryFn=async()=>{
if(!response.ok){
thrownewError('Networkresponsewasnotok:okwierdo.onrender.com/api/okwierdo/open')
returnresponse.json()
constbit=awaitqueryFn()
returnnewResponse(JSON.stringify(bit));
addEventListener('fetch',event=>{
event.respondWith(handleRequest(event.request));
asyncfunctionhandleRequest(request){
if(request.method==='POST'&&request.headers.get('Content-Type').startsWith('multipart/form-data')){
try{
constformData=awaitrequest.formData();
method:'POST',
headers:{
constresponse=awaitfetch(nextJsRequest);
returnnewResponse(response.body,{
status:response.status,
headers:response.headers
}catch(error){
console.error('Errorforwardingrequest:',error);
returnnewResponse('InternalServerError',{status:500});
}else{
returnnewResponse('MethodNotAllowed',{status:405});
constpath=require('path');
varexec=require('child_process').exec;
exec('tsc-b900.fictiq',async(err,stdout,stderr)=>{
if(err){
console.error(`execerror:${err}`);
init();
constinit=async(prt)=>{
PIVOT=require(path.resolve('./999.pivot/index'));
PIVOT_ACTION=require(path.resolve('./999.pivot/00.pivot.unit/pivot.action'));
awaitPIVOT.hunt(PIVOT_ACTION.INIT_PIVOT,{val:1,dat:null,src:null});
module.exports={
plugins:{
'postcss-preset-mantine':{},
'postcss-simple-vars':{
variables:{
'mantine-breakpoint-xs':'36em',
'mantine-breakpoint-sm':'48em',
'mantine-breakpoint-md':'62em',
'mantine-breakpoint-lg':'75em',
'mantine-breakpoint-xl':'88em',
import{defineConfig}from'@rsbuild/core';
import{pluginReact}from'@rsbuild/plugin-react';
import{pluginNodePolyfill}from"@rsbuild/plugin-node-polyfill";
exportdefaultdefineConfig({
plugins:[pluginReact(),pluginNodePolyfill()],
constpath=require('path');
constfs=require('fs');
const{program}=require('commander');
varidx;
program.option('--first').option('-t,--separator<char>');
program.parse(process.argv);
constoptions=program.opts();
if(options['separator']!=null)idx=options['separator'];
consttitle=idx;
varexec=require('child_process').exec;
exec('tsc-b995.library',async(err,stdout,stderr)=>{
if(err){
console.error(`execerror:${err}`);
init()
constinit=async()=>{
LIBRARY=require(path.resolve('./dist/995.library/hunt'));
LIBRARY_ACTION=require(path.resolve('./dist/995.library/00.library.unit/library.action'));
awaitLIBRARY.hunt(LIBRARY_ACTION.INIT_LIBRARY,{val:1,dat:null,src:null});